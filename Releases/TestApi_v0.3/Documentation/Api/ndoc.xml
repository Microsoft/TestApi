<?xml version="1.0" encoding="utf-8"?>
<ndoc SchemaVersion="2.0" xmlns="urn:ndoc-schema">
  <threadsafety static="true" instance="false" />
  <namespaceHierarchies>
    <namespaceHierarchy name="Microsoft.Test">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.AutomationUtilities" displayName="AutomationUtilities" namespace="Microsoft.Test" assembly="TestApiWpf" />
        <hierarchyType id="T:Microsoft.Test.DispatcherOperations" displayName="DispatcherOperations" namespace="Microsoft.Test" assembly="TestApiWpf" />
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.Input">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.Input.Keyboard" displayName="Keyboard" namespace="Microsoft.Test.Input" assembly="TestApiWpf" />
        <hierarchyType id="T:Microsoft.Test.Input.Mouse" displayName="Mouse" namespace="Microsoft.Test.Input" assembly="TestApiWpf" />
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.VariationGeneration">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Model" displayName="Model" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Parameter" displayName="Parameter" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.ICollection`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IEnumerable`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IList`1" displayName="IList(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IList`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" fullName="System.Collections.IEnumerable" assembly="mscorlib" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary(TKey,TValue)" namespace="System.Collections.Generic" assembly="mscorlib">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.ICollection`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IDictionary`2" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IEnumerable`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" fullName="System.Collections.ICollection" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" fullName="System.Collections.IDictionary" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" fullName="System.Collections.IEnumerable" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.IDeserializationCallback" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.ISerializable" assembly="mscorlib" />
          </hierarchyInterfaces>
          <hierarchyType id="T:Microsoft.Test.VariationGeneration.Variation" displayName="Variation" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.ApplicationControl">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" displayName="WpfInProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          </hierarchyType>
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" displayName="OutOfProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" displayName="IAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl" displayName="IOutOfProcessAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" displayName="IAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" fullName="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" displayName="UIAutomationOutOfProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" fullName="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" displayName="WpfInProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" fullName="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:System.EventArgs" displayName="EventArgs" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" displayName="AutomatedApplicationEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs" displayName="AutomatedApplicationFocusChangedEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
        <hierarchyType id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.InProcessApplication" displayName="InProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplication" displayName="OutOfProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
        <hierarchyType id="T:System.ValueType" displayName="ValueType" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:System.Enum" displayName="Enum" namespace="System" assembly="mscorlib">
            <hierarchyInterfaces>
              <hierarchyInterface id="T:System.IComparable" displayName="IComparable" namespace="System" fullName="System.IComparable" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IConvertible" displayName="IConvertible" namespace="System" fullName="System.IConvertible" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IFormattable" displayName="IFormattable" namespace="System" fullName="System.IFormattable" assembly="mscorlib" />
            </hierarchyInterfaces>
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" displayName="AutomatedApplicationEventType" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" displayName="InProcessApplicationType" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.VariationGeneration.Constraints">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore">
          <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" displayName="AndConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" displayName="EqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" displayName="GreaterThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" displayName="GreaterThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" displayName="LessThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" displayName="LessThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" displayName="NotConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" displayName="NotEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" displayName="OrConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          </hierarchyType>
          <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" displayName="IfThenConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers" displayName="ConstraintHelpers" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.VisualVerification">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.VisualVerification.ColorDifference" displayName="ColorDifference" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VisualVerification.Histogram" displayName="Histogram" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VisualVerification.Snapshot" displayName="Snapshot" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.ICloneable" displayName="ICloneable" namespace="System" fullName="System.ICloneable" assembly="mscorlib" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore">
          <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotColorVerifier" displayName="SnapshotColorVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier" displayName="SnapshotHistogramVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier" displayName="SnapshotToleranceMapVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:System.ValueType" displayName="ValueType" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:System.Enum" displayName="Enum" namespace="System" assembly="mscorlib">
            <hierarchyInterfaces>
              <hierarchyInterface id="T:System.IComparable" displayName="IComparable" namespace="System" fullName="System.IComparable" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IConvertible" displayName="IConvertible" namespace="System" fullName="System.IConvertible" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IFormattable" displayName="IFormattable" namespace="System" fullName="System.IFormattable" assembly="mscorlib" />
            </hierarchyInterfaces>
            <hierarchyType id="T:Microsoft.Test.VisualVerification.VerificationResult" displayName="VerificationResult" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" displayName="WindowSnapshotMode" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.CommandLineParsing">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.CommandLineParsing.Command" displayName="Command" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.CommandLineParsing.CommandLineParser" displayName="CommandLineParser" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        <hierarchyType id="T:System.Attribute" displayName="Attribute" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.RequiredAttribute" displayName="RequiredAttribute" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary(TKey,TValue)" namespace="System.Collections.Generic" assembly="mscorlib">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.ICollection`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IDictionary`2" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IEnumerable`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" fullName="System.Collections.ICollection" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" fullName="System.Collections.IDictionary" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" fullName="System.Collections.IEnumerable" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.IDeserializationCallback" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.ISerializable" assembly="mscorlib" />
          </hierarchyInterfaces>
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" displayName="CommandLineDictionary" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:System.ComponentModel.TypeConverter" displayName="TypeConverter" namespace="System.ComponentModel" assembly="System">
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter" displayName="DirectoryInfoConverter" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.FileInfoConverter" displayName="FileInfoConverter" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.Text">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.Text.StringFactory" displayName="StringFactory" namespace="Microsoft.Test.Text" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.Text.StringProperties" displayName="StringProperties" namespace="Microsoft.Test.Text" assembly="TestApiCore" />
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.FaultInjection">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.FaultInjection.BuiltInConditions" displayName="BuiltInConditions" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.BuiltInFaults" displayName="BuiltInFaults" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.CallStack" displayName="CallStack" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.ComRegistrar" displayName="ComRegistrar" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultDispatcher" displayName="FaultDispatcher" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultRule" displayName="FaultRule" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultSession" displayName="FaultSession" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.ICondition" displayName="ICondition" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.IFault" displayName="IFault" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.RuntimeContext" displayName="RuntimeContext" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.FaultInjection.IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" fullName="Microsoft.Test.FaultInjection.IRuntimeContext" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:System.Exception" displayName="Exception" namespace="System" assembly="mscorlib">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.ISerializable" assembly="mscorlib" />
          </hierarchyInterfaces>
          <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultInjectionException" displayName="FaultInjectionException" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
  </namespaceHierarchies>
  <assembly name="TestApiCore">
    <assemblyReference name="mscorlib" />
    <assemblyReference name="System" />
    <assemblyReference name="System.Core" />
    <assemblyReference name="System.Drawing" />
    <assemblyReference name="System.Xml" />
    <module name="TestApiCore.dll">
      <namespace name="Microsoft.Test.ApplicationControl">
        <class name="ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" access="Public">
          <documentation><summary> Configuration info for an AutomatedApplication </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" displayName="OutOfProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.ApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.ApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.ApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
        <class name="AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" access="Public" abstract="true">
          <documentation><summary> Loads and starts a test application either in the current process or in a new, separate process. </summary>
<remarks> Represents the 'Abstraction' in Bridge pattern. </remarks>
<example> The following example shows in-process usage. The code runs the target application in a separate thread within the current process. <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new InProcessApplication(new WpfInProcessApplicationSettings
   {
        Path = path,
        InProcessApplicationType = InProcessApplicationType.InProcessSeparateThread,
        ApplicationImplementationFactory = new WpfInProcessApplicationFactory()
   });

   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example>
<example> The following example demonstrates out-of-process usage: <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new OutOfProcessApplication(new OutOfProcessApplicationSettings
   {
       ProcessStartInfo = new ProcessStartInfo(path),
       ApplicationImplementationFactory = new UIAutomationOutOfProcessApplicationFactory()
   });
 
   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example></documentation>
          <baseType name="MarshalByRefObject" id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.InProcessApplication" displayName="InProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplication" displayName="OutOfProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.#ctor" access="Family" contract="Normal">
            <documentation><summary> AutomatedApplication objects are instantiated internally. </summary></documentation>
          </constructor>
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.MainWindow" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> The main window of the test application. </summary>
<remarks> This is an AutomationElement for an OutOfProcessApplication and a System.Windows.Window for an InProcessApplication. </remarks></documentation>
          </property>
          <property name="ApplicationImplementation" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.ApplicationImplementation" access="Family" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" valueType="false" get="Family" set="Family">
            <documentation><summary> Gets or sets the automated application implementation. </summary>
<remarks> This is the 'implementation' following the bridge pattern. </remarks></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.IsMainWindowOpened" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" get="Family" set="false">
            <documentation><summary> Indicates whether the main window of the test application is open. </summary></documentation>
          </property>
          <property name="IsApplicationRunning" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.IsApplicationRunning" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" get="Family" set="Family">
            <documentation><summary> Indicates whether the test application is running. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.Start" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Starts the test application after validating its settings. </summary>
<remarks> Refined abstractions are expected to initialize AutomatedAppImp and call AutomatedAppImp.Start(). </remarks></documentation>
          </method>
          <method name="WaitForMainWindow" displayName="WaitForMainWindow" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.WaitForMainWindow(System.TimeSpan)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to display its main window. </summary>
<remarks> Blocks execution of the current thread until the window is displayed or until the specified timeout interval elapses. </remarks>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="WaitForWindow" displayName="WaitForWindow" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.WaitForWindow(System.String,System.TimeSpan)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to display a window with a specified name. </summary>
<remarks> Blocks execution of the current thread until the window is displayed or until the specified timeout interval elapses. </remarks>
<param name="windowName">The window to wait for.</param>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="windowName" typeId="T:System.String" valueType="false" />
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="Close" displayName="Close" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.Close" access="Public" contract="Virtual" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Closes the automated application gracefully. </summary></documentation>
          </method>
          <method name="WaitForInputIdle" displayName="WaitForInputIdle" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.WaitForInputIdle(System.TimeSpan)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to enter an idle state. </summary>
<remarks> Blocks execution of the current thread until the window is displayed or until the specified timeout interval elapses. </remarks>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="AddEventHandler" displayName="AddEventHandler" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.AddEventHandler(Microsoft.Test.ApplicationControl.AutomatedApplicationEventType,System.Delegate)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Adds an event handler for the given AutomatedApplicationEventType. </summary>
<param name="eventType">The type of event to listen for.</param>
<param name="handler">The delegate to be called when the event occurs.</param></documentation>
            <parameter name="eventType" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" />
            <parameter name="handler" typeId="T:System.Delegate" valueType="false" />
          </method>
          <method name="RemoveEventHandler" displayName="RemoveEventHandler" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.RemoveEventHandler(Microsoft.Test.ApplicationControl.AutomatedApplicationEventType,System.Delegate)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Removes an event handler for the given AutomatedApplicationEventType. </summary>
<param name="eventType">The type of event to remove.</param>
<param name="handler">The delegate to remove.</param></documentation>
            <parameter name="eventType" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" />
            <parameter name="handler" typeId="T:System.Delegate" valueType="false" />
          </method>
          <method name="OnMainWindowOpened" displayName="OnMainWindowOpened" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.OnMainWindowOpened(System.Object,System.EventArgs)" access="Family" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Wrapper to signal the MainWindowOpened event </summary>
<param name="sender">The source of the event which is IAutomatedApplicationImpl.</param>
<param name="e">An System.EventArgs that contains no event data.</param></documentation>
            <parameter name="sender" typeId="T:System.Object" valueType="false" />
            <parameter name="e" typeId="T:System.EventArgs" valueType="false" />
          </method>
          <method name="OnFocusChanged" displayName="OnFocusChanged" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.OnFocusChanged(System.Object,System.EventArgs)" access="Family" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Wrapper to signal the FocusChanged event </summary>
<param name="sender">The source of the event which is IAutomatedApplicationImpl.</param>
<param name="e">An System.EventArgs that contains no event data.</param></documentation>
            <parameter name="sender" typeId="T:System.Object" valueType="false" />
            <parameter name="e" typeId="T:System.EventArgs" valueType="false" />
          </method>
          <method name="OnExit" displayName="OnExit" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.OnExit(System.Object,System.EventArgs)" access="Family" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Wrapper to signal the Exited event </summary>
<param name="sender">The source of the event which is IAutomatedApplicationImpl.</param>
<param name="e">An System.EventArgs that contains no event data.</param></documentation>
            <parameter name="sender" typeId="T:System.Object" valueType="false" />
            <parameter name="e" typeId="T:System.EventArgs" valueType="false" />
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.AutomatedApplication.MainWindowOpened" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" multicast="true">
            <documentation><summary> Notifies listeners that the MainWindow of the test application has opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.AutomatedApplication.Exited" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" multicast="true">
            <documentation><summary> Notifies listeners that the test application has exited. </summary></documentation>
          </event>
        </class>
        <class name="AutomatedApplicationEventArgs" displayName="AutomatedApplicationEventArgs" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" access="Public">
          <documentation><summary> Represents the event args passed to AutomatedApplication events. </summary></documentation>
          <baseType name="EventArgs" id="T:System.EventArgs" displayName="EventArgs" namespace="System" assembly="mscorlib" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs" displayName="AutomatedApplicationFocusChangedEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs.#ctor(Microsoft.Test.ApplicationControl.AutomatedApplication)" access="Public" contract="Normal">
            <documentation><summary> Constructs an AutomatedApplicationEventArgs instance with the given AutomatedApplication. </summary>
<param name="automatedApp">The AutomatedApplication data to pass to the listeners.</param></documentation>
            <parameter name="automatedApp" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" />
          </constructor>
          <property name="AutomatedApplication" id="P:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs.AutomatedApplication" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" get="Public" set="Public">
            <documentation><summary> The AutomatedApplication data passed to listeners. </summary></documentation>
          </property>
        </class>
        <class name="AutomatedApplicationFocusChangedEventArgs" displayName="AutomatedApplicationFocusChangedEventArgs" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs" access="Public">
          <documentation><summary> Represents the event args passed to AutomatedApplication focus changed events. </summary></documentation>
          <baseType name="AutomatedApplicationEventArgs" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" displayName="AutomatedApplicationEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="EventArgs" id="T:System.EventArgs" displayName="EventArgs" namespace="System" assembly="mscorlib" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs.#ctor(Microsoft.Test.ApplicationControl.AutomatedApplication,System.Object)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the AutomatedApplicationFocusChangedEventArgs class. </summary>
<param name="automatedApp"> The AutomatedApplication data to pass to the listeners. </param>
<param name="newFocusedElement"> The new focused element data to pass the listeners. This can be an AutomationElement for an out-of-process scenario or a UIElement for an in-process WPF scenario. </param></documentation>
            <parameter name="automatedApp" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" />
            <parameter name="newFocusedElement" typeId="T:System.Object" valueType="false" />
          </constructor>
          <property name="NewFocusedElement" id="P:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs.NewFocusedElement" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> The new focused element passed to the listeners. </summary></documentation>
          </property>
          <property name="AutomatedApplication" id="P:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs.AutomatedApplication" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" get="Public" set="Public">
            <documentation><summary> The AutomatedApplication data passed to listeners. </summary></documentation>
          </property>
        </class>
        <class name="InProcessApplication" displayName="InProcessApplication" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.InProcessApplication" access="Public">
          <documentation><summary> Represents a test application running in the current process. </summary>
<example> The following example demonstrates how to use this class. The code runs the target application in a separate thread within the current process. <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new InProcessApplication(new WpfInProcessApplicationSettings
   {
        Path = path,
        InProcessApplicationType = InProcessApplicationType.InProcessSeparateThread,
        ApplicationImplementationFactory = new WpfInProcessApplicationFactory()
   });

   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example></documentation>
          <baseType name="AutomatedApplication" id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="MarshalByRefObject" id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.InProcessApplication.#ctor(Microsoft.Test.ApplicationControl.InProcessApplicationSettings)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of an InProcessApplication. </summary>
<param name="settings">The settings used to start the test application.</param></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" valueType="false" />
          </constructor>
          <property name="ApplicationDriver" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.ApplicationDriver" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> Access to the UI thread dispatcher. </summary>
<remarks> This is used only for the in-proc/separate thread scenario. </remarks></documentation>
          </property>
          <property name="ApplicationSettings" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.ApplicationSettings" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" valueType="false" get="Public" set="Family">
            <documentation><summary> The settings for the test application. </summary></documentation>
          </property>
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.MainWindow" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Public" set="false">
            <documentation><summary> The main window of the test application. </summary></documentation>
          </property>
          <property name="ApplicationImplementation" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.ApplicationImplementation" access="Family" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Gets or sets the automated application implementation. </summary></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.IsMainWindowOpened" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="false">
            <documentation><summary> Indicates whether the main window of the test application is open. </summary></documentation>
          </property>
          <property name="IsApplicationRunning" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.IsApplicationRunning" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Indicates whether the test application is running. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.InProcessApplication.Start" access="Public" contract="Override" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Creates and starts the test application. </summary>
<remarks> Depending on the AutomatedApplicationType this can be on the same thread or on a separate thread. </remarks></documentation>
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.InProcessApplication.MainWindowOpened" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the MainWindow of the test application has opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.InProcessApplication.Exited" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the test application has exited. </summary></documentation>
          </event>
        </class>
        <class name="InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" access="Public">
          <documentation><summary> Configures an in-process test application. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="ApplicationSettings" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" displayName="WpfInProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Path" id="P:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.Path" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> The application path to test. </summary></documentation>
          </property>
          <property name="InProcessApplicationType" id="P:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.InProcessApplicationType" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" get="Public" set="Public">
            <documentation><summary> The type of test application to create. </summary></documentation>
          </property>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" declaringType="Microsoft.Test.ApplicationControl.ApplicationSettings" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
        <class name="OutOfProcessApplication" displayName="OutOfProcessApplication" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplication" access="Public">
          <documentation><summary> Represents a test application running in a new, separate process. </summary>
<example> The following example demonstrates how to use this class: <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new OutOfProcessApplication(new OutOfProcessApplicationSettings
   {
       ProcessStartInfo = new ProcessStartInfo(path),
       ApplicationImplementationFactory = new UIAutomationOutOfProcessApplicationFactory()
   });
 
   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example></documentation>
          <baseType name="AutomatedApplication" id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="MarshalByRefObject" id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.OutOfProcessApplication.#ctor(Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of an OutOfProcessApplication. </summary>
<param name="settings">The settings used to start the test application.</param></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" valueType="false" />
          </constructor>
          <property name="ApplicationSettings" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.ApplicationSettings" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" valueType="false" get="Public" set="Family">
            <documentation><summary> The settings for the test application. </summary></documentation>
          </property>
          <property name="Process" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.Process" access="Public" contract="Normal" typeId="T:System.Diagnostics.Process" valueType="false" get="Public" set="false">
            <documentation><summary> Get the process associated with the application. </summary></documentation>
          </property>
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.MainWindow" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Public" set="false">
            <documentation><summary> The main window of the test application. </summary></documentation>
          </property>
          <property name="ApplicationImplementation" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.ApplicationImplementation" access="Family" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Gets or sets the automated application implementation. </summary></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.IsMainWindowOpened" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="false">
            <documentation><summary> Indicates whether the main window of the test application is open. </summary></documentation>
          </property>
          <property name="IsApplicationRunning" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.IsApplicationRunning" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Indicates whether the test application is running. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.OutOfProcessApplication.Start" access="Public" contract="Override" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Creates and starts the test application. </summary></documentation>
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.OutOfProcessApplication.MainWindowOpened" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the MainWindow of the test application has opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.OutOfProcessApplication.Exited" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the test application has exited. </summary></documentation>
          </event>
        </class>
        <class name="OutOfProcessApplicationSettings" displayName="OutOfProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" access="Public">
          <documentation><summary> Configures an out-of-process test application. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="ApplicationSettings" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="ProcessStartInfo" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings.ProcessStartInfo" access="Public" contract="Normal" typeId="T:System.Diagnostics.ProcessStartInfo" valueType="false" get="Public" set="Public">
            <documentation><summary> The ProcessStartInfo to start a process. </summary></documentation>
          </property>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" declaringType="Microsoft.Test.ApplicationControl.ApplicationSettings" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
        <interface name="IAutomatedApplicationImpl" displayName="IAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" access="Public">
          <documentation><summary> Defines the contract for an AutomatedApplication. </summary>
<remarks> Represents the 'Implemention' inteface for a bridge pattern. As such, this can vary from the public interface of AutomatedApplication. </remarks></documentation>
          <derivedBy id="T:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl" displayName="IOutOfProcessAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.MainWindow" access="Public" contract="Abstract" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> The test application's main window. </summary></documentation>
          </property>
          <property name="ApplicationDriver" id="P:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.ApplicationDriver" access="Public" contract="Abstract" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> The driver of the test application. </summary></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.IsMainWindowOpened" access="Public" contract="Abstract" typeId="T:System.Boolean" valueType="true" get="Public" set="false">
            <documentation><summary> The value indicating whether the test application's main window has opened. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.Start" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Starts the test application. </summary></documentation>
          </method>
          <method name="Close" displayName="Close" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.Close" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Closes the test application. </summary></documentation>
          </method>
          <method name="WaitForMainWindow" displayName="WaitForMainWindow" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.WaitForMainWindow(System.TimeSpan)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application's main window to open. </summary>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="WaitForWindow" displayName="WaitForWindow" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.WaitForWindow(System.String,System.TimeSpan)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the given window to open. </summary>
<param name="windowName">The window id of the window to wait for.</param>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="windowName" typeId="T:System.String" valueType="false" />
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="WaitForInputIdle" displayName="WaitForInputIdle" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.WaitForInputIdle(System.TimeSpan)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to become idle. </summary>
<param name="timeSpan">The timeout interval.</param></documentation>
            <parameter name="timeSpan" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.MainWindowOpened" access="Public" contract="Abstract" typeId="T:System.EventHandler" valueType="false" multicast="true">
            <documentation><summary> Occurs when the test application's main window is opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.Exited" access="Public" contract="Abstract" typeId="T:System.EventHandler" valueType="false" multicast="true">
            <documentation><summary> Occurs when the test application exits. </summary></documentation>
          </event>
          <event name="FocusChanged" id="E:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.FocusChanged" access="Public" contract="Abstract" typeId="T:System.EventHandler" valueType="false" multicast="true">
            <documentation><summary> Occurs when focus changes. </summary></documentation>
          </event>
        </interface>
        <interface name="IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" access="Public">
          <documentation><summary> Defines the contract for creating an IAutomatedApplicationImpl instance </summary></documentation>
          <implementedBy id="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" displayName="UIAutomationOutOfProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          <implementedBy id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" displayName="WpfInProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          <method name="Create" displayName="Create" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" access="Public" contract="Abstract" valueType="false">
            <returnType type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
            <documentation><summary> Factory method for creating the IAutomatedApplicationImpl instance to be used by AutomatedApplication. </summary>
<param name="settings">The settings to be passed the the implementation instance</param>
<param name="appDomain"> The AppDomain to create the implementation in. This is intended for in-proc scenarios where the AutomatedApplication needs to create the proxy in a separate appdomain. </param>
<returns>Returns the application implementation to be used by AutomatedApplication</returns></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.ApplicationSettings" valueType="false" />
            <parameter name="appDomain" typeId="T:System.AppDomain" valueType="false" />
          </method>
        </interface>
        <interface name="IOutOfProcessAutomatedApplicationImpl" displayName="IOutOfProcessAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl" access="Public">
          <documentation><summary> Defines the contract for an out of process AutomatedApplication. </summary>
<remarks> Represents the 'Implemention' inteface for a bridge pattern. As such, this can vary from the public interface of AutomatedApplication. </remarks></documentation>
          <implements type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" assembly="TestApiCore" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
          <property name="Process" id="P:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl.Process" access="Public" contract="Abstract" typeId="T:System.Diagnostics.Process" valueType="false" get="Public" set="false">
            <documentation><summary> Gets the process associated with the application. </summary></documentation>
          </property>
        </interface>
        <enumeration name="AutomatedApplicationEventType" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" displayName="AutomatedApplicationEventType" namespace="Microsoft.Test.ApplicationControl" access="Public">
          <documentation><summary> Specifies the supported AutomatedApplication events. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <field name="MainWindowOpenedEvent" id="F:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType.MainWindowOpenedEvent" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" literal="true" value="0">
            <documentation><summary> The test application's main window opened event. </summary></documentation>
          </field>
          <field name="ApplicationExitedEvent" id="F:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType.ApplicationExitedEvent" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" literal="true" value="1">
            <documentation><summary> The test application closed event. </summary></documentation>
          </field>
          <field name="FocusChangedEvent" id="F:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType.FocusChangedEvent" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" literal="true" value="2">
            <documentation><summary> The test application's main window's focus changed event. </summary></documentation>
          </field>
        </enumeration>
        <enumeration name="InProcessApplicationType" id="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" displayName="InProcessApplicationType" namespace="Microsoft.Test.ApplicationControl" access="Public">
          <documentation><summary> Defines the Thread and AppDomain properties of an InProcessApplication. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <field name="InProcessSeparateThread" id="F:Microsoft.Test.ApplicationControl.InProcessApplicationType.InProcessSeparateThread" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" literal="true" value="0">
            <documentation><summary> A test application that runs in-process and on a separate thread. </summary></documentation>
          </field>
          <field name="InProcessSeparateThreadAndAppDomain" id="F:Microsoft.Test.ApplicationControl.InProcessApplicationType.InProcessSeparateThreadAndAppDomain" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" literal="true" value="1">
            <documentation><summary> A test application that runs in-process, on a separate thread and in a separate AppDomain. </summary></documentation>
          </field>
          <field name="InProcessSameThread" id="F:Microsoft.Test.ApplicationControl.InProcessApplicationType.InProcessSameThread" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" literal="true" value="2">
            <documentation><summary> A test application that runs in-process and on the same thread. </summary></documentation>
          </field>
        </enumeration>
      </namespace>
      <namespace name="Microsoft.Test.CommandLineParsing">
        <class name="Command" displayName="Command" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.Command" access="Public" abstract="true">
          <documentation><summary> An abstract class describing a command which has a name and an execute method. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.Command.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.Command" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Name" id="P:Microsoft.Test.CommandLineParsing.Command.Name" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The name of the command. The base implementation is to strip off the last instance of "Command" from the end of the type name. So "DiscoverCommand" would become "Discover". If the type name does not have the string "Command" in it, then the name of the command is the same as the type name. This behavior can be overridden, but most derived classes are going to be of the form [Command Name] + Command. </summary></documentation>
          </property>
          <method name="Execute" displayName="Execute" id="M:Microsoft.Test.CommandLineParsing.Command.Execute" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Executes the command. </summary></documentation>
          </method>
        </class>
        <class name="CommandLineDictionary" displayName="CommandLineDictionary" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" access="Public">
          <documentation><summary> A dictionary that is aware of command line input patterns. All lookups for keys ignore case. </summary>
<example> This is a sample for parsing the following command line: Test.exe /verbose /runId=10 <code>        CommandLineDictionary cld = CommandLineDictionary.FromArguments(args);
        bool verbose = cld.ContainsKey("verbose");
        int runId = Int32.Parse(cld["runId"]);

        // You can also explicitly provide key and value identifiers for the cases
        // that use other characters (rather than ‘/’ and ‘=’) as key/value identifiers
        CommandLineDictionary cld = CommandLineDictionary.FromArguments(args, '-', ':');   
</code></example></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="Dictionary`2" id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary`2" namespace="System.Collections.Generic" assembly="mscorlib">
            <genericargument name="System.String" />
            <genericargument name="System.String" />
          </baseType>
          <implementsClass type="System.Collections.Generic.IDictionary`2" id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="TKey" />
            <genericargument name="TValue" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.ICollection`1" id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.IEnumerable`1" id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.IEnumerable" id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.IDictionary" id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.ICollection" id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.ISerializable" id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.IDeserializationCallback" id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" inherited="true" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Create an empty CommandLineDictionary using the default key/value separators of '/' and '='. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" access="Family" contract="Normal" overload="2">
            <documentation><summary> Creates a dictionary using a serialization info and context. This is used for Xml deserialization and isn't normally called from user code. </summary>
<param name="info">Data needed to deserialize the dictionary.</param>
<param name="context">Describes source and destination of the stream.</param></documentation>
            <parameter name="info" typeId="T:System.Runtime.Serialization.SerializationInfo" valueType="false" />
            <parameter name="context" typeId="T:System.Runtime.Serialization.StreamingContext" valueType="true" />
          </constructor>
          <property name="Comparer" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Comparer" access="Public" contract="Normal" typeId="T:System.Collections.Generic.IEqualityComparer`1" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
          </property>
          <property name="Count" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Count" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <implements name="Count" id="P:System.Collections.ICollection.Count" interface="ICollection" assembly="mscorlib" interfaceId="T:System.Collections.ICollection" declaringType="System.Collections.ICollection" />
          </property>
          <property name="Keys" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Keys" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.KeyCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.String" />
          </property>
          <property name="Values" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Values" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.ValueCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.String" />
          </property>
          <property name="Item" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Item(System.String)" access="Public" contract="Final" typeId="T:System.String" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="Public">
            <documentation><summary></summary></documentation>
            <parameter name="key" typeId="T:System.String" valueType="false" />
            <implements name="Item" id="P:System.Collections.Generic.IDictionary`2.Item(System.String)" interface="IDictionary`2" assembly="mscorlib" interfaceId="T:System.Collections.Generic.IDictionary`2" declaringType="System.Collections.Generic.IDictionary`2" />
          </property>
          <method name="FromArguments" displayName="FromArguments" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.FromArguments(System.Collections.Generic.IEnumerable{System.String})" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.CommandLineParsing.CommandLineDictionary" id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" />
            <documentation><summary> Initializes a new instance of the CommandLineDictionary class, populating a dictionary with key/value pairs from a command line that supports syntax where options are provided in the form "/key=value". </summary>
<param name="arguments">Key/value pairs.</param>
<returns></returns></documentation>
            <parameter name="arguments" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="System.String" />
            </parameter>
          </method>
          <method name="FromArguments" displayName="FromArguments" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.FromArguments(System.Collections.Generic.IEnumerable{System.String},System.Char,System.Char)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.CommandLineParsing.CommandLineDictionary" id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" />
            <documentation><summary> Creates a dictionary that is populated with key/value pairs from a command line that supports syntax where options are provided in the form "/key=value". This method supports the ability to specify delimiter characters for options in the command line. </summary>
<param name="arguments">Key/value pairs.</param>
<param name="keyCharacter">A character that precedes a key.</param>
<param name="valueCharacter">A character that separates a key from a value.</param>
<returns></returns></documentation>
            <parameter name="arguments" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="System.String" />
            </parameter>
            <parameter name="keyCharacter" typeId="T:System.Char" valueType="true" />
            <parameter name="valueCharacter" typeId="T:System.Char" valueType="true" />
          </method>
          <method name="ToString" displayName="ToString" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.ToString" access="Public" contract="Override" valueType="false">
            <returnType type="System.String" id="T:System.String" />
            <documentation><summary> Converts dictionary contents to a command line string of key/value pairs. </summary>
<returns>Command line string.</returns></documentation>
          </method>
          <method name="GetObjectData" displayName="GetObjectData" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" access="Public" contract="Override" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Populates a SerializationInfo with data needed to serialize the dictionary. This is used by Xml serialization and isn't normally called from user code. </summary>
<param name="info">SerializationInfo object to populate.</param>
<param name="context">StreamingContext to populate data from.</param></documentation>
            <parameter name="info" typeId="T:System.Runtime.Serialization.SerializationInfo" valueType="false" />
            <parameter name="context" typeId="T:System.Runtime.Serialization.StreamingContext" valueType="true" />
            <implements name="GetObjectData" id="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" interface="ISerializable" interfaceId="T:System.Runtime.Serialization.ISerializable" assembly="mscorlib" declaringType="System.Runtime.Serialization.ISerializable" />
          </method>
        </class>
        <class name="CommandLineParser" displayName="CommandLineParser" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.CommandLineParser" access="Public" static="true">
          <documentation><summary> Provides utilities for parsing command-line values. </summary>
<example> The following example shows how to parse to a strongly typed data structure and to an executable command structure. <code>        // SAMPLE USAGE #1:
        // Sample for parsing the following command-line:
        // Test.exe /verbose /runId=10
        // This sample declares a class in which the strongly typed arguments are populated
        public class CommandLineArguments
        {
           bool? Verbose { get; set; }
           int? RunId { get; set; }
        }
    
        CommandLineArguments cla = new CommandLineArguments();
        cla.ParseArguments(args);
    
        // SAMPLE USAGE #2:
        // Sample for parsing the following command-line:
        // Test.exe run /verbose /id=10
        // In this particular case we have an actual command on the command-line (“run”),
        // which we want to effectively de-serialize and execute.
        public class RunCommand : Command
        {
            bool? Verbose { get; set; }
            int? RunId { get; set; }
 
            public override void Execute()
            {
            }
        }

        Command command = new RunCommand();
        command.ParseArguments(args);
        command.Execute();
</code></example></documentation>
          <method name="ParseArguments" displayName="ParseArguments" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.ParseArguments(System.Object,System.Collections.Generic.IEnumerable{System.String})" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Sets properties on an object from a series of key/value string arguments that are in the form "/PropertyName=Value", where the value is converted from a string into the property type. </summary>
<param name="valueToPopulate">The object to set properties on.</param>
<param name="args">The key/value arguments describing the property names and values to set.</param>
<returns> Indicates whether the properties were successfully set. Reasons for failure reasons include a property name that does not exist or a value that cannot be converted from a string. </returns>
<exception cref="T:System.ArgumentException">Thrown when one of the key/value strings cannot be parsed into a property.</exception></documentation>
            <parameter name="valueToPopulate" typeId="T:System.Object" valueType="false" extension="true" />
            <parameter name="args" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false" extension="true">
              <genericargument name="System.String" />
            </parameter>
          </method>
          <method name="PrintUsage" displayName="PrintUsage" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.PrintUsage(System.Object)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Prints names and descriptions for properties on the specified component. </summary>
<param name="component">The component to print usage for.</param></documentation>
            <parameter name="component" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="PrintCommands" displayName="PrintCommands" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.PrintCommands(System.Collections.Generic.IEnumerable{Microsoft.Test.CommandLineParsing.Command})" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Prints a general summary of each command. </summary>
<param name="commands">A collection of possible commands.</param></documentation>
            <parameter name="commands" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.CommandLineParsing.Command" />
            </parameter>
          </method>
          <method name="ToString" displayName="ToString" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.ToString(System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="System.String" id="T:System.String" />
            <documentation><summary> Creates a string that represents key/value arguments for the properties of the specified object. For example, an object with a name (string) of "example" and a priority value (integer) of 1 translates to '/name=example /priority=1'. This can be used to send data structures through the command line. </summary>
<param name="valueToConvert">Value to create key/value arguments from.</param>
<returns>Space-delimited key/value arguments.</returns></documentation>
            <parameter name="valueToConvert" typeId="T:System.Object" valueType="false" />
          </method>
        </class>
        <class name="DirectoryInfoConverter" displayName="DirectoryInfoConverter" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter" access="Public">
          <documentation><summary> Converter that can convert from a string to a DirectoryInfo. </summary></documentation>
          <baseType name="TypeConverter" id="T:System.ComponentModel.TypeConverter" displayName="TypeConverter" namespace="System.ComponentModel" assembly="System" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter" /> class.</summary>
            </documentation>
          </constructor>
          <method name="ConvertFrom" displayName="ConvertFrom" id="M:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" access="Public" contract="Override" valueType="false" overload="1">
            <returnType type="System.Object" id="T:System.Object" />
            <documentation><summary> Converts from a string to a DirectoryInfo. </summary>
<param name="context">Context.</param>
<param name="culture">Culture.</param>
<param name="value">Value to convert.</param>
<returns>DirectoryInfo, or null if value was null or non-string.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="culture" typeId="T:System.Globalization.CultureInfo" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="CanConvertFrom" displayName="CanConvertFrom" id="M:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)" access="Public" contract="Override" valueType="true" overload="1">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context. </summary>
<param name="context">An ITypeDescriptorContext that provides a format context.</param>
<param name="sourceType">A Type that represents the type you want to convert from.</param>
<returns>True if this converter can perform the conversion; otherwise, False.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="sourceType" typeId="T:System.Type" valueType="false" />
          </method>
        </class>
        <class name="FileInfoConverter" displayName="FileInfoConverter" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.FileInfoConverter" access="Public">
          <documentation><summary> Converter that can convert from a string to a FileInfo. </summary></documentation>
          <baseType name="TypeConverter" id="T:System.ComponentModel.TypeConverter" displayName="TypeConverter" namespace="System.ComponentModel" assembly="System" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.FileInfoConverter.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.FileInfoConverter" /> class.</summary>
            </documentation>
          </constructor>
          <method name="ConvertFrom" displayName="ConvertFrom" id="M:Microsoft.Test.CommandLineParsing.FileInfoConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" access="Public" contract="Override" valueType="false" overload="1">
            <returnType type="System.Object" id="T:System.Object" />
            <documentation><summary> Converts from a string to a FileInfo. </summary>
<param name="context">Context.</param>
<param name="culture">Culture.</param>
<param name="value">Value to convert.</param>
<returns>FileInfo, or null if value was null or non-string.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="culture" typeId="T:System.Globalization.CultureInfo" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="CanConvertFrom" displayName="CanConvertFrom" id="M:Microsoft.Test.CommandLineParsing.FileInfoConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)" access="Public" contract="Override" valueType="true" overload="1">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context. </summary>
<param name="context">An ITypeDescriptorContext that provides a format context.</param>
<param name="sourceType">A Type that represents the type you want to convert from.</param>
<returns>True if this converter can perform the conversion; otherwise, False.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="sourceType" typeId="T:System.Type" valueType="false" />
          </method>
        </class>
        <class name="RequiredAttribute" displayName="RequiredAttribute" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.RequiredAttribute" access="Public" sealed="true">
          <documentation><summary> Defines whether a property value is required to be specified. </summary></documentation>
          <baseType name="Attribute" id="T:System.Attribute" displayName="Attribute" namespace="System" assembly="mscorlib" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.RequiredAttribute.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.RequiredAttribute" /> class.</summary><summary /></documentation>
          </constructor>
          <property name="TypeId" id="P:Microsoft.Test.CommandLineParsing.RequiredAttribute.TypeId" access="Public" contract="Virtual" typeId="T:System.Object" valueType="false" declaringType="System.Attribute" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.FaultInjection">
        <class name="BuiltInConditions" displayName="BuiltInConditions" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.BuiltInConditions" access="Public" static="true">
          <documentation><summary> Contains all built-in fault injection conditions. </summary>
<remarks> For more information on how to use the BuiltInConditions class, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. All fault injection conditions implement the <see cref="T:Microsoft.Test.FaultInjection.ICondition" /> interface. </remarks></documentation>
          <property name="TriggerOnEveryCall" id="P:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnEveryCall" access="Public" contract="Static" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="false">
            <documentation><summary> A built-in condition which triggers a fault every time the faulted method is called. </summary></documentation>
          </property>
          <property name="TriggerOnFirstCall" id="P:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnFirstCall" access="Public" contract="Static" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="false">
            <documentation><summary> A built-in condition which triggers a fault the first time the faulted method is called. </summary></documentation>
          </property>
          <property name="NeverTrigger" id="P:Microsoft.Test.FaultInjection.BuiltInConditions.NeverTrigger" access="Public" contract="Static" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="false">
            <documentation><summary> A built-in condition which never triggers a fault. This condition can be used to turn off a fault rule. </summary></documentation>
          </property>
          <method name="TriggerIfCalledBy" displayName="TriggerIfCalledBy" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerIfCalledBy(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault if the faulted method is called by a specified method.</summary>
<param name="caller">A string in the format: System.Console.WriteLine(string), Namespace&lt;T&gt;.OuterClass&lt;E&gt;.InnerClass&lt;F,G&gt;.MethodName&lt;H&gt;(T, E, F, H, List&lt;H&gt;). </param></documentation>
            <parameter name="caller" typeId="T:System.String" valueType="false" />
          </method>
          <method name="TriggerIfStackContains" displayName="TriggerIfStackContains" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerIfStackContains(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault if the current call stack contains a specified method. </summary>
<param name="method">A string in the format: System.Console.WriteLine(string), Namespace&lt;T&gt;.OuterClass&lt;E&gt;.InnerClass&lt;F,G&gt;.MethodName&lt;H&gt;(T, E, F, H, List&lt;H&gt;). </param></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
          </method>
          <method name="TriggerEveryOnNthCall" displayName="TriggerEveryOnNthCall" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerEveryOnNthCall(System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault after every n times the faulted method is called. </summary>
<param name="n">A positive number.</param>
<remarks> A System.Argument exception is thrown if n is not positive. </remarks></documentation>
            <parameter name="n" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="TriggerOnNthCall" displayName="TriggerOnNthCall" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnNthCall(System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault after the first n times the faulted method is called. </summary>
<param name="n">A positive number.</param>
<remarks> A System.Argument exception is thrown if n is not positive. </remarks></documentation>
            <parameter name="n" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="TriggerOnNthCallBy" displayName="TriggerOnNthCallBy" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnNthCallBy(System.Int32,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault after the faulted method is called n times by the specified caller. </summary>
<param name="n">A positive number.</param>
<param name="caller">A string in the format: System.Console.WriteLine(string), Namespace&lt;T&gt;.OuterClass&lt;E&gt;.InnerClass&lt;F,G&gt;.MethodName&lt;H&gt;(T, E, F, H, List&lt;H&gt;). </param></documentation>
            <parameter name="n" typeId="T:System.Int32" valueType="true" />
            <parameter name="caller" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="BuiltInFaults" displayName="BuiltInFaults" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.BuiltInFaults" access="Public" static="true">
          <documentation><summary> Contains all built-in faults. </summary>
<remarks> For more information on how to use the BuiltInFaults class, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. All fault injection faults implement the <see cref="T:Microsoft.Test.FaultInjection.IFault" /> interface. </remarks></documentation>
          <method name="ReturnFault" displayName="ReturnFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ReturnFault" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which returns when triggered. </summary>
<remarks> This method can be called when the faulted method has a void return type; it will return null if triggered in a non-void method. </remarks></documentation>
          </method>
          <method name="ReturnValueFault" displayName="ReturnValueFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ReturnValueFault(System.Object)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which returns the specified object when triggered. </summary>
<param name="returnValue">The object to return. The faulted method will return this object when the fault condition is triggered.</param></documentation>
            <parameter name="returnValue" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="ReturnValueRuntimeFault" displayName="ReturnValueRuntimeFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ReturnValueRuntimeFault(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which returns an object constructed according to the specified expression when triggered. </summary>
<param name="returnValueExpression">A string in the format: (int)3, (double)6.6, (bool)true, ‘Hello World’ which means "Hello World", System.Exception(‘This is a fault’). </param></documentation>
            <parameter name="returnValueExpression" typeId="T:System.String" valueType="false" />
          </method>
          <method name="ThrowExceptionFault" displayName="ThrowExceptionFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ThrowExceptionFault(System.Exception)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which throws the specified exception object when triggered. </summary>
<param name="exceptionValue"> An Exception object constructed by the process that injects the fault. </param>
<remarks> The exception object must be serializable. </remarks></documentation>
            <parameter name="exceptionValue" typeId="T:System.Exception" valueType="false" />
          </method>
          <method name="ThrowExceptionRuntimeFault" displayName="ThrowExceptionRuntimeFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ThrowExceptionRuntimeFault(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which throws an exception object constructed according to the specified expression when triggered. </summary>
<param name="exceptionExpression">A string in the format: System.Exception(‘This is a fault’), CustomizedNameSpace.CustomizedException(‘Error Message’, (int)3, System.Exception(‘innerException’)). </param></documentation>
            <parameter name="exceptionExpression" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="ComRegistrar" displayName="ComRegistrar" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.ComRegistrar" access="Public" static="true">
          <documentation><summary> Provides facilities for registration and query of the fault injection COM engine. </summary></documentation>
          <field name="Clsid" id="F:Microsoft.Test.FaultInjection.ComRegistrar.Clsid" access="Public" contract="Static" typeId="T:System.String" valueType="false" literal="true" value="{2EB6DCDB-3250-4D7F-AA42-41B1B84113ED}">
            <documentation><summary> CLSID of the fault injection COM engine. </summary></documentation>
          </field>
          <method name="Register" displayName="Register" id="M:Microsoft.Test.FaultInjection.ComRegistrar.Register(System.String)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Registers the fault injection COM engine. </summary>
<param name="enginePathName">Path name of engine file.</param></documentation>
            <parameter name="enginePathName" typeId="T:System.String" valueType="false" />
          </method>
          <method name="Unregister" displayName="Unregister" id="M:Microsoft.Test.FaultInjection.ComRegistrar.Unregister(System.String)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Unregisters the fault injection COM engine. </summary></documentation>
            <parameter name="enginePathName" typeId="T:System.String" valueType="false" />
          </method>
          <method name="SuppressAutoRegister" displayName="SuppressAutoRegister" id="M:Microsoft.Test.FaultInjection.ComRegistrar.SuppressAutoRegister" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Supresses auto-registration behaviour of the fault injection API. </summary></documentation>
          </method>
        </class>
        <class name="CallStack" displayName="CallStack" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.CallStack" access="Public">
          <documentation><summary> Extracts frame information from a StackTrace object. </summary>
<remarks> Calling CallStack[n] (where n is zero-indexed) will return a C#-style method signature for the nth frame. </remarks></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.CallStack.#ctor(System.Diagnostics.StackTrace)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the CallStack class. </summary>
<param name="stackTrace"> A stack trace from which to create the CallStack.</param></documentation>
            <parameter name="stackTrace" typeId="T:System.Diagnostics.StackTrace" valueType="false" />
          </constructor>
          <property name="FrameCount" id="P:Microsoft.Test.FaultInjection.CallStack.FrameCount" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Number of Frames in the CallStack. </summary></documentation>
          </property>
          <property name="Item" id="P:Microsoft.Test.FaultInjection.CallStack.Item(System.Int32)" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> C#-style method signature for the specified frame. </summary>
<param name="index">frame to evaluate</param></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
          </property>
        </class>
        <class name="FaultDispatcher" displayName="FaultDispatcher" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultDispatcher" access="Public" static="true">
          <documentation><summary> Calls the appropriate fault for a given faulted method. </summary>
<remarks> The FaultDispatcher class contains a static method <see cref="M:Microsoft.Test.FaultInjection.FaultDispatcher.Trap(System.Exception@,System.Object@)" />, which is called by the MSIL code, injected in the faulted method, in order to dispatch to the specific fault. </remarks></documentation>
          <method name="Trap" displayName="Trap" id="M:Microsoft.Test.FaultInjection.FaultDispatcher.Trap(System.Exception@,System.Object@)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Injected into the prologue of the target method. </summary>
<param name="exceptionValue">Exception thrown by fault</param>
<param name="returnValue">Value to return from fault</param>
<returns></returns>
<remarks> Trap creates a RuntimeContext for the current call and evaluates the fault condition's Trigger method. If it evaluates to true the fault's Retrieve method is called. </remarks></documentation>
            <parameter name="exceptionValue" typeId="T:System.Exception" valueType="false" direction="out" />
            <parameter name="returnValue" typeId="T:System.Object" valueType="false" direction="out" />
          </method>
        </class>
        <class name="FaultInjectionException" displayName="FaultInjectionException" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultInjectionException" access="Public">
          <documentation><summary> An exception that is thrown when and error in the FaultInjection API occurs. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="Exception" id="T:System.Exception" displayName="Exception" namespace="System" assembly="mscorlib" />
          <implementsClass type="System.Runtime.Serialization.ISerializable" id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" inherited="true" />
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the FaultInjectionException class. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor(System.String)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the FaultInjectionException class using the specified message. </summary></documentation>
            <parameter name="message" typeId="T:System.String" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor(System.String,System.Exception)" access="Public" contract="Normal" overload="3">
            <documentation><summary> Initializes a new instance of the FaultInjectionException class using the specified message and inner exception. </summary></documentation>
            <parameter name="message" typeId="T:System.String" valueType="false" />
            <parameter name="innerException" typeId="T:System.Exception" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" access="Family" contract="Normal" overload="4">
            <documentation><summary> Constructor used for serialization purposes. </summary></documentation>
            <parameter name="info" typeId="T:System.Runtime.Serialization.SerializationInfo" valueType="false" />
            <parameter name="context" typeId="T:System.Runtime.Serialization.StreamingContext" valueType="true" />
          </constructor>
          <property name="Message" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.Message" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="Data" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.Data" access="Public" contract="Virtual" typeId="T:System.Collections.IDictionary" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="InnerException" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.InnerException" access="Public" contract="Final" typeId="T:System.Exception" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="TargetSite" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.TargetSite" access="Public" contract="Final" typeId="T:System.Reflection.MethodBase" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="StackTrace" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.StackTrace" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="HelpLink" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.HelpLink" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="Public">
            <documentation><summary></summary></documentation>
          </property>
          <property name="Source" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.Source" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="Public">
            <documentation><summary></summary></documentation>
          </property>
          <property name="HResult" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.HResult" access="Family" contract="Normal" typeId="T:System.Int32" valueType="true" declaringType="System.Exception" get="Family" set="Family">
            <documentation><summary></summary></documentation>
          </property>
        </class>
        <class name="FaultRule" displayName="FaultRule" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultRule" access="Public" sealed="true">
          <documentation><summary> Defines which method to fault, under what conditions the fault will occur, and how the method will fail. See also the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. </summary>
<remarks> There can only be one fault rule per target method. </remarks>
<example>Creates a new FaultSession with several FaultRules and launches the application <code>            string sampleAppPath = "SampleApp.exe";
     
            FaultRule[] ruleArray = new FaultRule[]
            {     
                // Instance method
                new FaultRule(
                    "SampleApp.TargetType.TargetMethod(string, string)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnValueFault("")),
     
                // Constructor
                new FaultRule(
                    "SampleApp.TargetType.TargetType(string, int)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException())),
     
                // Static method
                new FaultRule(
                    "static SampleApp.TargetType.StaticTargetMethod()",
                    BuiltInConditions.TriggerOnEveryNthCall(2),
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException())),
     
                // Generic method
                new FaultRule(
                    "SampleApp.TargetType.GenericTargetMethod&lt;T&gt;(string)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnFault);
     
                // Property 
                new FaultRule(
                    "SampleApp.TargetType.get_TargetProperty()",
                    BuiltInConditions.TriggerOnEveryNthCall(3),
                    BuiltInFaults.ReturnFault);
     
                // Operator overload
                new FaultRule(
                    "SampleApp.TargetType.op_Increment(int, int)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException()))
            }     
     
            FaultSession session = new FaultSession(ruleArray);
            ProcessStartInfo psi = session.GetProcessStartInfo(sampleAppPath);
            Process.Start(psi);
</code></example></documentation>
          <attribute name="System.SerializableAttribute" />
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultRule.#ctor(System.String)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of FaultRule class with the specified method. </summary>
<param name="method">The signature of the method where the fault should be injected.</param></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultRule.#ctor(System.String,Microsoft.Test.FaultInjection.ICondition,Microsoft.Test.FaultInjection.IFault)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of FaultRule class with the specified method, condition and fault. </summary>
<param name="method">The signature of the method where the fault should be injected.</param>
<param name="condition">The condition that defines when the fault should occur.</param>
<param name="fault">The fault to be injected.</param></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
            <parameter name="condition" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" />
            <parameter name="fault" typeId="T:Microsoft.Test.FaultInjection.IFault" valueType="false" />
          </constructor>
          <property name="MethodSignature" id="P:Microsoft.Test.FaultInjection.FaultRule.MethodSignature" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The signature of the method where the fault should be injected. </summary></documentation>
          </property>
          <property name="Condition" id="P:Microsoft.Test.FaultInjection.FaultRule.Condition" access="Public" contract="Normal" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="Public">
            <documentation><summary> The condition that defines when the fault should occur. </summary></documentation>
          </property>
          <property name="Fault" id="P:Microsoft.Test.FaultInjection.FaultRule.Fault" access="Public" contract="Normal" typeId="T:Microsoft.Test.FaultInjection.IFault" valueType="false" get="Public" set="Public">
            <documentation><summary> The fault to be injected. </summary></documentation>
          </property>
        </class>
        <class name="FaultSession" displayName="FaultSession" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultSession" access="Public" sealed="true">
          <documentation><summary> Maintains information needed for injecting faults into a test application. For general information on fault injection see <a href="http://en.wikipedia.org/wiki/Fault_injection">this page</a>. </summary>
<remarks> Users can launch the faulted application by calling GetProcessStartInfo(string) and calling Process.Start() with the returned ProcessStartInfo. </remarks>
<example>The following example creates a new FaultSession with a single FaultRule and launches the application under test. <code>            string sampleAppPath = "SampleApp.exe";

            FaultRule rule = new FaultRule(
                "SampleApp.TargetMethod(string, string)",
                BuiltInConditions.TriggerOnEveryCall,
                BuiltInFaults.ReturnValueFault(""));
     
            FaultSession session = new FaultSession(rule);
            ProcessStartInfo psi = session.GetProcessStartInfo(sampleAppPath);
            Process.Start(psi);
</code></example>
<example>The following example creates a new FaultSession with multiple FaultRules and launches the application under test. <code>            string sampleAppPath = "SampleApp.exe";
     
            FaultRule[] ruleArray = new FaultRule[]
            {
                new FaultRule(
                    "SampleApp.TargetMethod(string, string)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnValueFault("")),
 
                new FaultRule(
                    "SampleApp.TargetMethod2(string, int)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnValueFault(Int32.MaxValue)),
     
                new FaultRule(
                    "static SampleApp.StaticTargetMethod()",
                    BuiltInConditions.TriggerOnEveryNthCall(2),
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException()))
            }     
     
            FaultSession session = new FaultSession(ruleArray);
            ProcessStartInfo psi = session.GetProcessStartInfo(sampleAppPath);
            Process.Start(psi);
</code></example>
<example>The following example demonstrates how to modify a fault rule in an existing session. <code>            ...
            string sampleAppPath = "SampleApp.exe";     
            FaultSession session = new FaultSession(rule);
            ...
      
            FaultRule foundRule = session.FindRule("SampleApp.TargetMethod(string, string)");
            if( foundRule != null)
            {
                foundRule.Condition = BuiltInConditions.TriggerOnEveryNthCall(4);
                session.NotifyRuleChanges();
            }
            ...
     
</code></example></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultSession.#ctor(Microsoft.Test.FaultInjection.FaultRule[])" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the FaultSession class with the specified FaultRule objects. </summary>
<param name="rules">FaultRule objects defining how to fault the test application.</param>
<exception cref="T:Microsoft.Test.FaultInjection.FaultInjectionException">Two FaultRule objects corresponding to the same method.</exception></documentation>
            <parameter name="rules" typeId="T:Microsoft.Test.FaultInjection.FaultRule" valueType="false" isParamArray="true" />
          </constructor>
          <property name="LogDirectory" id="P:Microsoft.Test.FaultInjection.FaultSession.LogDirectory" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> Directory for all log files written by applications launched by this session. </summary></documentation>
          </property>
          <method name="FindRule" displayName="FindRule" id="M:Microsoft.Test.FaultInjection.FaultSession.FindRule(System.String)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.FaultRule" id="T:Microsoft.Test.FaultInjection.FaultRule" />
            <documentation><summary> Finds the rule corresponding to a specified method. </summary>
<param name="method">The signature of the method.</param>
<returns> The FaultRule instance corresponding to the method specified. Returns null if no such rule exists. </returns></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
          </method>
          <method name="NotifyRuleChanges" displayName="NotifyRuleChanges" id="M:Microsoft.Test.FaultInjection.FaultSession.NotifyRuleChanges" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Notifies all test applications that fault rules have changed. </summary></documentation>
          </method>
          <method name="GetProcessStartInfo" displayName="GetProcessStartInfo" id="M:Microsoft.Test.FaultInjection.FaultSession.GetProcessStartInfo(System.String)" access="Public" contract="Normal" valueType="false">
            <returnType type="System.Diagnostics.ProcessStartInfo" id="T:System.Diagnostics.ProcessStartInfo" />
            <documentation><summary> Creates a ProcessStartInfo with the appropriate environment variables set for fault injection. </summary>
<param name="file">The path to the executable to launch.</param>
<returns>The ProcessStartInfo object for the executable.</returns></documentation>
            <parameter name="file" typeId="T:System.String" valueType="false" />
          </method>
          <method name="SetGlobalFault" displayName="SetGlobalFault" id="M:Microsoft.Test.FaultInjection.FaultSession.SetGlobalFault(Microsoft.Test.FaultInjection.FaultSession)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Sets a global fault session. This enables fault injection for all .NET processes launched after the creation of the global session. This functionality is often useful when testing server .NET applications, where one application typically consists of and launches many processes. </summary></documentation>
            <parameter name="session" typeId="T:Microsoft.Test.FaultInjection.FaultSession" valueType="false" />
          </method>
          <method name="ClearGlobalFault" displayName="ClearGlobalFault" id="M:Microsoft.Test.FaultInjection.FaultSession.ClearGlobalFault" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Destroys the global fault session. </summary></documentation>
          </method>
        </class>
        <class name="RuntimeContext" displayName="RuntimeContext" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.RuntimeContext" access="Public">
          <documentation><summary> Stores information about a faulted method. </summary></documentation>
          <implementsClass type="Microsoft.Test.FaultInjection.IRuntimeContext" id="T:Microsoft.Test.FaultInjection.IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" />
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.RuntimeContext.#ctor" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the RuntimeContext class. </summary></documentation>
          </constructor>
          <property name="CalledTimes" id="P:Microsoft.Test.FaultInjection.RuntimeContext.CalledTimes" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" get="Public" set="Public">
            <documentation><summary> The number of times the method has been called. </summary></documentation>
            <implements name="CalledTimes" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CalledTimes" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
          <property name="CallStackTrace" id="P:Microsoft.Test.FaultInjection.RuntimeContext.CallStackTrace" access="Public" contract="Final" typeId="T:System.Diagnostics.StackTrace" valueType="false" get="Public" set="Public">
            <documentation><summary> The method's stack trace. </summary></documentation>
            <implements name="CallStackTrace" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStackTrace" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
          <property name="CallStack" id="P:Microsoft.Test.FaultInjection.RuntimeContext.CallStack" access="Public" contract="Final" typeId="T:Microsoft.Test.FaultInjection.CallStack" valueType="false" get="Public" set="Public">
            <documentation><summary> An array of C#-style method signatures for each method on the call stack. </summary></documentation>
            <implements name="CallStack" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStack" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
          <property name="Caller" id="P:Microsoft.Test.FaultInjection.RuntimeContext.Caller" access="Public" contract="Final" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The C#-style method signature of the caller of the faulted method. </summary></documentation>
            <implements name="Caller" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.Caller" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
        </class>
        <interface name="ICondition" displayName="ICondition" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.ICondition" access="Public">
          <documentation><summary> Defines the contract for specifying when a fault will be triggered on a method. </summary>
<remarks> If the fault condition is not triggered, the faulted method will execute its original code. For more information on how to use a condition, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. </remarks></documentation>
          <method name="Trigger" displayName="Trigger" id="M:Microsoft.Test.FaultInjection.ICondition.Trigger(Microsoft.Test.FaultInjection.IRuntimeContext)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Determines whether a fault should be triggered. </summary>
<param name="context">The runtime context information for this call and the faulted method.</param>
<returns>Returns true if a fault should be triggered, otherwise returns false.</returns></documentation>
            <parameter name="context" typeId="T:Microsoft.Test.FaultInjection.IRuntimeContext" valueType="false" />
          </method>
        </interface>
        <interface name="IFault" displayName="IFault" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.IFault" access="Public">
          <documentation><summary> Defines the contract for a fault. </summary>
<remarks> For more information on how to use a fault, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. </remarks>
<example>Define a custom fault <code>            //Returns a random int when triggered
            public class ReturnRandomIntFault : IFault
            {
                private Random rand;

                public ReturnRandomIntFault(int seed)
                {
                    rand = new Random(seed);
                }

                public void Retrieve(IRuntimeContext context, out Exception exceptionValue, out object returnValue)
                {
                    exceptionValue = null;
                    returnValue = rand.Next();
                }
            }
</code></example></documentation>
          <method name="Retrieve" displayName="Retrieve" id="M:Microsoft.Test.FaultInjection.IFault.Retrieve(Microsoft.Test.FaultInjection.IRuntimeContext,System.Exception@,System.Object@)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Defines the behavior of the fault when triggered. </summary>
<param name="context">The runtime context information for this call.</param>
<param name="exceptionValue">An output paramter for the exception to be thrown by the faulted method.</param>
<param name="returnValue">An output paramter for the value to be returned by the faulted method.</param>
<remarks> Parameter <paramref name="returnValue" /> is only checked when <paramref name="exceptionValue" /> returns null. </remarks></documentation>
            <parameter name="context" typeId="T:Microsoft.Test.FaultInjection.IRuntimeContext" valueType="false" />
            <parameter name="exceptionValue" typeId="T:System.Exception" valueType="false" direction="out" />
            <parameter name="returnValue" typeId="T:System.Object" valueType="false" direction="out" />
          </method>
        </interface>
        <interface name="IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.IRuntimeContext" access="Public">
          <documentation><summary> Defines the contract for information provided by the faulted method. </summary></documentation>
          <implementedBy id="T:Microsoft.Test.FaultInjection.RuntimeContext" displayName="RuntimeContext" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
          <property name="CalledTimes" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CalledTimes" access="Public" contract="Abstract" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> The number of times the method is called. </summary></documentation>
          </property>
          <property name="CallStackTrace" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStackTrace" access="Public" contract="Abstract" typeId="T:System.Diagnostics.StackTrace" valueType="false" get="Public" set="false">
            <documentation><summary> The method's stack trace. </summary></documentation>
          </property>
          <property name="CallStack" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStack" access="Public" contract="Abstract" typeId="T:Microsoft.Test.FaultInjection.CallStack" valueType="false" get="Public" set="false">
            <documentation><summary> An array of C#-style method signatures for each method on the call stack. </summary></documentation>
          </property>
          <property name="Caller" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.Caller" access="Public" contract="Abstract" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The C#-style method signature of the caller of the faulted method. </summary></documentation>
          </property>
        </interface>
      </namespace>
      <namespace name="Microsoft.Test.Text">
        <class name="StringFactory" displayName="StringFactory" namespace="Microsoft.Test.Text" id="T:Microsoft.Test.Text.StringFactory" access="Public" static="true">
          <documentation><summary> Provides factory methods for generation of text, interesting from testing point of view. </summary>
<example>The following example demonstrates how to create a random string with of 10 characters: <code> // Generate a random string of 10 characters.

 StringProperties sp = new StringProperties();
 sp.MaxNumberOfCharacters = sp.MinNumberOfCharacters = 10;

 string s = StringFactory.GenerateRandomString(sp, 0);
 </code></example></documentation>
          <method name="GenerateRandomString" displayName="GenerateRandomString" id="M:Microsoft.Test.Text.StringFactory.GenerateRandomString(Microsoft.Test.Text.StringProperties,System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="System.String" id="T:System.String" />
            <documentation><summary> Generates a random string, with the specified properties. <font color="red">NOT IMPLEMENTED.</font></summary>
<param name="stringProperties">The properties of the generated string.</param>
<param name="seed">A number used to calculate a starting value for the pseudo-random number sequence. If a negative number is specified, the absolute value of the number is used.</param>
<returns>A random string with the specified properties.</returns></documentation>
            <parameter name="stringProperties" typeId="T:Microsoft.Test.Text.StringProperties" valueType="false" />
            <parameter name="seed" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="GetPredefinedStrings" displayName="GetPredefinedStrings" id="M:Microsoft.Test.Text.StringFactory.GetPredefinedStrings(Microsoft.Test.Text.StringProperties)" access="Public" contract="Static" valueType="false">
            <returnType type="System.String[]" id="T:System.String" />
            <documentation><summary> Returns an array of predefined strings, interesting from a text testing point of view, with the specified properties. <font color="red">NOT IMPLEMENTED.</font></summary>
<param name="stringProperties">The properties of the generated string.</param>
<returns>An array of predefined strings with the specified properties.</returns></documentation>
            <parameter name="stringProperties" typeId="T:Microsoft.Test.Text.StringProperties" valueType="false" />
          </method>
        </class>
        <class name="StringProperties" displayName="StringProperties" namespace="Microsoft.Test.Text" id="T:Microsoft.Test.Text.StringProperties" access="Public">
          <documentation><summary> Defines the desired properties of a character string. For more information on character strings, see <a href="http://msdn.microsoft.com/en-us/library/dd317711(VS.85).aspx">this article</a>. </summary>
<remarks> Note that this class is used as <i>"a filter"</i> when generating character strings with <see cref="T:Microsoft.Test.Text.StringFactory" />. Upon instantiation, all properties except CultureInfo of a <see cref="T:Microsoft.Test.Text.StringProperties" nolink="true" /> object (which are all <a href="http://msdn.microsoft.com/en-us/library/system.nullable.aspx">Nullables</a>) have null values, which means that the object does not impose any filtering limitations on the generated strings. <para> Setting properties to non-null values means that the value of the property should be taken into account by <see cref="T:Microsoft.Test.Text.StringFactory" nolink="true" /> during string generation. For example, setting <see cref="P:Microsoft.Test.Text.StringProperties.MaxNumberOfCharacters" /> to 10 means <i>"generate strings with up to 10 characters"</i>.</para></remarks>
<example>The following example demonstrates how to create a random string with of 10 characters: <code> // Generate a random string of 10 characters.

 StringProperties sp = new StringProperties();
 sp.MaxNumberOfCharacters = sp.MinNumberOfCharacters = 10;

 string s = StringFactory.GenerateRandomString(sp, 0);
 </code></example></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.Text.StringProperties.#ctor" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the class. </summary></documentation>
          </constructor>
          <property name="CultureInfo" id="P:Microsoft.Test.Text.StringProperties.CultureInfo" access="Public" contract="Normal" typeId="T:System.Globalization.CultureInfo" valueType="false" get="Public" set="Public">
            <documentation><summary> Determines whether the string belongs to a specific culture by examining the name of the culture </summary></documentation>
          </property>
          <property name="HasCombiningMarks" id="P:Microsoft.Test.Text.StringProperties.HasCombiningMarks" access="Public" contract="Normal" typeId="T:System.Boolean" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines whether the string has combining marks. <a href="http://en.wikipedia.org/wiki/Combining_diacritical_mark">Combining marks</a> (and combining characters in general) are characters that are intended to modify other characters (e.g. accents, etc.) </summary></documentation>
          </property>
          <property name="HasNumbers" id="P:Microsoft.Test.Text.StringProperties.HasNumbers" access="Public" contract="Normal" typeId="T:System.Boolean" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines whether the string contains formatted numbers </summary></documentation>
          </property>
          <property name="IsBidirectional" id="P:Microsoft.Test.Text.StringProperties.IsBidirectional" access="Public" contract="Normal" typeId="T:System.Boolean" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines whether the string is <a href="http://en.wikipedia.org/wiki/Bi-directional_text">bi-directional</a>. </summary></documentation>
          </property>
          <property name="NormalizationForm" id="P:Microsoft.Test.Text.StringProperties.NormalizationForm" access="Public" contract="Normal" typeId="T:System.Text.NormalizationForm" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Defines the desired type of normalization to perform on the string. For more information, see <a href="http://www.unicode.org/reports/tr15">this article</a>. </summary></documentation>
          </property>
          <property name="MinNumberOfCharacters" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfCharacters" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the desired minimum number of characters in the string. </summary></documentation>
          </property>
          <property name="MaxNumberOfCharacters" id="P:Microsoft.Test.Text.StringProperties.MaxNumberOfCharacters" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the desired maximum number of characters in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfEndUserDefinedCharacters" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfEndUserDefinedCharacters" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines minimum number of <a href="http://msdn.microsoft.com/en-us/library/dd317802(VS.85).aspx">end-user-defined characters</a> (EUDC) in the string. </summary></documentation>
          </property>
          <property name="MaxNumberOfEndUserDefinedCharacters" id="P:Microsoft.Test.Text.StringProperties.MaxNumberOfEndUserDefinedCharacters" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines maximum number of <a href="http://msdn.microsoft.com/en-us/library/dd317802(VS.85).aspx">end-user-defined characters</a> (EUDC) in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfLineBreaks" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfLineBreaks" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the desired minimum number of line breaks in the string. </summary></documentation>
          </property>
          <property name="MaxNumberOfLineBreaks" id="P:Microsoft.Test.Text.StringProperties.MaxNumberOfLineBreaks" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the desired maximum number of line breaks in the string. </summary></documentation>
          </property>
          <property name="StartOfUnicodeRange" id="P:Microsoft.Test.Text.StringProperties.StartOfUnicodeRange" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the starting range of the Unicode characters in the string. </summary></documentation>
          </property>
          <property name="EndOfUnicodeRange" id="P:Microsoft.Test.Text.StringProperties.EndOfUnicodeRange" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the ending range of the Unicode characters in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfSurrogatePairs" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfSurrogatePairs" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines minimum number of <a href="http://en.wikipedia.org/wiki/Surrogate_pair">surrogate pairs</a> in the string. </summary></documentation>
          </property>
          <property name="MaxNumberOfSurrogatePairs" id="P:Microsoft.Test.Text.StringProperties.MaxNumberOfSurrogatePairs" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines maximum number of <a href="http://en.wikipedia.org/wiki/Surrogate_pair">surrogate pairs</a> in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfTextSegmentationCharacters" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfTextSegmentationCharacters" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines minimum number of <a href="http://en.wikipedia.org/wiki/Text_segmentation">text segmentation characters</a> in the string. </summary></documentation>
          </property>
          <property name="MaxNumberOfTextSegmentationCharacters" id="P:Microsoft.Test.Text.StringProperties.MaxNumberOfTextSegmentationCharacters" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines maximum number of <a href="http://en.wikipedia.org/wiki/Text_segmentation">text segmentation characters</a> in the string. </summary></documentation>
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.VariationGeneration">
        <class name="Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Constraint" access="Public" abstract="true">
          <documentation><summary> Represents a relationship between parameters, their values or other constraints. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, tests every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. Ideally all parameters in a model are independent but this is generally not the case. Constraints define combinations of values that are impossible in the variations produced by the <see cref="T:Microsoft.Test.VariationGeneration.Model" /> using combinatorial testing techniques. </remarks></documentation>
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" displayName="IfThenConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraint.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraint" /> class.</summary>
            </documentation>
          </constructor>
        </class>
        <class name="Model" displayName="Model" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Model" access="Public">
          <documentation><summary> Contains all the parameters and constraints for the system under test and produces a set of variations using combinatorial test techniques. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, tests every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. </remarks>
<example>
  <p> The following example demonstrates creating variations for a vacation planner with a signature like this: CallVacationPlanner(string destination, int hotelQuality, string activity). It demonstrates that certain activities are only available for certain destinations. </p>
  <code>            Parameter destination = 
                new Parameter("Destination") { "Whistler", "Hawaii", "Las Vegas" };

            Parameter hotelQuality = 
                new Parameter("Hotel Quality") { 5, 4, 3, 2, 1 };

            Parameter activity = 
               new Parameter("Activity") { "gambling", "swimming", "shopping", "skiing" };

            List&lt;Parameter&gt; parameters = new List&lt;Parameter&gt; { destination, hotelQuality, activity };
            List&lt;Constraint&gt; constraints = new List&lt;Constraint&gt;
            {
                new IfThenConstraint
                {
                    If = destination.Equal("Whistler").Or(destination.Equal("Hawaii")),
                    Then = activity.NotEqual("gambling")                        
                },
                new IfThenConstraint
                {
                    If = destination.Equal("Las Vegas").Or(destination.Equal("Hawaii")),
                    Then = activity.NotEqual("skiing")
                },
                new IfThenConstraint
                {
                    If = destination.Equal("Whistler"),
                    Then = activity.NotEqual("swimming")
                },
            };

            Model model = new Model(parameters, constraints);

            // call the method under test with each generated variation
            foreach (var variation in model.GenerateVariations())
            {
                CallVacationPlanner(
                    (string)variation[destination.Name], 
                    (int)variation[hotelQuality.Name], 
                    (string)variation[activity.Name]);
            }
</code>
</example></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Model.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Parameter})" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new model with the specified parameters. </summary>
<param name="parameters">The parameters.</param></documentation>
            <parameter name="parameters" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.VariationGeneration.Parameter" />
            </parameter>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Model.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Parameter},System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Constraint})" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new model with the specified parameters and constraints. </summary>
<param name="parameters">The parameters.</param>
<param name="constraints">The constraints.</param></documentation>
            <parameter name="parameters" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.VariationGeneration.Parameter" />
            </parameter>
            <parameter name="constraints" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.VariationGeneration.Constraint" />
            </parameter>
          </constructor>
          <property name="Parameters" id="P:Microsoft.Test.VariationGeneration.Model.Parameters" access="Public" contract="Normal" typeId="T:System.Collections.Generic.IList`1" valueType="false" get="Public" set="false">
            <documentation><summary> The parameters in the model. </summary></documentation>
            <genericargument name="Microsoft.Test.VariationGeneration.Parameter" />
          </property>
          <property name="Constraints" id="P:Microsoft.Test.VariationGeneration.Model.Constraints" access="Public" contract="Normal" typeId="T:System.Collections.Generic.ICollection`1" valueType="false" get="Public" set="false">
            <documentation><summary> The constraints in the model. </summary></documentation>
            <genericargument name="Microsoft.Test.VariationGeneration.Constraint" />
          </property>
          <method name="GenerateVariations" displayName="GenerateVariations" id="M:Microsoft.Test.VariationGeneration.Model.GenerateVariations" access="Public" contract="Virtual" valueType="false" overload="1">
            <returnType type="System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Variation}" id="T:System.Collections.Generic.IEnumerable`1">
              <genericargument name="Microsoft.Test.VariationGeneration.Variation" />
            </returnType>
            <documentation><summary> Generate a pairwise set of variations using a constant seed. </summary>
<returns>The variations.</returns></documentation>
          </method>
          <method name="GenerateVariations" displayName="GenerateVariations" id="M:Microsoft.Test.VariationGeneration.Model.GenerateVariations(System.Int32)" access="Public" contract="Virtual" valueType="false" overload="2">
            <returnType type="System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Variation}" id="T:System.Collections.Generic.IEnumerable`1">
              <genericargument name="Microsoft.Test.VariationGeneration.Variation" />
            </returnType>
            <documentation><summary> Generate an order-wise set of variations using a constant seed. </summary>
<param name="order">The order or the combinations selected (2 is every pair, 3 is every triple, etc). Must be between 1 and the number of parameters.</param>
<returns>The variations.</returns></documentation>
            <parameter name="order" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="GenerateVariations" displayName="GenerateVariations" id="M:Microsoft.Test.VariationGeneration.Model.GenerateVariations(System.Int32,System.Int32)" access="Public" contract="Virtual" valueType="false" overload="3">
            <returnType type="System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Variation}" id="T:System.Collections.Generic.IEnumerable`1">
              <genericargument name="Microsoft.Test.VariationGeneration.Variation" />
            </returnType>
            <documentation><summary> Generate and order-wise set of variations using the specified seed for random generation. </summary>
<param name="order">The order or the combinations selected (2 is every pair, 3 is every triple, etc). Must be between 1 and the number of parameters.</param>
<param name="seed">The seed used for random generation.</param>
<returns>The variations.</returns></documentation>
            <parameter name="order" typeId="T:System.Int32" valueType="true" />
            <parameter name="seed" typeId="T:System.Int32" valueType="true" />
          </method>
        </class>
        <class name="Parameter" displayName="Parameter" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Parameter" access="Public">
          <documentation><summary> Represents a single variable and its values in the model. Combinations of these values are used in the combinatorial generation of variations by the <see cref="T:Microsoft.Test.VariationGeneration.Model" />. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, tests every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. </remarks></documentation>
          <implementsClass type="System.Collections.Generic.IList`1" id="T:System.Collections.Generic.IList`1" displayName="IList(T)" namespace="System.Collections.Generic">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.ICollection`1" id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.IEnumerable`1" id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.IEnumerable" id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Parameter.#ctor(System.String)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the parameter class using the specified name. </summary>
<param name="name">The name of the parameter</param></documentation>
            <parameter name="name" typeId="T:System.String" valueType="false" />
          </constructor>
          <property name="Name" id="P:Microsoft.Test.VariationGeneration.Parameter.Name" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> The name of the parameter. </summary></documentation>
          </property>
          <property name="Count" id="P:Microsoft.Test.VariationGeneration.Parameter.Count" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> The number of values in the parameter. </summary></documentation>
            <implements name="Count" id="P:System.Collections.Generic.ICollection`1.Count" interface="ICollection`1" assembly="mscorlib" interfaceId="T:System.Collections.Generic.ICollection`1" declaringType="System.Collections.Generic.ICollection`1" />
          </property>
          <property name="IsReadOnly" id="P:Microsoft.Test.VariationGeneration.Parameter.IsReadOnly" access="Public" contract="Final" typeId="T:System.Boolean" valueType="true" get="Public" set="false">
            <documentation><summary> Whether values can be added or removed from the parameter. </summary></documentation>
            <implements name="IsReadOnly" id="P:System.Collections.Generic.ICollection`1.IsReadOnly" interface="ICollection`1" assembly="mscorlib" interfaceId="T:System.Collections.Generic.ICollection`1" declaringType="System.Collections.Generic.ICollection`1" />
          </property>
          <property name="Item" id="P:Microsoft.Test.VariationGeneration.Parameter.Item(System.Int32)" access="Public" contract="Final" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> The value at the specified index. </summary>
<param name="index">The index of the value.</param>
<returns>The value at the index.</returns></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
            <implements name="Item" id="P:System.Collections.Generic.IList`1.Item(System.Int32)" interface="IList`1" assembly="mscorlib" interfaceId="T:System.Collections.Generic.IList`1" declaringType="System.Collections.Generic.IList`1" />
          </property>
          <method name="Add" displayName="Add" id="M:Microsoft.Test.VariationGeneration.Parameter.Add(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Adds a value to the parameter. </summary>
<param name="item">The value to add</param></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Add" id="M:System.Collections.Generic.ICollection`1.Add(System.Object)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Clear" displayName="Clear" id="M:Microsoft.Test.VariationGeneration.Parameter.Clear" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Removes all values from the parameter. </summary></documentation>
            <implements name="Clear" id="M:System.Collections.Generic.ICollection`1.Clear" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Contains" displayName="Contains" id="M:Microsoft.Test.VariationGeneration.Parameter.Contains(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Checks whether the parameter has the specified value. </summary>
<param name="item">The value to search for.</param>
<returns>Whether the value was found.</returns></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Contains" id="M:System.Collections.Generic.ICollection`1.Contains(System.Object)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="CopyTo" displayName="CopyTo" id="M:Microsoft.Test.VariationGeneration.Parameter.CopyTo(System.Object[],System.Int32)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Copies the values into the specified array. </summary>
<param name="array">The target array.</param>
<param name="arrayIndex">The zero-based index in array at which copying begins.</param></documentation>
            <parameter name="array" typeId="T:System.Object" valueType="false" />
            <parameter name="arrayIndex" typeId="T:System.Int32" valueType="true" />
            <implements name="CopyTo" id="M:System.Collections.Generic.ICollection`1.CopyTo(System.Object[],System.Int32)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Remove" displayName="Remove" id="M:Microsoft.Test.VariationGeneration.Parameter.Remove(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Removes the specified value from the parameter if found. </summary>
<param name="item">The value to remove.</param>
<returns>Whether the value was found and removed.</returns></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Remove" id="M:System.Collections.Generic.ICollection`1.Remove(System.Object)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="GetEnumerator" displayName="GetEnumerator" id="M:Microsoft.Test.VariationGeneration.Parameter.GetEnumerator" access="Public" contract="Final" valueType="false">
            <returnType type="System.Collections.Generic.IEnumerator{System.Object}" id="T:System.Collections.Generic.IEnumerator`1">
              <genericargument name="System.Object" />
            </returnType>
            <documentation><summary> Gets an enumerator over the values in the parameter. </summary>
<returns>The enumerator.</returns></documentation>
            <implements name="GetEnumerator" id="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" interface="IEnumerable`1" interfaceId="T:System.Collections.Generic.IEnumerable`1" assembly="mscorlib" declaringType="System.Collections.Generic.IEnumerable`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="IndexOf" displayName="IndexOf" id="M:Microsoft.Test.VariationGeneration.Parameter.IndexOf(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Int32" id="T:System.Int32" />
            <documentation><summary> Determines the index of the value in the parameter. </summary>
<param name="item">The value to find.</param>
<returns>The index of the value if found, otherwise -1.</returns></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="IndexOf" id="M:System.Collections.Generic.IList`1.IndexOf(System.Object)" interface="IList`1" interfaceId="T:System.Collections.Generic.IList`1" assembly="mscorlib" declaringType="System.Collections.Generic.IList`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Insert" displayName="Insert" id="M:Microsoft.Test.VariationGeneration.Parameter.Insert(System.Int32,System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Inserts a value at the specified index. </summary>
<param name="index">The zero-based index where the value should be inserted.</param>
<param name="item">The value to insert.</param></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Insert" id="M:System.Collections.Generic.IList`1.Insert(System.Int32,System.Object)" interface="IList`1" interfaceId="T:System.Collections.Generic.IList`1" assembly="mscorlib" declaringType="System.Collections.Generic.IList`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="RemoveAt" displayName="RemoveAt" id="M:Microsoft.Test.VariationGeneration.Parameter.RemoveAt(System.Int32)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Removes a value at the specified index. </summary>
<param name="index">The zero-based index of the value to remove.</param></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
            <implements name="RemoveAt" id="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" interface="IList`1" interfaceId="T:System.Collections.Generic.IList`1" assembly="mscorlib" declaringType="System.Collections.Generic.IList`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
        </class>
        <class name="Variation" displayName="Variation" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Variation" access="Public">
          <documentation><summary> Represents a tuple with a single value for every <see cref="T:Microsoft.Test.VariationGeneration.Parameter" /> in the <see cref="T:Microsoft.Test.VariationGeneration.Model" />. The Model produces these using combinatorial test techniques. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, test every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. </remarks></documentation>
          <baseType name="Dictionary`2" id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary`2" namespace="System.Collections.Generic" assembly="mscorlib">
            <genericargument name="System.String" />
            <genericargument name="System.Object" />
          </baseType>
          <implementsClass type="System.Collections.Generic.IDictionary`2" id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="TKey" />
            <genericargument name="TValue" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.ICollection`1" id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.IEnumerable`1" id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.IEnumerable" id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.IDictionary" id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.ICollection" id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.ISerializable" id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.IDeserializationCallback" id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" inherited="true" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Variation.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Variation" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Comparer" id="P:Microsoft.Test.VariationGeneration.Variation.Comparer" access="Public" contract="Normal" typeId="T:System.Collections.Generic.IEqualityComparer`1" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
          </property>
          <property name="Count" id="P:Microsoft.Test.VariationGeneration.Variation.Count" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <implements name="Count" id="P:System.Collections.ICollection.Count" interface="ICollection" assembly="mscorlib" interfaceId="T:System.Collections.ICollection" declaringType="System.Collections.ICollection" />
          </property>
          <property name="Keys" id="P:Microsoft.Test.VariationGeneration.Variation.Keys" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.KeyCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.Object" />
          </property>
          <property name="Values" id="P:Microsoft.Test.VariationGeneration.Variation.Values" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.ValueCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.Object" />
          </property>
          <property name="Item" id="P:Microsoft.Test.VariationGeneration.Variation.Item(System.String)" access="Public" contract="Final" typeId="T:System.Object" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="Public">
            <documentation><summary></summary></documentation>
            <parameter name="key" typeId="T:System.String" valueType="false" />
            <implements name="Item" id="P:System.Collections.Generic.IDictionary`2.Item(System.String)" interface="IDictionary`2" assembly="mscorlib" interfaceId="T:System.Collections.Generic.IDictionary`2" declaringType="System.Collections.Generic.IDictionary`2" />
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.VariationGeneration.Constraints">
        <class name="ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" access="Public" abstract="true">
          <documentation><summary> Represents a relationship that evaluates to a boolean, such as "and", "or", or "equals." </summary></documentation>
          <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" displayName="AndConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" displayName="EqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" displayName="GreaterThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" displayName="GreaterThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" displayName="LessThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" displayName="LessThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" displayName="NotConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" displayName="NotEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" displayName="OrConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" /> class.</summary>
            </documentation>
          </constructor>
        </class>
        <class name="AndConstraint" displayName="AndConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" access="Public">
          <documentation><summary> Represents an "and" relationship between two conditions. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.AndConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="First" id="P:Microsoft.Test.VariationGeneration.Constraints.AndConstraint.First" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The first condition. </summary></documentation>
          </property>
          <property name="Second" id="P:Microsoft.Test.VariationGeneration.Constraints.AndConstraint.Second" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The second condition. </summary></documentation>
          </property>
        </class>
        <class name="EqualConstraint" displayName="EqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" access="Public">
          <documentation><summary> Represents an equality condition between either a parameter and a value or two parameters. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the EqualConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the EqualConstraint class using the specified parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="ConstraintHelpers" displayName="ConstraintHelpers" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers" access="Public" static="true">
          <documentation><summary> A collection of methods to help create constraints. </summary></documentation>
          <method name="And" displayName="And" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.And(Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint,Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.AndConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" />
            <documentation><summary> Creates an AndConstraint between two ConditionConstraints. </summary>
<param name="first">The first condition.</param>
<param name="second">The second condition.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
          </method>
          <method name="Equal" displayName="Equal" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Equal(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" />
            <documentation><summary> Creates an EqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="Equal" displayName="Equal" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Equal(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" />
            <documentation><summary> Creates an EqualConstraint between two parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="GreaterThan" displayName="GreaterThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThan(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" />
            <documentation><summary> Creates an EqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="GreaterThan" displayName="GreaterThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThan(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" />
            <documentation><summary> Creates a GreaterThanConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="GreaterThanOrEqual" displayName="GreaterThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" />
            <documentation><summary> Creates an GreaterThanOrEqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="GreaterThanOrEqual" displayName="GreaterThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" />
            <documentation><summary> Creates a GreaterThanOrEqualConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="LessThan" displayName="LessThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThan(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" />
            <documentation><summary> Creates a LessThanConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="LessThan" displayName="LessThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThan(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" />
            <documentation><summary> Creates a LessThanConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="LessThanOrEqual" displayName="LessThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" />
            <documentation><summary> Creates a LessThanOrEqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="LessThanOrEqual" displayName="LessThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" />
            <documentation><summary> Creates an EqualConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="Not" displayName="Not" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Not(Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.NotConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" />
            <documentation><summary> Creates a NotConstraint on the given condition. </summary>
<param name="condition">The condition to negate.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="condition" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
          </method>
          <method name="NotEqual" displayName="NotEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.NotEqual(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" />
            <documentation><summary> Creates a NotEqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="NotEqual" displayName="NotEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.NotEqual(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" />
            <documentation><summary> Creates a NotEqualConstraint between 2 parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="Or" displayName="Or" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Or(Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint,Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.OrConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" />
            <documentation><summary> Creates an OrConstraint between two ConditionConstraints. </summary>
<param name="first">The first condition.</param>
<param name="second">The second condition.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
          </method>
        </class>
        <class name="GreaterThanConstraint" displayName="GreaterThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" access="Public">
          <documentation><summary> Represents a greater-than condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the GreaterThanConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the GreaterThanConstraint class using the specified parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="GreaterThanOrEqualConstraint" displayName="GreaterThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" access="Public">
          <documentation><summary> Represents a greater-than-or-equal condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the GreaterThanOrEqualConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the GreaterThanOrEqualConstraint using two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="IfThenConstraint" displayName="IfThenConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" access="Public">
          <documentation><summary> Represents an implication between two constraints. </summary></documentation>
          <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="If" id="P:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint.If" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The condition to test. </summary></documentation>
          </property>
          <property name="Then" id="P:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint.Then" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The implied result of the test. </summary></documentation>
          </property>
        </class>
        <class name="LessThanConstraint" displayName="LessThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" access="Public">
          <documentation><summary> Represents a less-than condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the LessThanConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the LessThanConstraint class using the specified parameters. </summary>
<param name="left"> The left side</param>
<param name="right">The right side</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="LessThanOrEqualConstraint" displayName="LessThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" access="Public">
          <documentation><summary> Represents a less-than-or-equal condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the LessThanOrEqualConstraint class the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the LessThanOrEqualConstraint class the specified parameters. </summary>
<param name="left"> The first parameter</param>
<param name="right">The second parameter</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="NotConstraint" displayName="NotConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" access="Public">
          <documentation><summary> Negates the inner condition. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.NotConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Condition" id="P:Microsoft.Test.VariationGeneration.Constraints.NotConstraint.Condition" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The condition to negate. </summary></documentation>
          </property>
        </class>
        <class name="NotEqualConstraint" displayName="NotEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" access="Public">
          <documentation><summary> Represents an inequality condition between either a parameter and a value or two parameters. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the NotEqualConstraint class using the specified parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the NotEqualConstraint class using the specified parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="OrConstraint" displayName="OrConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" access="Public">
          <documentation><summary> Represents an "or" relationship between two conditions. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.OrConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="First" id="P:Microsoft.Test.VariationGeneration.Constraints.OrConstraint.First" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The first condition. </summary></documentation>
          </property>
          <property name="Second" id="P:Microsoft.Test.VariationGeneration.Constraints.OrConstraint.Second" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The second condition. </summary></documentation>
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.VisualVerification">
        <class name="ColorDifference" displayName="ColorDifference" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.ColorDifference" access="Public">
          <documentation><summary> Represents the per-channel difference between two colors. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.ColorDifference.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the ColorDifference class using values of zero, indicating no difference. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.ColorDifference.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the ColorDifference class, using the specified alpha, red, green and blue values. </summary>
<param name="alpha">The alpha (transparency) color channel difference.</param>
<param name="red">The red color channel difference.</param>
<param name="green">The green color channel difference.</param>
<param name="blue">The blue color channel difference.</param></documentation>
            <parameter name="alpha" typeId="T:System.Byte" valueType="true" />
            <parameter name="red" typeId="T:System.Byte" valueType="true" />
            <parameter name="green" typeId="T:System.Byte" valueType="true" />
            <parameter name="blue" typeId="T:System.Byte" valueType="true" />
          </constructor>
          <property name="A" id="P:Microsoft.Test.VisualVerification.ColorDifference.A" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Alpha (transparency) color channel difference. </summary></documentation>
          </property>
          <property name="R" id="P:Microsoft.Test.VisualVerification.ColorDifference.R" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Red color channel difference. </summary></documentation>
          </property>
          <property name="G" id="P:Microsoft.Test.VisualVerification.ColorDifference.G" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Green color channel difference. </summary></documentation>
          </property>
          <property name="B" id="P:Microsoft.Test.VisualVerification.ColorDifference.B" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Blue color channel difference. </summary></documentation>
          </property>
        </class>
        <class name="Histogram" displayName="Histogram" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.Histogram" access="Public">
          <documentation><summary> The Histogram class represents a histogram curve, expressed in terms of frequency (proportion of total pixels) over brightness (from 0 to 255). In other words, the Histogram class represents the percentage (proportion) of pixels that have brightness of 0, 1, etc. <a href="http://en.wikipedia.org/wiki/Image_histogram">This page</a> provides a good introduction to <i>image histograms</i>. <p /> For testing purposes "brightness" is often equated to "difference". Thus, one is able to construct a "difference histogram" from a "difference shapshot" and compare that histogram to a histogram of "expected maximum differences" (also knows as a "tolerance histogram") in order to determine whether a visual verification test passes or fails. <p /> A Histogram object can be loaded from a XML file or generated from a Snapshot object. </summary></documentation>
          <property name="Item" id="P:Microsoft.Test.VisualVerification.Histogram.Item(System.Int32)" access="Public" contract="Normal" typeId="T:System.Single" valueType="true" get="Public" set="false">
            <documentation><summary> The data of the histogram. </summary>
<param name="column">Which column of the histogram you want.</param>
<returns>A float value between 0 and 1.</returns></documentation>
            <parameter name="column" typeId="T:System.Int32" valueType="true" />
          </property>
          <method name="FromSnapshot" displayName="FromSnapshot" id="M:Microsoft.Test.VisualVerification.Histogram.FromSnapshot(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Histogram" id="T:Microsoft.Test.VisualVerification.Histogram" />
            <documentation><summary> Creates a Histogram object from an existing Snapshot object. </summary>
<param name="snapshot">The Snapshot object to derive the Histogram from.</param>
<returns>A new instance of Histogram, based on the provided snapshot.</returns></documentation>
            <parameter name="snapshot" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
          <method name="FromFile" displayName="FromFile" id="M:Microsoft.Test.VisualVerification.Histogram.FromFile(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Histogram" id="T:Microsoft.Test.VisualVerification.Histogram" />
            <documentation><summary> Creates a Histogram object from a histogram curve file. </summary>
<param name="filePath">Name of the file containing the histogram curve.</param>
<returns>A new instance of Histogram, based on the specified file.</returns></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
          <method name="ToGraph" displayName="ToGraph" id="M:Microsoft.Test.VisualVerification.Histogram.ToGraph(System.String,System.Drawing.Imaging.ImageFormat)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Create a snapshot to visualize this histogram, and save it to a file. The graph will be 100 pixels high and 256 columns wide - one for each 'bin' in the histogram. The snapshot generated will be framed and slightly larger. </summary></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
            <parameter name="imageFormat" typeId="T:System.Drawing.Imaging.ImageFormat" valueType="false" />
          </method>
          <method name="Merge" displayName="Merge" id="M:Microsoft.Test.VisualVerification.Histogram.Merge(Microsoft.Test.VisualVerification.Histogram)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Histogram" id="T:Microsoft.Test.VisualVerification.Histogram" />
            <documentation><summary> Merges the specified input histogram curve with the current histogram by accumulating the per-brightness peak error quantities of two histograms. The Merge operation merges the peak values of the two histograms. </summary>
<param name="histogram">The histogram curve to be merged with.</param>
<returns>A new Histogram object, containing the peak values of both histogram curves.</returns></documentation>
            <parameter name="histogram" typeId="T:Microsoft.Test.VisualVerification.Histogram" valueType="false" />
          </method>
          <method name="ToFile" displayName="ToFile" id="M:Microsoft.Test.VisualVerification.Histogram.ToFile(System.String)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Saves the Histogram object to an XML file representation. </summary>
<param name="filePath">The path of the XML histogram file to be stored.</param></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="Snapshot" displayName="Snapshot" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.Snapshot" access="Public">
          <documentation><summary> Represents image pixels in a two-dimensional array for use in visual verification. Every element of the array represents a pixel at the given [row, column] of the image. A Snapshot object can be instantiated from a file or captured from the screen. </summary>
<example>Takes a snapshot and verifies it is an absolute match to an expected image. <code>        // Take a snapshot, compare to master image, validate match and save the diff
        // in case of a poor match.
        Snapshot actual = Snapshot.FromRectangle(new Rectangle(0, 0, 800, 600));
        Snapshot expected = Snapshot.FromFile("Expected.bmp");
        Snapshot diff = actual.CompareTo(expected);
     
        // The SnapshotColorVerifier.Verify() method compares every pixel of a diff bitmap 
        // against the threshold defined by the ColorDifference tolerance. If all pixels
        // fall within the tolerance, then the method returns VerificationResult.Pass
        SnapshotVerifier v = new SnapshotColorVerifier(Color.Black, new ColorDifference(0, 0, 0, 0));
        if (v.Verify(diff) == VerificationResult.Fail)
        {
            diff.ToFile("Actual.bmp", ImageFormat.Bmp);
        }
</code></example></documentation>
          <implementsClass type="System.ICloneable" id="T:System.ICloneable" displayName="ICloneable" namespace="System" />
          <property name="Item" id="P:Microsoft.Test.VisualVerification.Snapshot.Item(System.Int32,System.Int32)" access="Public" contract="Normal" typeId="T:System.Drawing.Color" valueType="true" get="Public" set="Public">
            <documentation><summary> Returns a Color instance for the pixel at the specified row and column. </summary>
<param name="row">Zero-based row position of the pixel.</param>
<param name="column">Zero-based column position of the pixel.</param>
<returns>A Color instance for the pixel at the specified row and column.</returns></documentation>
            <parameter name="row" typeId="T:System.Int32" valueType="true" />
            <parameter name="column" typeId="T:System.Int32" valueType="true" />
          </property>
          <property name="Width" id="P:Microsoft.Test.VisualVerification.Snapshot.Width" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Returns the width of the pixel buffer. </summary></documentation>
          </property>
          <property name="Height" id="P:Microsoft.Test.VisualVerification.Snapshot.Height" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Returns the height of the pixel buffer. </summary></documentation>
          </property>
          <method name="FromFile" displayName="FromFile" id="M:Microsoft.Test.VisualVerification.Snapshot.FromFile(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a Snapshot instance from data in the specified image file. </summary>
<param name="filePath">Path to the image file.</param>
<returns>A Snapshot instance containing the pixels in the loaded file.</returns></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
          <method name="FromWindow" displayName="FromWindow" id="M:Microsoft.Test.VisualVerification.Snapshot.FromWindow(System.IntPtr,Microsoft.Test.VisualVerification.WindowSnapshotMode)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a Snapshot instance populated with pixels sampled from the rectangle of the specified window. </summary>
<param name="windowHandle">The Win32 window handle (also known as an HWND), identifying the window to capture from.</param>
<param name="windowSnapshotMode">Determines if window border region should captured as part of Snapshot.</param>
<returns>A Snapshot instance of the pixels captured.</returns></documentation>
            <parameter name="windowHandle" typeId="T:System.IntPtr" valueType="true" />
            <parameter name="windowSnapshotMode" typeId="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" valueType="true" />
          </method>
          <method name="FromRectangle" displayName="FromRectangle" id="M:Microsoft.Test.VisualVerification.Snapshot.FromRectangle(System.Drawing.Rectangle)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a Snapshot instance populated with pixels sampled from the specified screen rectangle, from the context of the Desktop. </summary>
<param name="rectangle">Rectangle of the screen region to be sampled from.</param>
<returns>A Snapshot instance of the pixels from the bounds of the screen rectangle.</returns></documentation>
            <parameter name="rectangle" typeId="T:System.Drawing.Rectangle" valueType="true" />
          </method>
          <method name="Clone" displayName="Clone" id="M:Microsoft.Test.VisualVerification.Snapshot.Clone" access="Public" contract="Final" valueType="false">
            <returnType type="System.Object" id="T:System.Object" />
            <documentation><summary> Creates a deep-copied clone Snapshot with the same value as the existing instance. </summary>
<returns>Clone instance</returns></documentation>
            <implements name="Clone" id="M:System.ICloneable.Clone" interface="ICloneable" interfaceId="T:System.ICloneable" assembly="mscorlib" declaringType="System.ICloneable" />
          </method>
          <method name="CompareTo" displayName="CompareTo" id="M:Microsoft.Test.VisualVerification.Snapshot.CompareTo(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Compares the current Snapshot instance to the specified Snapshot to produce a difference image. Note: This does not compare alpha channels. </summary>
<param name="snapshot">The Snapshot to be compared to.</param>
<returns>A new Snapshot object representing the difference image (i.e. the result of the comparison).</returns></documentation>
            <parameter name="snapshot" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
          <method name="CompareTo" displayName="CompareTo" id="M:Microsoft.Test.VisualVerification.Snapshot.CompareTo(Microsoft.Test.VisualVerification.Snapshot,System.Boolean)" access="Public" contract="Normal" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Compares the current Snapshot instance to the specified Snapshot to produce a difference image. </summary>
<param name="snapshot">The target Snapshot to be compared to.</param>
<param name="compareAlphaChannel">If true, compares alpha channels. If false, the alpha channel difference values are fixed to 255.</param>
<returns>A new Snapshot object representing the difference image (i.e. the result of the comparison).</returns></documentation>
            <parameter name="snapshot" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
            <parameter name="compareAlphaChannel" typeId="T:System.Boolean" valueType="true" />
          </method>
          <method name="DrawLine" displayName="DrawLine" id="M:Microsoft.Test.VisualVerification.Snapshot.DrawLine(System.Int32,System.Int32,System.Int32,System.Drawing.Color)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Draw a vertical line from the bottom of the specified column up to the height given. </summary>
<param name="col">which column to draw in</param>
<param name="floor">the lowest pixel of the line</param>
<param name="height">the height of the line</param>
<param name="color">the color of the line</param></documentation>
            <parameter name="col" typeId="T:System.Int32" valueType="true" />
            <parameter name="floor" typeId="T:System.Int32" valueType="true" />
            <parameter name="height" typeId="T:System.Int32" valueType="true" />
            <parameter name="color" typeId="T:System.Drawing.Color" valueType="true" />
          </method>
          <method name="ToFile" displayName="ToFile" id="M:Microsoft.Test.VisualVerification.Snapshot.ToFile(System.String,System.Drawing.Imaging.ImageFormat)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Writes the current Snapshot (at 32 bits per pixel) to a file. </summary>
<param name="filePath">The path to the output file.</param>
<param name="imageFormat">The file storage format to be used.</param></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
            <parameter name="imageFormat" typeId="T:System.Drawing.Imaging.ImageFormat" valueType="false" />
          </method>
          <method name="Crop" displayName="Crop" id="M:Microsoft.Test.VisualVerification.Snapshot.Crop(System.Drawing.Rectangle)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a new Snapshot based on the cropped bounds of the current snapshot. </summary>
<param name="bounds">The bounding rectangle of the Snapshot.</param>
<returns></returns></documentation>
            <parameter name="bounds" typeId="T:System.Drawing.Rectangle" valueType="true" />
          </method>
          <method name="Resize" displayName="Resize" id="M:Microsoft.Test.VisualVerification.Snapshot.Resize(System.Drawing.Size)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a new Snapshot of the specified size from the original using bilinear interpolation. </summary>
<param name="size">Desired size of new image</param>
<returns></returns></documentation>
            <parameter name="size" typeId="T:System.Drawing.Size" valueType="true" />
          </method>
          <method name="Or" displayName="Or" id="M:Microsoft.Test.VisualVerification.Snapshot.Or(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Modifies the current image to contain the result of a bitwise OR of this Snapshot and the mask. This technique can be used to merge data from two images. http://en.wikipedia.org/wiki/Bitmask#Image_masks </summary>
<param name="mask">Mask Snapshot to use in the bitwise OR operation.</param></documentation>
            <parameter name="mask" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
          <method name="And" displayName="And" id="M:Microsoft.Test.VisualVerification.Snapshot.And(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Modifies the current image to contain the result of a bitwise AND of this Snapshot and the mask. This technique can be used to remove data from an image. http://en.wikipedia.org/wiki/Bitmask#Image_masks </summary>
<param name="mask">Mask Snapshot to use in the bitwise AND operation.</param></documentation>
            <parameter name="mask" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" access="Public" abstract="true">
          <documentation><summary> Base class for all Snapshot verifier types. This establishes a single method contract: Verify(Snapshot). </summary></documentation>
          <derivedBy id="T:Microsoft.Test.VisualVerification.SnapshotColorVerifier" displayName="SnapshotColorVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier" displayName="SnapshotHistogramVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier" displayName="SnapshotToleranceMapVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotVerifier.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VisualVerification.SnapshotVerifier" /> class.</summary>
            </documentation>
          </constructor>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Abstract" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Verifies the specified Snapshot instance against the current settings of the SnapshotVerifier instance. </summary>
<param name="image">The image to be verified.</param>
<returns>The verification result based on the supplied image and the current settings of the SnapshotVerifier instance.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotColorVerifier" displayName="SnapshotColorVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotColorVerifier" access="Public">
          <documentation><summary> Verifies that all pixels in a Snapshot are within tolerance range of ExpectedColor. </summary></documentation>
          <baseType name="SnapshotVerifier" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotColorVerifier.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of a SnapshotColorVerifier class, using black pixels with zero tolerance. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotColorVerifier.#ctor(System.Drawing.Color,Microsoft.Test.VisualVerification.ColorDifference)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the SnapshotColorVerifier class, using the specified tolerance value. </summary>
<param name="expectedColor">The expected color to test against.</param>
<param name="tolerance">A ColorDifference instance specifying the desired tolerance.</param></documentation>
            <parameter name="expectedColor" typeId="T:System.Drawing.Color" valueType="true" />
            <parameter name="tolerance" typeId="T:Microsoft.Test.VisualVerification.ColorDifference" valueType="false" />
          </constructor>
          <property name="Tolerance" id="P:Microsoft.Test.VisualVerification.SnapshotColorVerifier.Tolerance" access="Public" contract="Normal" typeId="T:Microsoft.Test.VisualVerification.ColorDifference" valueType="false" get="Public" set="Public">
            <documentation><summary> The color tolerance range for verification. To pass verification, all Snapshot pixels must be within range of the expected color tolerance. </summary></documentation>
          </property>
          <property name="ExpectedColor" id="P:Microsoft.Test.VisualVerification.SnapshotColorVerifier.ExpectedColor" access="Public" contract="Normal" typeId="T:System.Drawing.Color" valueType="true" get="Public" set="Public">
            <documentation><summary> The expected Color value for verification. </summary></documentation>
          </property>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotColorVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Override" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Ensures that the image colors are all within tolerance range of the expected Color. </summary>
<param name="image">The actual image being verified.</param>
<returns>A VerificationResult enumeration value based on the image, the expected color, and the tolerance.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotHistogramVerifier" displayName="SnapshotHistogramVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier" access="Public">
          <documentation><summary> Verifies a diffed image based on the number of pixels of a given brightness per color. A tolerance Histogram curve can be created from an XML file, produced from a reference image, or manually created for use as a tolerance. <p /> For more information on histograms, refer to the description of the Histogram class. </summary>
<example>Takes a snapshot and verifies it is an absolute match to an expected image. <code>        // Take a snapshot, compare to a master image, validate match using a tolerance histogram 
        // and save the diff in case of a poor match.
        Snapshot actual = Snapshot.FromRectangle(new Rectangle(0, 0, 800, 600));
        Snapshot expected = Snapshot.FromFile("Expected.bmp");
        Snapshot diff = actual.CompareTo(expected);
     
        SnapshotVerifier v = new SnapshotHistogramVerifier(Histogram.FromFile("ToleranceHistogram.xml"));
        if (v.Verify(diff) == VerificationResult.Fail)
        {
            diff.ToFile("Actual.bmp", ImageFormat.Bmp);
        }
</code></example></documentation>
          <baseType name="SnapshotVerifier" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the SnapshotHistgramVerifier class, with the tolerance histogram curve initialized to zero tolerance for non-black values. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.#ctor(Microsoft.Test.VisualVerification.Histogram)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the SnapshotHistgramVerifier class, with the tolerance histogram curve initialized to the specified tolerance value. </summary>
<param name="tolerance">The tolerance Histogram to use for verification.</param></documentation>
            <parameter name="tolerance" typeId="T:Microsoft.Test.VisualVerification.Histogram" valueType="false" />
          </constructor>
          <property name="Tolerance" id="P:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.Tolerance" access="Public" contract="Normal" typeId="T:Microsoft.Test.VisualVerification.Histogram" valueType="false" get="Public" set="Public">
            <documentation><summary> The tolerance Histogram that is used to test snapshots; snapshots must produce a histogram which falls below this curve in order to pass. </summary></documentation>
          </property>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Override" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Verifies a diffed image based on the number of pixels of a given brightness per color. A tolerance Histogram curve can be created from an XML file, produced from a reference image, or manually created for use as a tolerance. </summary>
<param name="image">The actual Snapshot to be verified.</param>
<returns>A VerificationResult enumeration value based on the image, the expected color, and the tolerance.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotToleranceMapVerifier" displayName="SnapshotToleranceMapVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier" access="Public">
          <documentation><summary> Verifies that all pixels in a Snapshot are within the tolerance range, defined by the tolerance map. </summary>
<example> This sample demonstrates the use of SnapshotToleranceMapVerifier. <code>        Snapshot expected = Shapshot.FromFile("expectedImage.png");
        Shapshot actual = Snapshot.FromRectangle(new Rectangle(10, 10, 200, 100));
        Snapshot diff = actual.CompareTo(master);
        
        Snapshot toleranceMap = Snapshot.FromFile("expectedImageTolerances.png");

        SnapshotVerifier v = new SnapshotToleranceMapVerifier(toleranceMap);
        if (v.Verify() == VerificationResult.Pass)
        {
            // Log success
        }
        else
        {
            // Log failure. Store the actual snapshot and the diff for investigation
            actual.ToFile("actualImage.png");
            diff.ToFile("diffImage.png");
        }
</code></example></documentation>
          <baseType name="SnapshotVerifier" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier.#ctor(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the SnapshotToleranceMapVerifier class, using the specified tolerance map. </summary>
<param name="toleranceMap"> A Snapshot instance defining the tolerance map, used by the verifier. A black tolerance map (a snapshot, where all pixels are with zero values) means zero tolerance. A white tolerance map (a snapshot, where all pixels are with value 0xFF) means infinitely high tolerance. </param></documentation>
            <parameter name="toleranceMap" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </constructor>
          <property name="ToleranceMap" id="P:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier.ToleranceMap" access="Public" contract="Normal" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" get="Public" set="Public">
            <documentation><summary> A Snapshot defining the tolerance map used by the verifier. A black tolerance map (a snapshot, where all pixels are with zero values) means zero tolerance. A white tolerance map (a snapshot, where all pixels are with value 0xFF) means infinitely high tolerance. </summary></documentation>
          </property>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Override" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Ensures that the image colors are all with smaller values than the image colors of the tolerance map. </summary>
<param name="image">The actual image being verified.</param>
<returns>A VerificationResult enumeration value based on the image, and the tolerance map.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <enumeration name="VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" displayName="VerificationResult" namespace="Microsoft.Test.VisualVerification" access="Public">
          <documentation><summary> Specifies values used to report the outcome of a verification. </summary></documentation>
          <field name="Fail" id="F:Microsoft.Test.VisualVerification.VerificationResult.Fail" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.VerificationResult" valueType="true" literal="true" value="0">
            <documentation><summary> Object does not meet verification criteria. </summary></documentation>
          </field>
          <field name="Pass" id="F:Microsoft.Test.VisualVerification.VerificationResult.Pass" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.VerificationResult" valueType="true" literal="true" value="1">
            <documentation><summary> Object meets verification criteria. </summary></documentation>
          </field>
        </enumeration>
        <enumeration name="WindowSnapshotMode" id="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" displayName="WindowSnapshotMode" namespace="Microsoft.Test.VisualVerification" access="Public">
          <documentation><summary> WindowSnapshotMode determines if window border should be captured as part of Snapshot. </summary></documentation>
          <field name="ExcludeWindowBorder" id="F:Microsoft.Test.VisualVerification.WindowSnapshotMode.ExcludeWindowBorder" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" valueType="true" literal="true" value="0">
            <documentation><summary> Capture a snapshot of only the window client area. This mode excludes the window border. </summary></documentation>
          </field>
          <field name="IncludeWindowBorder" id="F:Microsoft.Test.VisualVerification.WindowSnapshotMode.IncludeWindowBorder" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" valueType="true" literal="true" value="1">
            <documentation><summary> Capture a snapshot of the entire window area. This mode includes the window border. </summary></documentation>
          </field>
        </enumeration>
      </namespace>
    </module>
  </assembly>
  <assembly name="TestApiWpf">
    <assemblyReference name="mscorlib" />
    <assemblyReference name="TestApiCore" />
    <assemblyReference name="UIAutomationClient" />
    <assemblyReference name="UIAutomationTypes" />
    <assemblyReference name="WindowsBase" />
    <assemblyReference name="System" />
    <assemblyReference name="PresentationCore" />
    <assemblyReference name="PresentationFramework" />
    <assemblyReference name="System.Core" />
    <assemblyReference name="System.Drawing" />
    <module name="TestApiWpf.dll">
      <namespace name="Microsoft.Test">
        <class name="AutomationUtilities" displayName="AutomationUtilities" namespace="Microsoft.Test" id="T:Microsoft.Test.AutomationUtilities" access="Public" static="true">
          <documentation><summary> The AutomationUtilities class provides a simple interface to common <a href="http://msdn.microsoft.com/en-us/library/ms747327.aspx">UI Automation</a> (UIA) operations. The most common class of UIA operations in testing involves discovery of UI elements. </summary>
<example> This sample discovers and clicks the "Close" button in an "About" dialog box, thus dismissing the "About" dialog box. <code>        string aboutDialogName = "About";
        string closeButtonName = "Close";

        AutomationElementCollection aboutDialogs = AutomationUtilities.FindElementsByName(
            AutomationElement.RootElement,
            aboutDialogName);

        AutomationElementCollection closeButtons = AutomationUtilities.FindElementsByName(
            aboutDialogs[0],
            closeButtonName);

        // You can either invoke the discovered control, through its invoke pattern ...
        InvokePattern p = 
            closeButtons[0].GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;
        p.Invoke();

        // ... or you can handle the mouse directly and click on the control.
        System.Windows.Point winPoint = closeButtons[0].GetClickablePoint();
        System.Drawing.Point drawingPoint = new System.Drawing.Point((int)winPoint.X, (int)winPoint.Y);
        Mouse.MoveTo(drawingPoint);
        Mouse.Click(System.Windows.Input.MouseButton.Left);
</code></example></documentation>
          <method name="FindElementByIndex" displayName="FindElementByIndex" id="M:Microsoft.Test.AutomationUtilities.FindElementByIndex(System.Windows.Automation.AutomationElement,System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElement" id="T:System.Windows.Automation.AutomationElement" />
            <documentation><summary> Retrieves the child element with the specified index. </summary>
<param name="rootElement">The parent element (e.g., a ListBox control).</param>
<param name="index"> The index of the child element to find.</param>
<returns>An AutomationElement representing the discovered child element.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="FindElements" displayName="FindElements" id="M:Microsoft.Test.AutomationUtilities.FindElements(System.Windows.Automation.AutomationElement,System.Windows.Automation.Condition[])" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves all UIA elements that meet the specified conditions. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="conditions">Conditions that the returned collection should meet.</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="conditions" typeId="T:System.Windows.Automation.Condition" valueType="false" isParamArray="true" />
          </method>
          <method name="FindElementsByClassName" displayName="FindElementsByClassName" id="M:Microsoft.Test.AutomationUtilities.FindElementsByClassName(System.Windows.Automation.AutomationElement,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements with a given class name. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="className">The class name of the control type to find.</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="className" typeId="T:System.String" valueType="false" />
          </method>
          <method name="FindElementsByControlType" displayName="FindElementsByControlType" id="M:Microsoft.Test.AutomationUtilities.FindElementsByControlType(System.Windows.Automation.AutomationElement,System.Windows.Automation.ControlType)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements of a given control type. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="controlType">Control type of the control, such as Button.</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="controlType" typeId="T:System.Windows.Automation.ControlType" valueType="false" />
          </method>
          <method name="FindElementsById" displayName="FindElementsById" id="M:Microsoft.Test.AutomationUtilities.FindElementsById(System.Windows.Automation.AutomationElement,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements with a given UIA identifier. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="automationId">UIA identifier of the searched element, such as "button1".</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="automationId" typeId="T:System.String" valueType="false" />
          </method>
          <method name="FindElementsByName" displayName="FindElementsByName" id="M:Microsoft.Test.AutomationUtilities.FindElementsByName(System.Windows.Automation.AutomationElement,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements with a given name. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="name">Name of the searched element, such as "button1".</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="name" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="DispatcherOperations" displayName="DispatcherOperations" namespace="Microsoft.Test" id="T:Microsoft.Test.DispatcherOperations" access="Public" static="true">
          <documentation><summary> Helper class for the WPF Dispatcher. This class provides simple and consistent wrappers for common dispatcher operations. </summary>
<example>
  <code>        // SAMPLE USAGE #1:
        // Move the mouse to a certain location on the screen. Wait for a popup to appear. 
        // Verify that it appeared.
        TimeSpan defaultPopupDelay = TimeSpan.FromSeconds(2);
        Mouse.MoveTo(new System.Drawing.Point(100, 100));
        DispatcherOperations.WaitFor(defaultPopupDelay);
        // verify that the popup showed up.

        // SAMPLE USAGE #2:
        // Click on a button and verify that a mouse click event handler gets called.
        Mouse.MoveTo(new System.Drawing.Point(100, 100));
        Mouse.Click(System.Windows.Input.MouseButton.Left);
        DispatcherOperations.WaitFor(DispatcherPriority.SystemIdle);
        // verify that the handler has been clicked (e.g. check a isClicked variable)
</code>
</example></documentation>
          <method name="WaitFor" displayName="WaitFor" id="M:Microsoft.Test.DispatcherOperations.WaitFor(System.Windows.Threading.DispatcherPriority)" access="Public" contract="Static" valueType="true" overload="1">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> This method will wait until all pending DispatcherOperations of a priority higher than the specified priority have been processed. </summary>
<param name="priority">The priority to wait for before continuing.</param></documentation>
            <parameter name="priority" typeId="T:System.Windows.Threading.DispatcherPriority" valueType="true" />
          </method>
          <method name="WaitFor" displayName="WaitFor" id="M:Microsoft.Test.DispatcherOperations.WaitFor(System.TimeSpan)" access="Public" contract="Static" valueType="true" overload="2">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> This method will wait for the specified TimeSpan, allowing pending DispatcherOperations (such as UI rendering) to continue during that time. This method should be used with caution. Waiting for time is generally discouraged, because it may have an adverse effect on the overall run time of a test suite when the test suite has a large number of tests. </summary>
<param name="time">Amount of time to wait.</param></documentation>
            <parameter name="time" typeId="T:System.TimeSpan" valueType="true" />
          </method>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.ApplicationControl">
        <class name="UIAutomationOutOfProcessApplicationFactory" displayName="UIAutomationOutOfProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" access="Public">
          <documentation><summary> Factory for a UIAutomation implementation that AutomatedApplication will consume. </summary></documentation>
          <implementsClass type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" /> class.</summary>
            </documentation>
          </constructor>
          <method name="Create" displayName="Create" id="M:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" access="Public" contract="Final" valueType="false">
            <returnType type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
            <documentation><summary> Factory method for creating the IAutomatedApplicationImpl instance to be used by AutomatedApplication. </summary>
<param name="settings">The settings needed to create the specific instance</param>
<param name="appDomain">The UIAutomation app proxy does not require initialization on a separate appdomain</param>
<returns>Returns the application implementation of UIAutomation for an OutOfProcessApplication</returns></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.ApplicationSettings" valueType="false" />
            <parameter name="appDomain" typeId="T:System.AppDomain" valueType="false" />
            <implements name="Create" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" interface="IAutomatedApplicationImplFactory" interfaceId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" declaringType="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" />
          </method>
        </class>
        <class name="WpfInProcessApplicationFactory" displayName="WpfInProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" access="Public">
          <documentation><summary> Factory for a WpfApplication implementation that AutomatedApplication will consume. </summary></documentation>
          <implementsClass type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" /> class.</summary>
            </documentation>
          </constructor>
          <method name="Create" displayName="Create" id="M:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" access="Public" contract="Final" valueType="false">
            <returnType type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
            <documentation><summary> Factory method for creating the IAutomatedApplicationImpl instance to be used by AutomatedApplication. </summary>
<param name="settings">The settings needed to create the specific instance</param>
<param name="appDomain"> The AppDomain to create the implementation in. This will be null for scenarios where separate AppDomain is not specified. </param>
<returns>Returns the application implementation of Wpf for an InProcessApplication</returns></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.ApplicationSettings" valueType="false" />
            <parameter name="appDomain" typeId="T:System.AppDomain" valueType="false" />
            <implements name="Create" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" interface="IAutomatedApplicationImplFactory" interfaceId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" declaringType="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" />
          </method>
        </class>
        <class name="WpfInProcessApplicationSettings" displayName="WpfInProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" access="Public">
          <documentation><summary> Configures a WPF in-process test application. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="InProcessApplicationSettings" id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="ApplicationSettings" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="WindowClassName" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.WindowClassName" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> The window class to start. </summary>
<remarks> This must be the full class name. </remarks></documentation>
          </property>
          <property name="Path" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.Path" access="Public" contract="Normal" typeId="T:System.String" valueType="false" declaringType="Microsoft.Test.ApplicationControl.InProcessApplicationSettings" get="Public" set="Public">
            <documentation><summary> The application path to test. </summary></documentation>
          </property>
          <property name="InProcessApplicationType" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.InProcessApplicationType" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" declaringType="Microsoft.Test.ApplicationControl.InProcessApplicationSettings" get="Public" set="Public">
            <documentation><summary> The type of test application to create. </summary></documentation>
          </property>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" declaringType="Microsoft.Test.ApplicationControl.ApplicationSettings" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.Input">
        <class name="Keyboard" displayName="Keyboard" namespace="Microsoft.Test.Input" id="T:Microsoft.Test.Input.Keyboard" access="Public" static="true">
          <documentation><summary> Exposes a simple interface to common keyboard operations, allowing the user to simulate keyboard input. </summary>
<example> The following code types "Hello world" with the specified casing, and then types "hello, capitalized world" which will be in all caps because the left shift key is being held down. <code>            Keyboard.Type("Hello world");
            Keyboard.Press(Key.LeftShift);
            Keyboard.Type("hello, capitalized world");
            Keyboard.Release(Key.LeftShift);
</code></example></documentation>
          <method name="Press" displayName="Press" id="M:Microsoft.Test.Input.Keyboard.Press(System.Windows.Input.Key)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Presses down a key. </summary>
<param name="key">The key to press.</param></documentation>
            <parameter name="key" typeId="T:System.Windows.Input.Key" valueType="true" />
          </method>
          <method name="Release" displayName="Release" id="M:Microsoft.Test.Input.Keyboard.Release(System.Windows.Input.Key)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Releases a key. </summary>
<param name="key">The key to release.</param></documentation>
            <parameter name="key" typeId="T:System.Windows.Input.Key" valueType="true" />
          </method>
          <method name="Reset" displayName="Reset" id="M:Microsoft.Test.Input.Keyboard.Reset" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Resets the system keyboard to a clean state. </summary></documentation>
          </method>
          <method name="Type" displayName="Type" id="M:Microsoft.Test.Input.Keyboard.Type(System.Windows.Input.Key)" access="Public" contract="Static" valueType="true" overload="1">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Performs a press-and-release operation for the specified key, which is effectively equivallent to typing. </summary>
<param name="key">The key to press.</param></documentation>
            <parameter name="key" typeId="T:System.Windows.Input.Key" valueType="true" />
          </method>
          <method name="Type" displayName="Type" id="M:Microsoft.Test.Input.Keyboard.Type(System.String)" access="Public" contract="Static" valueType="true" overload="2">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Types the specified text. </summary>
<param name="text">The text to type.</param></documentation>
            <parameter name="text" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="Mouse" displayName="Mouse" namespace="Microsoft.Test.Input" id="T:Microsoft.Test.Input.Mouse" access="Public" static="true">
          <documentation><summary> Exposes a simple interface to common mouse operations, allowing the user to simulate mouse input. </summary>
<example>The following code moves to screen coordinate 100,100 and left clicks. <code>        Mouse.MoveTo(new Point(100, 100));
        Mouse.Click(MouseButton.Left);
</code></example></documentation>
          <method name="Click" displayName="Click" id="M:Microsoft.Test.Input.Mouse.Click(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Clicks a mouse button. </summary>
<param name="mouseButton">The mouse button to click.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
          <method name="DoubleClick" displayName="DoubleClick" id="M:Microsoft.Test.Input.Mouse.DoubleClick(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Double-clicks a mouse button. </summary>
<param name="mouseButton">The mouse button to click.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
          <method name="Down" displayName="Down" id="M:Microsoft.Test.Input.Mouse.Down(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Performs a mouse-down operation for a specified mouse button. </summary>
<param name="mouseButton">The mouse button to use.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
          <method name="MoveTo" displayName="MoveTo" id="M:Microsoft.Test.Input.Mouse.MoveTo(System.Drawing.Point)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Moves the mouse pointer to the specified screen coordinates. </summary>
<param name="point">The screen coordinates to move to.</param></documentation>
            <parameter name="point" typeId="T:System.Drawing.Point" valueType="true" />
          </method>
          <method name="Reset" displayName="Reset" id="M:Microsoft.Test.Input.Mouse.Reset" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Resets the system mouse to a clean state. </summary></documentation>
          </method>
          <method name="Scroll" displayName="Scroll" id="M:Microsoft.Test.Input.Mouse.Scroll(System.Double)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Simulates scrolling of the mouse wheel up or down. </summary>
<param name="lines">The number of lines to scroll. Use positive numbers to scroll up and negative numbers to scroll down.</param></documentation>
            <parameter name="lines" typeId="T:System.Double" valueType="true" />
          </method>
          <method name="Up" displayName="Up" id="M:Microsoft.Test.Input.Mouse.Up(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Performs a mouse-up operation for a specified mouse button. </summary>
<param name="mouseButton">The mouse button to use.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
        </class>
      </namespace>
    </module>
  </assembly>
</ndoc>