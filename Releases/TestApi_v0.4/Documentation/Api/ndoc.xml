<?xml version="1.0" encoding="utf-8"?>
<ndoc SchemaVersion="2.0" xmlns="urn:ndoc-schema">
  <threadsafety static="true" instance="false" />
  <namespaceHierarchies>
    <namespaceHierarchy name="Microsoft.Test">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.AutomationUtilities" displayName="AutomationUtilities" namespace="Microsoft.Test" assembly="TestApiWpf" />
        <hierarchyType id="T:Microsoft.Test.DispatcherOperations" displayName="DispatcherOperations" namespace="Microsoft.Test" assembly="TestApiWpf" />
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.ObjectComparison">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.ObjectComparison.GraphNode" displayName="GraphNode" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.ObjectComparison.ObjectComparer" displayName="ObjectComparer" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatch" displayName="ObjectComparisonMismatch" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.ObjectComparison.ObjectGraphFactory" displayName="ObjectGraphFactory" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore">
          <hierarchyType id="T:Microsoft.Test.ObjectComparison.PublicPropertyObjectGraphFactory" displayName="PublicPropertyObjectGraphFactory" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:System.ValueType" displayName="ValueType" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:System.Enum" displayName="Enum" namespace="System" assembly="mscorlib">
            <hierarchyInterfaces>
              <hierarchyInterface id="T:System.IComparable" displayName="IComparable" namespace="System" fullName="System.IComparable" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IConvertible" displayName="IConvertible" namespace="System" fullName="System.IConvertible" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IFormattable" displayName="IFormattable" namespace="System" fullName="System.IFormattable" assembly="mscorlib" />
            </hierarchyInterfaces>
            <hierarchyType id="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" displayName="ObjectComparisonMismatchType" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.LeakDetection">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.LeakDetection.MemorySnapshot" displayName="MemorySnapshot" namespace="Microsoft.Test.LeakDetection" assembly="TestApiCore" />
        <hierarchyType id="T:System.Collections.ObjectModel.Collection`1" displayName="Collection(T)" namespace="System.Collections.ObjectModel" assembly="mscorlib">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.ICollection`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IEnumerable`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IList`1" displayName="IList(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IList`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" fullName="System.Collections.ICollection" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" fullName="System.Collections.IEnumerable" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IList" displayName="IList" namespace="System.Collections" fullName="System.Collections.IList" assembly="mscorlib" />
          </hierarchyInterfaces>
          <hierarchyType id="T:Microsoft.Test.LeakDetection.MemorySnapshotCollection" displayName="MemorySnapshotCollection" namespace="Microsoft.Test.LeakDetection" assembly="TestApiCore" />
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.Input">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.Input.Keyboard" displayName="Keyboard" namespace="Microsoft.Test.Input" assembly="TestApiWpf" />
        <hierarchyType id="T:Microsoft.Test.Input.Mouse" displayName="Mouse" namespace="Microsoft.Test.Input" assembly="TestApiWpf" />
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.VariationGeneration">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Model" displayName="Model" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Parameter" displayName="Parameter" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.ICollection`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IEnumerable`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IList`1" displayName="IList(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IList`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" fullName="System.Collections.IEnumerable" assembly="mscorlib" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.ParameterValue" displayName="ParameterValue" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
        <hierarchyType id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary(TKey,TValue)" namespace="System.Collections.Generic" assembly="mscorlib">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.ICollection`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IDictionary`2" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IEnumerable`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" fullName="System.Collections.ICollection" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" fullName="System.Collections.IDictionary" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" fullName="System.Collections.IEnumerable" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.IDeserializationCallback" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.ISerializable" assembly="mscorlib" />
          </hierarchyInterfaces>
          <hierarchyType id="T:Microsoft.Test.VariationGeneration.Variation" displayName="Variation" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.ApplicationControl">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" displayName="WpfInProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          </hierarchyType>
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" displayName="OutOfProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" displayName="IAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl" displayName="IOutOfProcessAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" displayName="IAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" fullName="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" displayName="UIAutomationOutOfProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" fullName="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" displayName="WpfInProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" fullName="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:System.EventArgs" displayName="EventArgs" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" displayName="AutomatedApplicationEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs" displayName="AutomatedApplicationFocusChangedEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
        <hierarchyType id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.InProcessApplication" displayName="InProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplication" displayName="OutOfProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
        <hierarchyType id="T:System.ValueType" displayName="ValueType" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:System.Enum" displayName="Enum" namespace="System" assembly="mscorlib">
            <hierarchyInterfaces>
              <hierarchyInterface id="T:System.IComparable" displayName="IComparable" namespace="System" fullName="System.IComparable" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IConvertible" displayName="IConvertible" namespace="System" fullName="System.IConvertible" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IFormattable" displayName="IFormattable" namespace="System" fullName="System.IFormattable" assembly="mscorlib" />
            </hierarchyInterfaces>
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" displayName="AutomatedApplicationEventType" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" displayName="InProcessApplicationType" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.VariationGeneration.Constraints">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore">
          <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" displayName="AndConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" displayName="EqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" displayName="GreaterThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" displayName="GreaterThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" displayName="LessThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" displayName="LessThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" displayName="NotConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" displayName="NotEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" displayName="OrConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          </hierarchyType>
          <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" displayName="IfThenConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers" displayName="ConstraintHelpers" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.VisualVerification">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.VisualVerification.ColorDifference" displayName="ColorDifference" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VisualVerification.Histogram" displayName="Histogram" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.VisualVerification.Snapshot" displayName="Snapshot" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.ICloneable" displayName="ICloneable" namespace="System" fullName="System.ICloneable" assembly="mscorlib" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotHelper" displayName="SnapshotHelper" namespace="Microsoft.Test.VisualVerification" assembly="TestApiWpf" />
        <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore">
          <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotColorVerifier" displayName="SnapshotColorVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier" displayName="SnapshotHistogramVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <hierarchyType id="T:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier" displayName="SnapshotToleranceMapVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:System.ValueType" displayName="ValueType" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:System.Enum" displayName="Enum" namespace="System" assembly="mscorlib">
            <hierarchyInterfaces>
              <hierarchyInterface id="T:System.IComparable" displayName="IComparable" namespace="System" fullName="System.IComparable" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IConvertible" displayName="IConvertible" namespace="System" fullName="System.IConvertible" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IFormattable" displayName="IFormattable" namespace="System" fullName="System.IFormattable" assembly="mscorlib" />
            </hierarchyInterfaces>
            <hierarchyType id="T:Microsoft.Test.VisualVerification.VerificationResult" displayName="VerificationResult" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
            <hierarchyType id="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" displayName="WindowSnapshotMode" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.CommandLineParsing">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.CommandLineParsing.Command" displayName="Command" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.CommandLineParsing.CommandLineParser" displayName="CommandLineParser" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        <hierarchyType id="T:System.Attribute" displayName="Attribute" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.RequiredAttribute" displayName="RequiredAttribute" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary(TKey,TValue)" namespace="System.Collections.Generic" assembly="mscorlib">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.ICollection`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IDictionary`2" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" fullName="System.Collections.Generic.IEnumerable`1" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" fullName="System.Collections.ICollection" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" fullName="System.Collections.IDictionary" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" fullName="System.Collections.IEnumerable" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.IDeserializationCallback" assembly="mscorlib" />
            <hierarchyInterface id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.ISerializable" assembly="mscorlib" />
          </hierarchyInterfaces>
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" displayName="CommandLineDictionary" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        </hierarchyType>
        <hierarchyType id="T:System.ComponentModel.TypeConverter" displayName="TypeConverter" namespace="System.ComponentModel" assembly="System">
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter" displayName="DirectoryInfoConverter" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
          <hierarchyType id="T:Microsoft.Test.CommandLineParsing.FileInfoConverter" displayName="FileInfoConverter" namespace="Microsoft.Test.CommandLineParsing" assembly="TestApiCore" />
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.Text">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.Text.StringFactory" displayName="StringFactory" namespace="Microsoft.Test.Text" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.Text.StringProperties" displayName="StringProperties" namespace="Microsoft.Test.Text" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.Text.UnicodeRange" displayName="UnicodeRange" namespace="Microsoft.Test.Text" assembly="TestApiCore" />
        <hierarchyType id="T:System.ValueType" displayName="ValueType" namespace="System" assembly="mscorlib">
          <hierarchyType id="T:System.Enum" displayName="Enum" namespace="System" assembly="mscorlib">
            <hierarchyInterfaces>
              <hierarchyInterface id="T:System.IComparable" displayName="IComparable" namespace="System" fullName="System.IComparable" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IConvertible" displayName="IConvertible" namespace="System" fullName="System.IConvertible" assembly="mscorlib" />
              <hierarchyInterface id="T:System.IFormattable" displayName="IFormattable" namespace="System" fullName="System.IFormattable" assembly="mscorlib" />
            </hierarchyInterfaces>
            <hierarchyType id="T:Microsoft.Test.Text.UnicodeChart" displayName="UnicodeChart" namespace="Microsoft.Test.Text" assembly="TestApiCore" />
          </hierarchyType>
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
    <namespaceHierarchy name="Microsoft.Test.FaultInjection">
      <hierarchyType id="T:System.Object" displayName="Object" namespace="System" assembly="mscorlib">
        <hierarchyType id="T:Microsoft.Test.FaultInjection.BuiltInConditions" displayName="BuiltInConditions" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.BuiltInFaults" displayName="BuiltInFaults" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.CallStack" displayName="CallStack" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.ComRegistrar" displayName="ComRegistrar" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultDispatcher" displayName="FaultDispatcher" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultRule" displayName="FaultRule" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultSession" displayName="FaultSession" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.ICondition" displayName="ICondition" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.IFault" displayName="IFault" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        <hierarchyType id="T:Microsoft.Test.FaultInjection.RuntimeContext" displayName="RuntimeContext" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:Microsoft.Test.FaultInjection.IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" fullName="Microsoft.Test.FaultInjection.IRuntimeContext" assembly="TestApiCore" />
          </hierarchyInterfaces>
        </hierarchyType>
        <hierarchyType id="T:System.Exception" displayName="Exception" namespace="System" assembly="mscorlib">
          <hierarchyInterfaces>
            <hierarchyInterface id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" fullName="System.Runtime.Serialization.ISerializable" assembly="mscorlib" />
          </hierarchyInterfaces>
          <hierarchyType id="T:Microsoft.Test.FaultInjection.FaultInjectionException" displayName="FaultInjectionException" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
        </hierarchyType>
      </hierarchyType>
    </namespaceHierarchy>
  </namespaceHierarchies>
  <assembly name="TestApiCore">
    <assemblyReference name="mscorlib" />
    <assemblyReference name="System" />
    <assemblyReference name="System.Xml" />
    <assemblyReference name="System.Core" />
    <assemblyReference name="System.Drawing" />
    <module name="TestApiCore.dll">
      <namespace name="Microsoft.Test.ApplicationControl">
        <class name="ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" access="Public">
          <documentation><summary> Configuration info for an AutomatedApplication </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" displayName="OutOfProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.ApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.ApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.ApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
        <class name="AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" access="Public" abstract="true">
          <documentation><summary> Loads and starts a test application either in the current process or in a new, separate process. </summary>
<remarks> Represents the 'Abstraction' in Bridge pattern. </remarks>
<example> The following example shows in-process usage. The code runs the target application in a separate thread within the current process. <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new InProcessApplication(new WpfInProcessApplicationSettings
   {
        Path = path,
        InProcessApplicationType = InProcessApplicationType.InProcessSeparateThread,
        ApplicationImplementationFactory = new WpfInProcessApplicationFactory()
   });

   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example>
<example> The following example demonstrates out-of-process usage: <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new OutOfProcessApplication(new OutOfProcessApplicationSettings
   {
       ProcessStartInfo = new ProcessStartInfo(path),
       ApplicationImplementationFactory = new UIAutomationOutOfProcessApplicationFactory()
   });
 
   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example></documentation>
          <baseType name="MarshalByRefObject" id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.InProcessApplication" displayName="InProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplication" displayName="OutOfProcessApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.#ctor" access="Family" contract="Normal">
            <documentation><summary> AutomatedApplication objects are instantiated internally. </summary></documentation>
          </constructor>
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.MainWindow" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> The main window of the test application. </summary>
<remarks> This is an AutomationElement for an OutOfProcessApplication and a System.Windows.Window for an InProcessApplication. </remarks></documentation>
          </property>
          <property name="ApplicationImplementation" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.ApplicationImplementation" access="Family" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" valueType="false" get="Family" set="Family">
            <documentation><summary> Gets or sets the automated application implementation. </summary>
<remarks> This is the 'implementation' following the bridge pattern. </remarks></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.IsMainWindowOpened" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" get="Family" set="false">
            <documentation><summary> Indicates whether the main window of the test application is open. </summary></documentation>
          </property>
          <property name="IsApplicationRunning" id="P:Microsoft.Test.ApplicationControl.AutomatedApplication.IsApplicationRunning" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" get="Family" set="Family">
            <documentation><summary> Indicates whether the test application is running. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.Start" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Starts the test application after validating its settings. </summary>
<remarks> Refined abstractions are expected to initialize AutomatedAppImp and call AutomatedAppImp.Start(). </remarks></documentation>
          </method>
          <method name="WaitForMainWindow" displayName="WaitForMainWindow" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.WaitForMainWindow(System.TimeSpan)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to display its main window. </summary>
<remarks> Blocks execution of the current thread until the window is displayed or until the specified timeout interval elapses. </remarks>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="WaitForWindow" displayName="WaitForWindow" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.WaitForWindow(System.String,System.TimeSpan)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to display a window with a specified name. </summary>
<remarks> Blocks execution of the current thread until the window is displayed or until the specified timeout interval elapses. </remarks>
<param name="windowName">The window to wait for.</param>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="windowName" typeId="T:System.String" valueType="false" />
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="Close" displayName="Close" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.Close" access="Public" contract="Virtual" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Closes the automated application gracefully. </summary></documentation>
          </method>
          <method name="WaitForInputIdle" displayName="WaitForInputIdle" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.WaitForInputIdle(System.TimeSpan)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to enter an idle state. </summary>
<remarks> Blocks execution of the current thread until the window is displayed or until the specified timeout interval elapses. </remarks>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="AddEventHandler" displayName="AddEventHandler" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.AddEventHandler(Microsoft.Test.ApplicationControl.AutomatedApplicationEventType,System.Delegate)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Adds an event handler for the given AutomatedApplicationEventType. </summary>
<param name="eventType">The type of event to listen for.</param>
<param name="handler">The delegate to be called when the event occurs.</param></documentation>
            <parameter name="eventType" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" />
            <parameter name="handler" typeId="T:System.Delegate" valueType="false" />
          </method>
          <method name="RemoveEventHandler" displayName="RemoveEventHandler" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.RemoveEventHandler(Microsoft.Test.ApplicationControl.AutomatedApplicationEventType,System.Delegate)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Removes an event handler for the given AutomatedApplicationEventType. </summary>
<param name="eventType">The type of event to remove.</param>
<param name="handler">The delegate to remove.</param></documentation>
            <parameter name="eventType" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" />
            <parameter name="handler" typeId="T:System.Delegate" valueType="false" />
          </method>
          <method name="OnMainWindowOpened" displayName="OnMainWindowOpened" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.OnMainWindowOpened(System.Object,System.EventArgs)" access="Family" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Wrapper to signal the MainWindowOpened event </summary>
<param name="sender">The source of the event which is IAutomatedApplicationImpl.</param>
<param name="e">An System.EventArgs that contains no event data.</param></documentation>
            <parameter name="sender" typeId="T:System.Object" valueType="false" />
            <parameter name="e" typeId="T:System.EventArgs" valueType="false" />
          </method>
          <method name="OnFocusChanged" displayName="OnFocusChanged" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.OnFocusChanged(System.Object,System.EventArgs)" access="Family" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Wrapper to signal the FocusChanged event </summary>
<param name="sender">The source of the event which is IAutomatedApplicationImpl.</param>
<param name="e">An System.EventArgs that contains no event data.</param></documentation>
            <parameter name="sender" typeId="T:System.Object" valueType="false" />
            <parameter name="e" typeId="T:System.EventArgs" valueType="false" />
          </method>
          <method name="OnExit" displayName="OnExit" id="M:Microsoft.Test.ApplicationControl.AutomatedApplication.OnExit(System.Object,System.EventArgs)" access="Family" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Wrapper to signal the Exited event </summary>
<param name="sender">The source of the event which is IAutomatedApplicationImpl.</param>
<param name="e">An System.EventArgs that contains no event data.</param></documentation>
            <parameter name="sender" typeId="T:System.Object" valueType="false" />
            <parameter name="e" typeId="T:System.EventArgs" valueType="false" />
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.AutomatedApplication.MainWindowOpened" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" multicast="true">
            <documentation><summary> Notifies listeners that the MainWindow of the test application has opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.AutomatedApplication.Exited" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" multicast="true">
            <documentation><summary> Notifies listeners that the test application has exited. </summary></documentation>
          </event>
        </class>
        <class name="AutomatedApplicationEventArgs" displayName="AutomatedApplicationEventArgs" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" access="Public">
          <documentation><summary> Represents the event args passed to AutomatedApplication events. </summary></documentation>
          <baseType name="EventArgs" id="T:System.EventArgs" displayName="EventArgs" namespace="System" assembly="mscorlib" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs" displayName="AutomatedApplicationFocusChangedEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs.#ctor(Microsoft.Test.ApplicationControl.AutomatedApplication)" access="Public" contract="Normal">
            <documentation><summary> Constructs an AutomatedApplicationEventArgs instance with the given AutomatedApplication. </summary>
<param name="automatedApp">The AutomatedApplication data to pass to the listeners.</param></documentation>
            <parameter name="automatedApp" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" />
          </constructor>
          <property name="AutomatedApplication" id="P:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs.AutomatedApplication" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" get="Public" set="Public">
            <documentation><summary> The AutomatedApplication data passed to listeners. </summary></documentation>
          </property>
        </class>
        <class name="AutomatedApplicationFocusChangedEventArgs" displayName="AutomatedApplicationFocusChangedEventArgs" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs" access="Public">
          <documentation><summary> Represents the event args passed to AutomatedApplication focus changed events. </summary></documentation>
          <baseType name="AutomatedApplicationEventArgs" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" displayName="AutomatedApplicationEventArgs" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="EventArgs" id="T:System.EventArgs" displayName="EventArgs" namespace="System" assembly="mscorlib" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs.#ctor(Microsoft.Test.ApplicationControl.AutomatedApplication,System.Object)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the AutomatedApplicationFocusChangedEventArgs class. </summary>
<param name="automatedApp"> The AutomatedApplication data to pass to the listeners. </param>
<param name="newFocusedElement"> The new focused element data to pass the listeners. This can be an AutomationElement for an out-of-process scenario or a UIElement for an in-process WPF scenario. </param></documentation>
            <parameter name="automatedApp" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" />
            <parameter name="newFocusedElement" typeId="T:System.Object" valueType="false" />
          </constructor>
          <property name="NewFocusedElement" id="P:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs.NewFocusedElement" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> The new focused element passed to the listeners. </summary></documentation>
          </property>
          <property name="AutomatedApplication" id="P:Microsoft.Test.ApplicationControl.AutomatedApplicationFocusChangedEventArgs.AutomatedApplication" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplication" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplicationEventArgs" get="Public" set="Public">
            <documentation><summary> The AutomatedApplication data passed to listeners. </summary></documentation>
          </property>
        </class>
        <class name="InProcessApplication" displayName="InProcessApplication" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.InProcessApplication" access="Public">
          <documentation><summary> Represents a test application running in the current process. </summary>
<example> The following example demonstrates how to use this class. The code runs the target application in a separate thread within the current process. <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new InProcessApplication(new WpfInProcessApplicationSettings
   {
        Path = path,
        InProcessApplicationType = InProcessApplicationType.InProcessSeparateThread,
        ApplicationImplementationFactory = new WpfInProcessApplicationFactory()
   });

   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example></documentation>
          <baseType name="AutomatedApplication" id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="MarshalByRefObject" id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.InProcessApplication.#ctor(Microsoft.Test.ApplicationControl.InProcessApplicationSettings)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of an InProcessApplication. </summary>
<param name="settings">The settings used to start the test application.</param></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" valueType="false" />
          </constructor>
          <property name="ApplicationDriver" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.ApplicationDriver" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> Access to the UI thread dispatcher. </summary>
<remarks> This is used only for the in-proc/separate thread scenario. </remarks></documentation>
          </property>
          <property name="ApplicationSettings" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.ApplicationSettings" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" valueType="false" get="Public" set="Family">
            <documentation><summary> The settings for the test application. </summary></documentation>
          </property>
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.MainWindow" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Public" set="false">
            <documentation><summary> The main window of the test application. </summary></documentation>
          </property>
          <property name="ApplicationImplementation" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.ApplicationImplementation" access="Family" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Gets or sets the automated application implementation. </summary></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.IsMainWindowOpened" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="false">
            <documentation><summary> Indicates whether the main window of the test application is open. </summary></documentation>
          </property>
          <property name="IsApplicationRunning" id="P:Microsoft.Test.ApplicationControl.InProcessApplication.IsApplicationRunning" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Indicates whether the test application is running. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.InProcessApplication.Start" access="Public" contract="Override" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Creates and starts the test application. </summary>
<remarks> Depending on the AutomatedApplicationType this can be on the same thread or on a separate thread. </remarks></documentation>
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.InProcessApplication.MainWindowOpened" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the MainWindow of the test application has opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.InProcessApplication.Exited" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the test application has exited. </summary></documentation>
          </event>
        </class>
        <class name="InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" access="Public">
          <documentation><summary> Configures an in-process test application. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="ApplicationSettings" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" displayName="WpfInProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Path" id="P:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.Path" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> The application path to test. </summary></documentation>
          </property>
          <property name="InProcessApplicationType" id="P:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.InProcessApplicationType" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" get="Public" set="Public">
            <documentation><summary> The type of test application to create. </summary></documentation>
          </property>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.InProcessApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" declaringType="Microsoft.Test.ApplicationControl.ApplicationSettings" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
        <class name="OutOfProcessApplication" displayName="OutOfProcessApplication" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplication" access="Public">
          <documentation><summary> Represents a test application running in a new, separate process. </summary>
<example> The following example demonstrates how to use this class: <code>public void MyTest()
{
   var path = Path.Combine(executionDir, "WpfTestApplication.exe");
   var aa = new OutOfProcessApplication(new OutOfProcessApplicationSettings
   {
       ProcessStartInfo = new ProcessStartInfo(path),
       ApplicationImplementationFactory = new UIAutomationOutOfProcessApplicationFactory()
   });
 
   aa.Start();
   aa.WaitForMainWindow(TimeSpan.FromMilliseconds(5000));
   
   // Perform various tests...
   
   aa.Close();
}
</code></example></documentation>
          <baseType name="AutomatedApplication" id="T:Microsoft.Test.ApplicationControl.AutomatedApplication" displayName="AutomatedApplication" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="MarshalByRefObject" id="T:System.MarshalByRefObject" displayName="MarshalByRefObject" namespace="System" assembly="mscorlib" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.OutOfProcessApplication.#ctor(Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of an OutOfProcessApplication. </summary>
<param name="settings">The settings used to start the test application.</param></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" valueType="false" />
          </constructor>
          <property name="ApplicationSettings" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.ApplicationSettings" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" valueType="false" get="Public" set="Family">
            <documentation><summary> The settings for the test application. </summary></documentation>
          </property>
          <property name="Process" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.Process" access="Public" contract="Normal" typeId="T:System.Diagnostics.Process" valueType="false" get="Public" set="false">
            <documentation><summary> Get the process associated with the application. </summary></documentation>
          </property>
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.MainWindow" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Public" set="false">
            <documentation><summary> The main window of the test application. </summary></documentation>
          </property>
          <property name="ApplicationImplementation" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.ApplicationImplementation" access="Family" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Gets or sets the automated application implementation. </summary></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.IsMainWindowOpened" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="false">
            <documentation><summary> Indicates whether the main window of the test application is open. </summary></documentation>
          </property>
          <property name="IsApplicationRunning" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplication.IsApplicationRunning" access="Family" contract="Normal" typeId="T:System.Boolean" valueType="true" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" get="Family" set="Family">
            <documentation><summary> Indicates whether the test application is running. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.OutOfProcessApplication.Start" access="Public" contract="Override" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Creates and starts the test application. </summary></documentation>
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.OutOfProcessApplication.MainWindowOpened" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the MainWindow of the test application has opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.OutOfProcessApplication.Exited" access="Public" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="Microsoft.Test.ApplicationControl.AutomatedApplication" multicast="true">
            <documentation><summary> Notifies listeners that the test application has exited. </summary></documentation>
          </event>
        </class>
        <class name="OutOfProcessApplicationSettings" displayName="OutOfProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" access="Public">
          <documentation><summary> Configures an out-of-process test application. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="ApplicationSettings" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="ProcessStartInfo" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings.ProcessStartInfo" access="Public" contract="Normal" typeId="T:System.Diagnostics.ProcessStartInfo" valueType="false" get="Public" set="Public">
            <documentation><summary> The ProcessStartInfo to start a process. </summary></documentation>
          </property>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.OutOfProcessApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" declaringType="Microsoft.Test.ApplicationControl.ApplicationSettings" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
        <interface name="IAutomatedApplicationImpl" displayName="IAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" access="Public">
          <documentation><summary> Defines the contract for an AutomatedApplication. </summary>
<remarks> Represents the 'Implemention' inteface for a bridge pattern. As such, this can vary from the public interface of AutomatedApplication. </remarks></documentation>
          <derivedBy id="T:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl" displayName="IOutOfProcessAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          <property name="MainWindow" id="P:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.MainWindow" access="Public" contract="Abstract" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> The test application's main window. </summary></documentation>
          </property>
          <property name="ApplicationDriver" id="P:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.ApplicationDriver" access="Public" contract="Abstract" typeId="T:System.Object" valueType="false" get="Public" set="false">
            <documentation><summary> The driver of the test application. </summary></documentation>
          </property>
          <property name="IsMainWindowOpened" id="P:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.IsMainWindowOpened" access="Public" contract="Abstract" typeId="T:System.Boolean" valueType="true" get="Public" set="false">
            <documentation><summary> The value indicating whether the test application's main window has opened. </summary></documentation>
          </property>
          <method name="Start" displayName="Start" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.Start" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Starts the test application. </summary></documentation>
          </method>
          <method name="Close" displayName="Close" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.Close" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Closes the test application. </summary></documentation>
          </method>
          <method name="WaitForMainWindow" displayName="WaitForMainWindow" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.WaitForMainWindow(System.TimeSpan)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application's main window to open. </summary>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="WaitForWindow" displayName="WaitForWindow" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.WaitForWindow(System.String,System.TimeSpan)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the given window to open. </summary>
<param name="windowName">The window id of the window to wait for.</param>
<param name="timeout">The timeout interval.</param></documentation>
            <parameter name="windowName" typeId="T:System.String" valueType="false" />
            <parameter name="timeout" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <method name="WaitForInputIdle" displayName="WaitForInputIdle" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.WaitForInputIdle(System.TimeSpan)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Waits for the test application to become idle. </summary>
<param name="timeSpan">The timeout interval.</param></documentation>
            <parameter name="timeSpan" typeId="T:System.TimeSpan" valueType="true" />
          </method>
          <event name="MainWindowOpened" id="E:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.MainWindowOpened" access="Public" contract="Abstract" typeId="T:System.EventHandler" valueType="false" multicast="true">
            <documentation><summary> Occurs when the test application's main window is opened. </summary></documentation>
          </event>
          <event name="Exited" id="E:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.Exited" access="Public" contract="Abstract" typeId="T:System.EventHandler" valueType="false" multicast="true">
            <documentation><summary> Occurs when the test application exits. </summary></documentation>
          </event>
          <event name="FocusChanged" id="E:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl.FocusChanged" access="Public" contract="Abstract" typeId="T:System.EventHandler" valueType="false" multicast="true">
            <documentation><summary> Occurs when focus changes. </summary></documentation>
          </event>
        </interface>
        <interface name="IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" access="Public">
          <documentation><summary> Defines the contract for creating an IAutomatedApplicationImpl instance </summary></documentation>
          <implementedBy id="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" displayName="UIAutomationOutOfProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          <implementedBy id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" displayName="WpfInProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiWpf" />
          <method name="Create" displayName="Create" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" access="Public" contract="Abstract" valueType="false">
            <returnType type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
            <documentation><summary> Factory method for creating the IAutomatedApplicationImpl instance to be used by AutomatedApplication. </summary>
<param name="settings">The settings to be passed the the implementation instance</param>
<param name="appDomain"> The AppDomain to create the implementation in. This is intended for in-proc scenarios where the AutomatedApplication needs to create the proxy in a separate appdomain. </param>
<returns>Returns the application implementation to be used by AutomatedApplication</returns></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.ApplicationSettings" valueType="false" />
            <parameter name="appDomain" typeId="T:System.AppDomain" valueType="false" />
          </method>
        </interface>
        <interface name="IOutOfProcessAutomatedApplicationImpl" displayName="IOutOfProcessAutomatedApplicationImpl" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl" access="Public">
          <documentation><summary> Defines the contract for an out of process AutomatedApplication. </summary>
<remarks> Represents the 'Implemention' inteface for a bridge pattern. As such, this can vary from the public interface of AutomatedApplication. </remarks></documentation>
          <implements type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" assembly="TestApiCore" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
          <property name="Process" id="P:Microsoft.Test.ApplicationControl.IOutOfProcessAutomatedApplicationImpl.Process" access="Public" contract="Abstract" typeId="T:System.Diagnostics.Process" valueType="false" get="Public" set="false">
            <documentation><summary> Gets the process associated with the application. </summary></documentation>
          </property>
        </interface>
        <enumeration name="AutomatedApplicationEventType" id="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" displayName="AutomatedApplicationEventType" namespace="Microsoft.Test.ApplicationControl" access="Public">
          <documentation><summary> Specifies the supported AutomatedApplication events. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <field name="MainWindowOpenedEvent" id="F:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType.MainWindowOpenedEvent" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" literal="true" value="0">
            <documentation><summary> The test application's main window opened event. </summary></documentation>
          </field>
          <field name="ApplicationExitedEvent" id="F:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType.ApplicationExitedEvent" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" literal="true" value="1">
            <documentation><summary> The test application closed event. </summary></documentation>
          </field>
          <field name="FocusChangedEvent" id="F:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType.FocusChangedEvent" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.AutomatedApplicationEventType" valueType="true" literal="true" value="2">
            <documentation><summary> The test application's main window's focus changed event. </summary></documentation>
          </field>
        </enumeration>
        <enumeration name="InProcessApplicationType" id="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" displayName="InProcessApplicationType" namespace="Microsoft.Test.ApplicationControl" access="Public">
          <documentation><summary> Defines the Thread and AppDomain properties of an InProcessApplication. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <field name="InProcessSeparateThread" id="F:Microsoft.Test.ApplicationControl.InProcessApplicationType.InProcessSeparateThread" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" literal="true" value="0">
            <documentation><summary> A test application that runs in-process and on a separate thread. </summary></documentation>
          </field>
          <field name="InProcessSeparateThreadAndAppDomain" id="F:Microsoft.Test.ApplicationControl.InProcessApplicationType.InProcessSeparateThreadAndAppDomain" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" literal="true" value="1">
            <documentation><summary> A test application that runs in-process, on a separate thread and in a separate AppDomain. </summary></documentation>
          </field>
          <field name="InProcessSameThread" id="F:Microsoft.Test.ApplicationControl.InProcessApplicationType.InProcessSameThread" access="Public" contract="Static" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" literal="true" value="2">
            <documentation><summary> A test application that runs in-process and on the same thread. </summary></documentation>
          </field>
        </enumeration>
      </namespace>
      <namespace name="Microsoft.Test.CommandLineParsing">
        <class name="Command" displayName="Command" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.Command" access="Public" abstract="true">
          <documentation><summary> An abstract class describing a command which has a name and an execute method. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.Command.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.Command" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Name" id="P:Microsoft.Test.CommandLineParsing.Command.Name" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The name of the command. The base implementation is to strip off the last instance of "Command" from the end of the type name. So "DiscoverCommand" would become "Discover". If the type name does not have the string "Command" in it, then the name of the command is the same as the type name. This behavior can be overridden, but most derived classes are going to be of the form [Command Name] + Command. </summary></documentation>
          </property>
          <method name="Execute" displayName="Execute" id="M:Microsoft.Test.CommandLineParsing.Command.Execute" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Executes the command. </summary></documentation>
          </method>
        </class>
        <class name="CommandLineDictionary" displayName="CommandLineDictionary" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" access="Public">
          <documentation><summary> A dictionary that is aware of command line input patterns. All lookups for keys ignore case. </summary>
<example> This is a sample for parsing the following command line: Test.exe /verbose /runId=10 <code>        CommandLineDictionary cld = CommandLineDictionary.FromArguments(args);
        bool verbose = cld.ContainsKey("verbose");
        int runId = Int32.Parse(cld["runId"]);

        // You can also explicitly provide key and value identifiers for the cases
        // that use other characters (rather than ‘/’ and ‘=’) as key/value identifiers
        CommandLineDictionary cld = CommandLineDictionary.FromArguments(args, '-', ':');   
</code></example></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="Dictionary`2" id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary`2" namespace="System.Collections.Generic" assembly="mscorlib">
            <genericargument name="System.String" />
            <genericargument name="System.String" />
          </baseType>
          <implementsClass type="System.Collections.Generic.IDictionary`2" id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="TKey" />
            <genericargument name="TValue" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.ICollection`1" id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.IEnumerable`1" id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.IEnumerable" id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.IDictionary" id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.ICollection" id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.ISerializable" id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.IDeserializationCallback" id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" inherited="true" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Create an empty CommandLineDictionary using the default key/value separators of '/' and '='. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" access="Family" contract="Normal" overload="2">
            <documentation><summary> Creates a dictionary using a serialization info and context. This is used for Xml deserialization and isn't normally called from user code. </summary>
<param name="info">Data needed to deserialize the dictionary.</param>
<param name="context">Describes source and destination of the stream.</param></documentation>
            <parameter name="info" typeId="T:System.Runtime.Serialization.SerializationInfo" valueType="false" />
            <parameter name="context" typeId="T:System.Runtime.Serialization.StreamingContext" valueType="true" />
          </constructor>
          <property name="Comparer" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Comparer" access="Public" contract="Normal" typeId="T:System.Collections.Generic.IEqualityComparer`1" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
          </property>
          <property name="Count" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Count" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <implements name="Count" id="P:System.Collections.ICollection.Count" interface="ICollection" assembly="mscorlib" interfaceId="T:System.Collections.ICollection" declaringType="System.Collections.ICollection" />
          </property>
          <property name="Keys" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Keys" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.KeyCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.String" />
          </property>
          <property name="Values" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Values" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.ValueCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.String" />
          </property>
          <property name="Item" id="P:Microsoft.Test.CommandLineParsing.CommandLineDictionary.Item(System.String)" access="Public" contract="Final" typeId="T:System.String" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="Public">
            <documentation><summary></summary></documentation>
            <parameter name="key" typeId="T:System.String" valueType="false" />
            <implements name="Item" id="P:System.Collections.Generic.IDictionary`2.Item(System.String)" interface="IDictionary`2" assembly="mscorlib" interfaceId="T:System.Collections.Generic.IDictionary`2" declaringType="System.Collections.Generic.IDictionary`2" />
          </property>
          <method name="FromArguments" displayName="FromArguments" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.FromArguments(System.Collections.Generic.IEnumerable{System.String})" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.CommandLineParsing.CommandLineDictionary" id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" />
            <documentation><summary> Initializes a new instance of the CommandLineDictionary class, populating a dictionary with key/value pairs from a command line that supports syntax where options are provided in the form "/key=value". </summary>
<param name="arguments">Key/value pairs.</param>
<returns></returns></documentation>
            <parameter name="arguments" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="System.String" />
            </parameter>
          </method>
          <method name="FromArguments" displayName="FromArguments" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.FromArguments(System.Collections.Generic.IEnumerable{System.String},System.Char,System.Char)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.CommandLineParsing.CommandLineDictionary" id="T:Microsoft.Test.CommandLineParsing.CommandLineDictionary" />
            <documentation><summary> Creates a dictionary that is populated with key/value pairs from a command line that supports syntax where options are provided in the form "/key=value". This method supports the ability to specify delimiter characters for options in the command line. </summary>
<param name="arguments">Key/value pairs.</param>
<param name="keyCharacter">A character that precedes a key.</param>
<param name="valueCharacter">A character that separates a key from a value.</param>
<returns></returns></documentation>
            <parameter name="arguments" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="System.String" />
            </parameter>
            <parameter name="keyCharacter" typeId="T:System.Char" valueType="true" />
            <parameter name="valueCharacter" typeId="T:System.Char" valueType="true" />
          </method>
          <method name="ToString" displayName="ToString" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.ToString" access="Public" contract="Override" valueType="false">
            <returnType type="System.String" id="T:System.String" />
            <documentation><summary> Converts dictionary contents to a command line string of key/value pairs. </summary>
<returns>Command line string.</returns></documentation>
          </method>
          <method name="GetObjectData" displayName="GetObjectData" id="M:Microsoft.Test.CommandLineParsing.CommandLineDictionary.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" access="Public" contract="Override" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Populates a SerializationInfo with data needed to serialize the dictionary. This is used by Xml serialization and isn't normally called from user code. </summary>
<param name="info">SerializationInfo object to populate.</param>
<param name="context">StreamingContext to populate data from.</param></documentation>
            <parameter name="info" typeId="T:System.Runtime.Serialization.SerializationInfo" valueType="false" />
            <parameter name="context" typeId="T:System.Runtime.Serialization.StreamingContext" valueType="true" />
            <implements name="GetObjectData" id="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" interface="ISerializable" interfaceId="T:System.Runtime.Serialization.ISerializable" assembly="mscorlib" declaringType="System.Runtime.Serialization.ISerializable" />
          </method>
        </class>
        <class name="CommandLineParser" displayName="CommandLineParser" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.CommandLineParser" access="Public" static="true">
          <documentation><summary> Provides utilities for parsing command-line values. </summary>
<example> The following example shows how to parse to a strongly typed data structure and to an executable command structure. <code>        // SAMPLE USAGE #1:
        // Sample for parsing the following command-line:
        // Test.exe /verbose /runId=10
        // This sample declares a class in which the strongly typed arguments are populated
        public class CommandLineArguments
        {
           bool? Verbose { get; set; }
           int? RunId { get; set; }
        }
    
        CommandLineArguments cla = new CommandLineArguments();
        cla.ParseArguments(args);
    
        // SAMPLE USAGE #2:
        // Sample for parsing the following command-line:
        // Test.exe run /verbose /id=10
        // In this particular case we have an actual command on the command-line (“run”),
        // which we want to effectively de-serialize and execute.
        public class RunCommand : Command
        {
            bool? Verbose { get; set; }
            int? RunId { get; set; }
 
            public override void Execute()
            {
            }
        }

        Command command = new RunCommand();
        command.ParseArguments(args);
        command.Execute();
</code></example></documentation>
          <method name="ParseArguments" displayName="ParseArguments" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.ParseArguments(System.Object,System.Collections.Generic.IEnumerable{System.String})" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Sets properties on an object from a series of key/value string arguments that are in the form "/PropertyName=Value", where the value is converted from a string into the property type. </summary>
<param name="valueToPopulate">The object to set properties on.</param>
<param name="args">The key/value arguments describing the property names and values to set.</param>
<returns> Indicates whether the properties were successfully set. Reasons for failure reasons include a property name that does not exist or a value that cannot be converted from a string. </returns>
<exception cref="T:System.ArgumentException">Thrown when one of the key/value strings cannot be parsed into a property.</exception></documentation>
            <parameter name="valueToPopulate" typeId="T:System.Object" valueType="false" extension="true" />
            <parameter name="args" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false" extension="true">
              <genericargument name="System.String" />
            </parameter>
          </method>
          <method name="PrintUsage" displayName="PrintUsage" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.PrintUsage(System.Object)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Prints names and descriptions for properties on the specified component. </summary>
<param name="component">The component to print usage for.</param></documentation>
            <parameter name="component" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="PrintCommands" displayName="PrintCommands" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.PrintCommands(System.Collections.Generic.IEnumerable{Microsoft.Test.CommandLineParsing.Command})" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Prints a general summary of each command. </summary>
<param name="commands">A collection of possible commands.</param></documentation>
            <parameter name="commands" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.CommandLineParsing.Command" />
            </parameter>
          </method>
          <method name="ToString" displayName="ToString" id="M:Microsoft.Test.CommandLineParsing.CommandLineParser.ToString(System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="System.String" id="T:System.String" />
            <documentation><summary> Creates a string that represents key/value arguments for the properties of the specified object. For example, an object with a name (string) of "example" and a priority value (integer) of 1 translates to '/name=example /priority=1'. This can be used to send data structures through the command line. </summary>
<param name="valueToConvert">Value to create key/value arguments from.</param>
<returns>Space-delimited key/value arguments.</returns></documentation>
            <parameter name="valueToConvert" typeId="T:System.Object" valueType="false" />
          </method>
        </class>
        <class name="DirectoryInfoConverter" displayName="DirectoryInfoConverter" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter" access="Public">
          <documentation><summary> Converter that can convert from a string to a DirectoryInfo. </summary></documentation>
          <baseType name="TypeConverter" id="T:System.ComponentModel.TypeConverter" displayName="TypeConverter" namespace="System.ComponentModel" assembly="System" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter" /> class.</summary>
            </documentation>
          </constructor>
          <method name="ConvertFrom" displayName="ConvertFrom" id="M:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" access="Public" contract="Override" valueType="false" overload="1">
            <returnType type="System.Object" id="T:System.Object" />
            <documentation><summary> Converts from a string to a DirectoryInfo. </summary>
<param name="context">Context.</param>
<param name="culture">Culture.</param>
<param name="value">Value to convert.</param>
<returns>DirectoryInfo, or null if value was null or non-string.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="culture" typeId="T:System.Globalization.CultureInfo" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="CanConvertFrom" displayName="CanConvertFrom" id="M:Microsoft.Test.CommandLineParsing.DirectoryInfoConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)" access="Public" contract="Override" valueType="true" overload="1">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context. </summary>
<param name="context">An ITypeDescriptorContext that provides a format context.</param>
<param name="sourceType">A Type that represents the type you want to convert from.</param>
<returns>True if this converter can perform the conversion; otherwise, False.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="sourceType" typeId="T:System.Type" valueType="false" />
          </method>
        </class>
        <class name="FileInfoConverter" displayName="FileInfoConverter" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.FileInfoConverter" access="Public">
          <documentation><summary> Converter that can convert from a string to a FileInfo. </summary></documentation>
          <baseType name="TypeConverter" id="T:System.ComponentModel.TypeConverter" displayName="TypeConverter" namespace="System.ComponentModel" assembly="System" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.FileInfoConverter.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.FileInfoConverter" /> class.</summary>
            </documentation>
          </constructor>
          <method name="ConvertFrom" displayName="ConvertFrom" id="M:Microsoft.Test.CommandLineParsing.FileInfoConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" access="Public" contract="Override" valueType="false" overload="1">
            <returnType type="System.Object" id="T:System.Object" />
            <documentation><summary> Converts from a string to a FileInfo. </summary>
<param name="context">Context.</param>
<param name="culture">Culture.</param>
<param name="value">Value to convert.</param>
<returns>FileInfo, or null if value was null or non-string.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="culture" typeId="T:System.Globalization.CultureInfo" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="CanConvertFrom" displayName="CanConvertFrom" id="M:Microsoft.Test.CommandLineParsing.FileInfoConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)" access="Public" contract="Override" valueType="true" overload="1">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context. </summary>
<param name="context">An ITypeDescriptorContext that provides a format context.</param>
<param name="sourceType">A Type that represents the type you want to convert from.</param>
<returns>True if this converter can perform the conversion; otherwise, False.</returns></documentation>
            <parameter name="context" typeId="T:System.ComponentModel.ITypeDescriptorContext" valueType="false" />
            <parameter name="sourceType" typeId="T:System.Type" valueType="false" />
          </method>
        </class>
        <class name="RequiredAttribute" displayName="RequiredAttribute" namespace="Microsoft.Test.CommandLineParsing" id="T:Microsoft.Test.CommandLineParsing.RequiredAttribute" access="Public" sealed="true">
          <documentation><summary> Defines whether a property value is required to be specified. </summary></documentation>
          <baseType name="Attribute" id="T:System.Attribute" displayName="Attribute" namespace="System" assembly="mscorlib" />
          <constructor name=".ctor" id="M:Microsoft.Test.CommandLineParsing.RequiredAttribute.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.CommandLineParsing.RequiredAttribute" /> class.</summary><summary /></documentation>
          </constructor>
          <property name="TypeId" id="P:Microsoft.Test.CommandLineParsing.RequiredAttribute.TypeId" access="Public" contract="Virtual" typeId="T:System.Object" valueType="false" declaringType="System.Attribute" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.FaultInjection">
        <class name="BuiltInConditions" displayName="BuiltInConditions" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.BuiltInConditions" access="Public" static="true">
          <documentation><summary> Contains all built-in fault injection conditions. </summary>
<remarks> For more information on how to use the BuiltInConditions class, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. All fault injection conditions implement the <see cref="T:Microsoft.Test.FaultInjection.ICondition" /> interface. </remarks></documentation>
          <property name="TriggerOnEveryCall" id="P:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnEveryCall" access="Public" contract="Static" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="false">
            <documentation><summary> A built-in condition which triggers a fault every time the faulted method is called. </summary></documentation>
          </property>
          <property name="TriggerOnFirstCall" id="P:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnFirstCall" access="Public" contract="Static" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="false">
            <documentation><summary> A built-in condition which triggers a fault the first time the faulted method is called. </summary></documentation>
          </property>
          <property name="NeverTrigger" id="P:Microsoft.Test.FaultInjection.BuiltInConditions.NeverTrigger" access="Public" contract="Static" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="false">
            <documentation><summary> A built-in condition which never triggers a fault. This condition can be used to turn off a fault rule. </summary></documentation>
          </property>
          <method name="TriggerIfCalledBy" displayName="TriggerIfCalledBy" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerIfCalledBy(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault if the faulted method is called by a specified method.</summary>
<param name="caller">A string in the format: System.Console.WriteLine(string), Namespace&lt;T&gt;.OuterClass&lt;E&gt;.InnerClass&lt;F,G&gt;.MethodName&lt;H&gt;(T, E, F, H, List&lt;H&gt;). </param></documentation>
            <parameter name="caller" typeId="T:System.String" valueType="false" />
          </method>
          <method name="TriggerIfStackContains" displayName="TriggerIfStackContains" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerIfStackContains(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault if the current call stack contains a specified method. </summary>
<param name="method">A string in the format: System.Console.WriteLine(string), Namespace&lt;T&gt;.OuterClass&lt;E&gt;.InnerClass&lt;F,G&gt;.MethodName&lt;H&gt;(T, E, F, H, List&lt;H&gt;). </param></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
          </method>
          <method name="TriggerEveryOnNthCall" displayName="TriggerEveryOnNthCall" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerEveryOnNthCall(System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault after every n times the faulted method is called. </summary>
<param name="n">A positive number.</param>
<remarks> A System.Argument exception is thrown if n is not positive. </remarks></documentation>
            <parameter name="n" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="TriggerOnNthCall" displayName="TriggerOnNthCall" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnNthCall(System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault after the first n times the faulted method is called. </summary>
<param name="n">A positive number.</param>
<remarks> A System.Argument exception is thrown if n is not positive. </remarks></documentation>
            <parameter name="n" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="TriggerOnNthCallBy" displayName="TriggerOnNthCallBy" id="M:Microsoft.Test.FaultInjection.BuiltInConditions.TriggerOnNthCallBy(System.Int32,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.ICondition" id="T:Microsoft.Test.FaultInjection.ICondition" />
            <documentation><summary> A built-in condition which triggers a fault after the faulted method is called n times by the specified caller. </summary>
<param name="n">A positive number.</param>
<param name="caller">A string in the format: System.Console.WriteLine(string), Namespace&lt;T&gt;.OuterClass&lt;E&gt;.InnerClass&lt;F,G&gt;.MethodName&lt;H&gt;(T, E, F, H, List&lt;H&gt;). </param></documentation>
            <parameter name="n" typeId="T:System.Int32" valueType="true" />
            <parameter name="caller" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="BuiltInFaults" displayName="BuiltInFaults" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.BuiltInFaults" access="Public" static="true">
          <documentation><summary> Contains all built-in faults. </summary>
<remarks> For more information on how to use the BuiltInFaults class, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. All fault injection faults implement the <see cref="T:Microsoft.Test.FaultInjection.IFault" /> interface. </remarks></documentation>
          <method name="ReturnFault" displayName="ReturnFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ReturnFault" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which returns when triggered. </summary>
<remarks> This method can be called when the faulted method has a void return type; it will return null if triggered in a non-void method. </remarks></documentation>
          </method>
          <method name="ReturnValueFault" displayName="ReturnValueFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ReturnValueFault(System.Object)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which returns the specified object when triggered. </summary>
<param name="returnValue">The object to return. The faulted method will return this object when the fault condition is triggered.</param></documentation>
            <parameter name="returnValue" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="ReturnValueRuntimeFault" displayName="ReturnValueRuntimeFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ReturnValueRuntimeFault(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which returns an object constructed according to the specified expression when triggered. </summary>
<param name="returnValueExpression">A string in the format: (int)3, (double)6.6, (bool)true, ‘Hello World’ which means "Hello World", System.Exception(‘This is a fault’). </param></documentation>
            <parameter name="returnValueExpression" typeId="T:System.String" valueType="false" />
          </method>
          <method name="ThrowExceptionFault" displayName="ThrowExceptionFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ThrowExceptionFault(System.Exception)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which throws the specified exception object when triggered. </summary>
<param name="exceptionValue"> An Exception object constructed by the process that injects the fault. </param>
<remarks> The exception object must be serializable. </remarks></documentation>
            <parameter name="exceptionValue" typeId="T:System.Exception" valueType="false" />
          </method>
          <method name="ThrowExceptionRuntimeFault" displayName="ThrowExceptionRuntimeFault" id="M:Microsoft.Test.FaultInjection.BuiltInFaults.ThrowExceptionRuntimeFault(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.IFault" id="T:Microsoft.Test.FaultInjection.IFault" />
            <documentation><summary> A built-in fault which throws an exception object constructed according to the specified expression when triggered. </summary>
<param name="exceptionExpression">A string in the format: System.Exception(‘This is a fault’), CustomizedNameSpace.CustomizedException(‘Error Message’, (int)3, System.Exception(‘innerException’)). </param></documentation>
            <parameter name="exceptionExpression" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="ComRegistrar" displayName="ComRegistrar" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.ComRegistrar" access="Public" static="true">
          <documentation><summary> Provides facilities for registration and query of the fault injection COM engine. </summary></documentation>
          <field name="Clsid" id="F:Microsoft.Test.FaultInjection.ComRegistrar.Clsid" access="Public" contract="Static" typeId="T:System.String" valueType="false" literal="true" value="{2EB6DCDB-3250-4D7F-AA42-41B1B84113ED}">
            <documentation><summary> CLSID of the fault injection COM engine. </summary></documentation>
          </field>
          <method name="Register" displayName="Register" id="M:Microsoft.Test.FaultInjection.ComRegistrar.Register(System.String)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Registers the fault injection COM engine. </summary>
<param name="enginePathName">Path name of engine file.</param></documentation>
            <parameter name="enginePathName" typeId="T:System.String" valueType="false" />
          </method>
          <method name="Unregister" displayName="Unregister" id="M:Microsoft.Test.FaultInjection.ComRegistrar.Unregister(System.String)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Unregisters the fault injection COM engine. </summary></documentation>
            <parameter name="enginePathName" typeId="T:System.String" valueType="false" />
          </method>
          <method name="SuppressAutoRegister" displayName="SuppressAutoRegister" id="M:Microsoft.Test.FaultInjection.ComRegistrar.SuppressAutoRegister" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Supresses auto-registration behaviour of the fault injection API. </summary></documentation>
          </method>
        </class>
        <class name="CallStack" displayName="CallStack" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.CallStack" access="Public">
          <documentation><summary> Extracts frame information from a StackTrace object. </summary>
<remarks> Calling CallStack[n] (where n is zero-indexed) will return a C#-style method signature for the nth frame. </remarks></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.CallStack.#ctor(System.Diagnostics.StackTrace)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the CallStack class. </summary>
<param name="stackTrace"> A stack trace from which to create the CallStack.</param></documentation>
            <parameter name="stackTrace" typeId="T:System.Diagnostics.StackTrace" valueType="false" />
          </constructor>
          <property name="FrameCount" id="P:Microsoft.Test.FaultInjection.CallStack.FrameCount" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Number of Frames in the CallStack. </summary></documentation>
          </property>
          <property name="Item" id="P:Microsoft.Test.FaultInjection.CallStack.Item(System.Int32)" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> C#-style method signature for the specified frame. </summary>
<param name="index">frame to evaluate</param></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
          </property>
        </class>
        <class name="FaultDispatcher" displayName="FaultDispatcher" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultDispatcher" access="Public" static="true">
          <documentation><summary> Calls the appropriate fault for a given faulted method. </summary>
<remarks> The FaultDispatcher class contains a static method <see cref="M:Microsoft.Test.FaultInjection.FaultDispatcher.Trap(System.Exception@,System.Object@)" />, which is called by the MSIL code, injected in the faulted method, in order to dispatch to the specific fault. </remarks></documentation>
          <method name="Trap" displayName="Trap" id="M:Microsoft.Test.FaultInjection.FaultDispatcher.Trap(System.Exception@,System.Object@)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Injected into the prologue of the target method. </summary>
<param name="exceptionValue">Exception thrown by fault</param>
<param name="returnValue">Value to return from fault</param>
<returns></returns>
<remarks> Trap creates a RuntimeContext for the current call and evaluates the fault condition's Trigger method. If it evaluates to true the fault's Retrieve method is called. </remarks></documentation>
            <parameter name="exceptionValue" typeId="T:System.Exception" valueType="false" direction="out" />
            <parameter name="returnValue" typeId="T:System.Object" valueType="false" direction="out" />
          </method>
        </class>
        <class name="FaultInjectionException" displayName="FaultInjectionException" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultInjectionException" access="Public">
          <documentation><summary> An exception that is thrown when and error in the FaultInjection API occurs. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="Exception" id="T:System.Exception" displayName="Exception" namespace="System" assembly="mscorlib" />
          <implementsClass type="System.Runtime.Serialization.ISerializable" id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" inherited="true" />
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the FaultInjectionException class. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor(System.String)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the FaultInjectionException class using the specified message. </summary></documentation>
            <parameter name="message" typeId="T:System.String" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor(System.String,System.Exception)" access="Public" contract="Normal" overload="3">
            <documentation><summary> Initializes a new instance of the FaultInjectionException class using the specified message and inner exception. </summary></documentation>
            <parameter name="message" typeId="T:System.String" valueType="false" />
            <parameter name="innerException" typeId="T:System.Exception" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultInjectionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" access="Family" contract="Normal" overload="4">
            <documentation><summary> Constructor used for serialization purposes. </summary></documentation>
            <parameter name="info" typeId="T:System.Runtime.Serialization.SerializationInfo" valueType="false" />
            <parameter name="context" typeId="T:System.Runtime.Serialization.StreamingContext" valueType="true" />
          </constructor>
          <property name="Message" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.Message" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="Data" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.Data" access="Public" contract="Virtual" typeId="T:System.Collections.IDictionary" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="InnerException" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.InnerException" access="Public" contract="Final" typeId="T:System.Exception" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="TargetSite" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.TargetSite" access="Public" contract="Final" typeId="T:System.Reflection.MethodBase" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="StackTrace" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.StackTrace" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="false">
            <documentation><summary></summary></documentation>
          </property>
          <property name="HelpLink" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.HelpLink" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="Public">
            <documentation><summary></summary></documentation>
          </property>
          <property name="Source" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.Source" access="Public" contract="Virtual" typeId="T:System.String" valueType="false" declaringType="System.Exception" get="Public" set="Public">
            <documentation><summary></summary></documentation>
          </property>
          <property name="HResult" id="P:Microsoft.Test.FaultInjection.FaultInjectionException.HResult" access="Family" contract="Normal" typeId="T:System.Int32" valueType="true" declaringType="System.Exception" get="Family" set="Family">
            <documentation><summary></summary></documentation>
          </property>
          <event name="SerializeObjectState" id="E:Microsoft.Test.FaultInjection.FaultInjectionException.SerializeObjectState" access="Family" contract="Normal" typeId="T:System.EventHandler`1" valueType="false" declaringType="System.Exception" multicast="true">
            <documentation><summary></summary></documentation>
          </event>
        </class>
        <class name="FaultRule" displayName="FaultRule" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultRule" access="Public" sealed="true">
          <documentation><summary> Defines which method to fault, under what conditions the fault will occur, and how the method will fail. See also the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. </summary>
<remarks> There can only be one fault rule per target method. </remarks>
<example>Creates a new FaultSession with several FaultRules and launches the application <code>            string sampleAppPath = "SampleApp.exe";
     
            FaultRule[] ruleArray = new FaultRule[]
            {     
                // Instance method
                new FaultRule(
                    "SampleApp.TargetType.TargetMethod(string, string)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnValueFault("")),
     
                // Constructor
                new FaultRule(
                    "SampleApp.TargetType.TargetType(string, int)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException())),
     
                // Static method
                new FaultRule(
                    "static SampleApp.TargetType.StaticTargetMethod()",
                    BuiltInConditions.TriggerOnEveryNthCall(2),
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException())),
     
                // Generic method
                new FaultRule(
                    "SampleApp.TargetType.GenericTargetMethod&lt;T&gt;(string)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnFault);
     
                // Property 
                new FaultRule(
                    "SampleApp.TargetType.get_TargetProperty()",
                    BuiltInConditions.TriggerOnEveryNthCall(3),
                    BuiltInFaults.ReturnFault);
     
                // Operator overload
                new FaultRule(
                    "SampleApp.TargetType.op_Increment(int, int)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException()))
            }     
     
            FaultSession session = new FaultSession(ruleArray);
            ProcessStartInfo psi = session.GetProcessStartInfo(sampleAppPath);
            Process.Start(psi);
</code></example></documentation>
          <attribute name="System.SerializableAttribute" />
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultRule.#ctor(System.String)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of FaultRule class with the specified method. </summary>
<param name="method">The signature of the method where the fault should be injected.</param></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultRule.#ctor(System.String,Microsoft.Test.FaultInjection.ICondition,Microsoft.Test.FaultInjection.IFault)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of FaultRule class with the specified method, condition and fault. </summary>
<param name="method">The signature of the method where the fault should be injected.</param>
<param name="condition">The condition that defines when the fault should occur.</param>
<param name="fault">The fault to be injected.</param></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
            <parameter name="condition" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" />
            <parameter name="fault" typeId="T:Microsoft.Test.FaultInjection.IFault" valueType="false" />
          </constructor>
          <property name="MethodSignature" id="P:Microsoft.Test.FaultInjection.FaultRule.MethodSignature" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The signature of the method where the fault should be injected. </summary></documentation>
          </property>
          <property name="Condition" id="P:Microsoft.Test.FaultInjection.FaultRule.Condition" access="Public" contract="Normal" typeId="T:Microsoft.Test.FaultInjection.ICondition" valueType="false" get="Public" set="Public">
            <documentation><summary> The condition that defines when the fault should occur. </summary></documentation>
          </property>
          <property name="Fault" id="P:Microsoft.Test.FaultInjection.FaultRule.Fault" access="Public" contract="Normal" typeId="T:Microsoft.Test.FaultInjection.IFault" valueType="false" get="Public" set="Public">
            <documentation><summary> The fault to be injected. </summary></documentation>
          </property>
        </class>
        <class name="FaultSession" displayName="FaultSession" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.FaultSession" access="Public" sealed="true">
          <documentation><summary> Maintains information needed for injecting faults into a test application. For general information on fault injection see <a href="http://en.wikipedia.org/wiki/Fault_injection">this page</a>. </summary>
<remarks> Users can launch the faulted application by calling GetProcessStartInfo(string) and calling Process.Start() with the returned ProcessStartInfo. </remarks>
<example>The following example creates a new FaultSession with a single FaultRule and launches the application under test. <code>            string sampleAppPath = "SampleApp.exe";

            FaultRule rule = new FaultRule(
                "SampleApp.TargetMethod(string, string)",
                BuiltInConditions.TriggerOnEveryCall,
                BuiltInFaults.ReturnValueFault(""));
     
            FaultSession session = new FaultSession(rule);
            ProcessStartInfo psi = session.GetProcessStartInfo(sampleAppPath);
            Process.Start(psi);
</code></example>
<example>The following example creates a new FaultSession with multiple FaultRules and launches the application under test. <code>            string sampleAppPath = "SampleApp.exe";
     
            FaultRule[] ruleArray = new FaultRule[]
            {
                new FaultRule(
                    "SampleApp.TargetMethod(string, string)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnValueFault("")),
 
                new FaultRule(
                    "SampleApp.TargetMethod2(string, int)",
                    BuiltInConditions.TriggerOnEveryCall,
                    BuiltInFaults.ReturnValueFault(Int32.MaxValue)),
     
                new FaultRule(
                    "static SampleApp.StaticTargetMethod()",
                    BuiltInConditions.TriggerOnEveryNthCall(2),
                    BuiltInFaults.ThrowExceptionFault(new InvalidOperationException()))
            }     
     
            FaultSession session = new FaultSession(ruleArray);
            ProcessStartInfo psi = session.GetProcessStartInfo(sampleAppPath);
            Process.Start(psi);
</code></example>
<example>The following example demonstrates how to modify a fault rule in an existing session. <code>            ...
            string sampleAppPath = "SampleApp.exe";     
            FaultSession session = new FaultSession(rule);
            ...
      
            FaultRule foundRule = session.FindRule("SampleApp.TargetMethod(string, string)");
            if( foundRule != null)
            {
                foundRule.Condition = BuiltInConditions.TriggerOnEveryNthCall(4);
                session.NotifyRuleChanges();
            }
            ...
     
</code></example></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.FaultSession.#ctor(Microsoft.Test.FaultInjection.FaultRule[])" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the FaultSession class with the specified FaultRule objects. </summary>
<param name="rules">FaultRule objects defining how to fault the test application.</param>
<exception cref="T:Microsoft.Test.FaultInjection.FaultInjectionException">Two FaultRule objects corresponding to the same method.</exception></documentation>
            <parameter name="rules" typeId="T:Microsoft.Test.FaultInjection.FaultRule" valueType="false" isParamArray="true" />
          </constructor>
          <property name="LogDirectory" id="P:Microsoft.Test.FaultInjection.FaultSession.LogDirectory" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> Directory for all log files written by applications launched by this session. </summary></documentation>
          </property>
          <method name="FindRule" displayName="FindRule" id="M:Microsoft.Test.FaultInjection.FaultSession.FindRule(System.String)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.FaultInjection.FaultRule" id="T:Microsoft.Test.FaultInjection.FaultRule" />
            <documentation><summary> Finds the rule corresponding to a specified method. </summary>
<param name="method">The signature of the method.</param>
<returns> The FaultRule instance corresponding to the method specified. Returns null if no such rule exists. </returns></documentation>
            <parameter name="method" typeId="T:System.String" valueType="false" />
          </method>
          <method name="NotifyRuleChanges" displayName="NotifyRuleChanges" id="M:Microsoft.Test.FaultInjection.FaultSession.NotifyRuleChanges" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Notifies all test applications that fault rules have changed. </summary></documentation>
          </method>
          <method name="GetProcessStartInfo" displayName="GetProcessStartInfo" id="M:Microsoft.Test.FaultInjection.FaultSession.GetProcessStartInfo(System.String)" access="Public" contract="Normal" valueType="false">
            <returnType type="System.Diagnostics.ProcessStartInfo" id="T:System.Diagnostics.ProcessStartInfo" />
            <documentation><summary> Creates a ProcessStartInfo with the appropriate environment variables set for fault injection. </summary>
<param name="file">The path to the executable to launch.</param>
<returns>The ProcessStartInfo object for the executable.</returns></documentation>
            <parameter name="file" typeId="T:System.String" valueType="false" />
          </method>
          <method name="SetGlobalFault" displayName="SetGlobalFault" id="M:Microsoft.Test.FaultInjection.FaultSession.SetGlobalFault(Microsoft.Test.FaultInjection.FaultSession)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Sets a global fault session. This enables fault injection for all .NET processes launched after the creation of the global session. This functionality is often useful when testing server .NET applications, where one application typically consists of and launches many processes. </summary></documentation>
            <parameter name="session" typeId="T:Microsoft.Test.FaultInjection.FaultSession" valueType="false" />
          </method>
          <method name="ClearGlobalFault" displayName="ClearGlobalFault" id="M:Microsoft.Test.FaultInjection.FaultSession.ClearGlobalFault" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Destroys the global fault session. </summary></documentation>
          </method>
        </class>
        <class name="RuntimeContext" displayName="RuntimeContext" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.RuntimeContext" access="Public">
          <documentation><summary> Stores information about a faulted method. </summary></documentation>
          <implementsClass type="Microsoft.Test.FaultInjection.IRuntimeContext" id="T:Microsoft.Test.FaultInjection.IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" />
          <constructor name=".ctor" id="M:Microsoft.Test.FaultInjection.RuntimeContext.#ctor" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the RuntimeContext class. </summary></documentation>
          </constructor>
          <property name="CalledTimes" id="P:Microsoft.Test.FaultInjection.RuntimeContext.CalledTimes" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" get="Public" set="Public">
            <documentation><summary> The number of times the method has been called. </summary></documentation>
            <implements name="CalledTimes" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CalledTimes" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
          <property name="CallStackTrace" id="P:Microsoft.Test.FaultInjection.RuntimeContext.CallStackTrace" access="Public" contract="Final" typeId="T:System.Diagnostics.StackTrace" valueType="false" get="Public" set="Public">
            <documentation><summary> The method's stack trace. </summary></documentation>
            <implements name="CallStackTrace" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStackTrace" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
          <property name="CallStack" id="P:Microsoft.Test.FaultInjection.RuntimeContext.CallStack" access="Public" contract="Final" typeId="T:Microsoft.Test.FaultInjection.CallStack" valueType="false" get="Public" set="Public">
            <documentation><summary> An array of C#-style method signatures for each method on the call stack. </summary></documentation>
            <implements name="CallStack" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStack" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
          <property name="Caller" id="P:Microsoft.Test.FaultInjection.RuntimeContext.Caller" access="Public" contract="Final" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The C#-style method signature of the caller of the faulted method. </summary></documentation>
            <implements name="Caller" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.Caller" interface="IRuntimeContext" assembly="TestApiCore" interfaceId="T:Microsoft.Test.FaultInjection.IRuntimeContext" declaringType="Microsoft.Test.FaultInjection.IRuntimeContext" />
          </property>
        </class>
        <interface name="ICondition" displayName="ICondition" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.ICondition" access="Public">
          <documentation><summary> Defines the contract for specifying when a fault will be triggered on a method. </summary>
<remarks> If the fault condition is not triggered, the faulted method will execute its original code. For more information on how to use a condition, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. </remarks></documentation>
          <method name="Trigger" displayName="Trigger" id="M:Microsoft.Test.FaultInjection.ICondition.Trigger(Microsoft.Test.FaultInjection.IRuntimeContext)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Determines whether a fault should be triggered. </summary>
<param name="context">The runtime context information for this call and the faulted method.</param>
<returns>Returns true if a fault should be triggered, otherwise returns false.</returns></documentation>
            <parameter name="context" typeId="T:Microsoft.Test.FaultInjection.IRuntimeContext" valueType="false" />
          </method>
        </interface>
        <interface name="IFault" displayName="IFault" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.IFault" access="Public">
          <documentation><summary> Defines the contract for a fault. </summary>
<remarks> For more information on how to use a fault, see the <see cref="T:Microsoft.Test.FaultInjection.FaultSession" /> class. </remarks>
<example>Define a custom fault <code>            //Returns a random int when triggered
            public class ReturnRandomIntFault : IFault
            {
                private Random rand;

                public ReturnRandomIntFault(int seed)
                {
                    rand = new Random(seed);
                }

                public void Retrieve(IRuntimeContext context, out Exception exceptionValue, out object returnValue)
                {
                    exceptionValue = null;
                    returnValue = rand.Next();
                }
            }
</code></example></documentation>
          <method name="Retrieve" displayName="Retrieve" id="M:Microsoft.Test.FaultInjection.IFault.Retrieve(Microsoft.Test.FaultInjection.IRuntimeContext,System.Exception@,System.Object@)" access="Public" contract="Abstract" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Defines the behavior of the fault when triggered. </summary>
<param name="context">The runtime context information for this call.</param>
<param name="exceptionValue">An output paramter for the exception to be thrown by the faulted method.</param>
<param name="returnValue">An output paramter for the value to be returned by the faulted method.</param>
<remarks> Parameter <paramref name="returnValue" /> is only checked when <paramref name="exceptionValue" /> returns null. </remarks></documentation>
            <parameter name="context" typeId="T:Microsoft.Test.FaultInjection.IRuntimeContext" valueType="false" />
            <parameter name="exceptionValue" typeId="T:System.Exception" valueType="false" direction="out" />
            <parameter name="returnValue" typeId="T:System.Object" valueType="false" direction="out" />
          </method>
        </interface>
        <interface name="IRuntimeContext" displayName="IRuntimeContext" namespace="Microsoft.Test.FaultInjection" id="T:Microsoft.Test.FaultInjection.IRuntimeContext" access="Public">
          <documentation><summary> Defines the contract for information provided by the faulted method. </summary></documentation>
          <implementedBy id="T:Microsoft.Test.FaultInjection.RuntimeContext" displayName="RuntimeContext" namespace="Microsoft.Test.FaultInjection" assembly="TestApiCore" />
          <property name="CalledTimes" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CalledTimes" access="Public" contract="Abstract" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> The number of times the method is called. </summary></documentation>
          </property>
          <property name="CallStackTrace" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStackTrace" access="Public" contract="Abstract" typeId="T:System.Diagnostics.StackTrace" valueType="false" get="Public" set="false">
            <documentation><summary> The method's stack trace. </summary></documentation>
          </property>
          <property name="CallStack" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.CallStack" access="Public" contract="Abstract" typeId="T:Microsoft.Test.FaultInjection.CallStack" valueType="false" get="Public" set="false">
            <documentation><summary> An array of C#-style method signatures for each method on the call stack. </summary></documentation>
          </property>
          <property name="Caller" id="P:Microsoft.Test.FaultInjection.IRuntimeContext.Caller" access="Public" contract="Abstract" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> The C#-style method signature of the caller of the faulted method. </summary></documentation>
          </property>
        </interface>
      </namespace>
      <namespace name="Microsoft.Test.Text">
        <class name="StringFactory" displayName="StringFactory" namespace="Microsoft.Test.Text" id="T:Microsoft.Test.Text.StringFactory" access="Public" static="true">
          <documentation><summary> Provides factory methods for generation of text, interesting from the testing point of view. </summary>
<example>The following example demonstrates how to create a random string with 10 Unicode code points. A Unicode code point may correspond to 1 or 2 characters. For more information see <see cref="T:Microsoft.Test.Text.StringProperties" />: <code> StringProperties sp = new StringProperties();
 sp.MinNumberOfCodePoints = sp.MaxNumberOfCodePoints = 10;

 string s = StringFactory.GenerateRandomString(sp, 1234);
 </code></example></documentation>
          <method name="GenerateRandomString" displayName="GenerateRandomString" id="M:Microsoft.Test.Text.StringFactory.GenerateRandomString(Microsoft.Test.Text.StringProperties,System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="System.String" id="T:System.String" />
            <documentation><summary> Returns a string, conforming to the <see cref="T:Microsoft.Test.Text.StringProperties" /> provided. </summary>
<param name="stringProperties">The properties of the strings to be generated by the factory.</param>
<param name="seed">The random number generator seed.</param>
<returns>A string, conforming to the previously specified properties.</returns></documentation>
            <parameter name="stringProperties" typeId="T:Microsoft.Test.Text.StringProperties" valueType="false" />
            <parameter name="seed" typeId="T:System.Int32" valueType="true" />
          </method>
        </class>
        <class name="StringProperties" displayName="StringProperties" namespace="Microsoft.Test.Text" id="T:Microsoft.Test.Text.StringProperties" access="Public">
          <documentation><summary> Defines the desired properties of a character string. For more information on character strings, see <a href="http://msdn.microsoft.com/en-us/library/dd317711(VS.85).aspx">this article</a>. </summary>
<remarks> Note that this class is used as <i>"a filter"</i> when generating character strings with <see cref="T:Microsoft.Test.Text.StringFactory" />. Upon instantiation, all properties except CultureInfo of a <see cref="T:Microsoft.Test.Text.StringProperties" nolink="true" /> object (which are all <a href="http://msdn.microsoft.com/en-us/library/system.nullable.aspx">Nullables</a>) have null values, which means that the object does not impose any filtering limitations on the generated strings. <para> Setting properties to non-null values means that the value of the property should be taken into account by <see cref="T:Microsoft.Test.Text.StringFactory" nolink="true" /> during string generation. For example, setting <see cref="P:Microsoft.Test.Text.StringProperties.MaxNumberOfCodePoints" /> to 10 means <i>"generate strings with up to 10 code points"</i>.</para></remarks>
<example>The following example demonstrates how to create a random string with 10 Unicode points from the Greek character set: <code> StringProperties sp = new StringProperties();
 sp.MinNumberOfCodePoints = sp.MaxNumberOfCodePoints = 10;
 sp.UnicodeRange = new UnicodeRange(UnicodeChart.Greek);

 string s = StringFactory.GenerateRandomString(sp, 1234);
 </code></example></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.Text.StringProperties.#ctor" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the class. </summary></documentation>
          </constructor>
          <property name="UnicodeRange" id="P:Microsoft.Test.Text.StringProperties.UnicodeRange" access="Public" contract="Normal" typeId="T:Microsoft.Test.Text.UnicodeRange" valueType="false" get="Public" set="Public">
            <documentation><summary> Determines whether the string belongs to a particular <see cref="P:Microsoft.Test.Text.StringProperties.UnicodeRange" nolink="true" />. </summary></documentation>
          </property>
          <property name="HasNumbers" id="P:Microsoft.Test.Text.StringProperties.HasNumbers" access="Public" contract="Normal" typeId="T:System.Boolean" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines whether the string contains formatted numbers. </summary></documentation>
          </property>
          <property name="IsBidirectional" id="P:Microsoft.Test.Text.StringProperties.IsBidirectional" access="Public" contract="Normal" typeId="T:System.Boolean" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines whether the string is <a href="http://en.wikipedia.org/wiki/Bi-directional_text">bi-directional</a>. </summary></documentation>
          </property>
          <property name="NormalizationForm" id="P:Microsoft.Test.Text.StringProperties.NormalizationForm" access="Public" contract="Normal" typeId="T:System.Text.NormalizationForm" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the type of normalization to perform on the string. For more information, see <a href="http://www.unicode.org/reports/tr15">this article</a>. </summary></documentation>
          </property>
          <property name="MinNumberOfCombiningMarks" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfCombiningMarks" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the minimum number of combining marks in the string. <a href="http://www.unicode.org/reports/tr15/">Combining marks</a> (and combining characters in general) are characters that are intended to modify other characters (e.g. accents, etc.) </summary></documentation>
          </property>
          <property name="MinNumberOfCodePoints" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfCodePoints" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the minimum number of code points (characters) in the string. </summary></documentation>
          </property>
          <property name="MaxNumberOfCodePoints" id="P:Microsoft.Test.Text.StringProperties.MaxNumberOfCodePoints" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the maximum number of code points (characters) in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfEndUserDefinedCodePoints" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfEndUserDefinedCodePoints" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the minimum number of <a href="http://msdn.microsoft.com/en-us/library/dd317802(VS.85).aspx">end-user-defined characters</a> (EUDC) in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfLineBreaks" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfLineBreaks" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the minimum number of line breaks in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfSurrogatePairs" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfSurrogatePairs" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the minimum number of <a href="http://en.wikipedia.org/wiki/Surrogate_pair">surrogate pairs</a> in the string. </summary></documentation>
          </property>
          <property name="MinNumberOfTextSegmentationCodePoints" id="P:Microsoft.Test.Text.StringProperties.MinNumberOfTextSegmentationCodePoints" access="Public" contract="Normal" typeId="T:System.Int32" nullable="true" valueType="true" get="Public" set="Public">
            <documentation><summary> Determines the minimum number of <a href="http://en.wikipedia.org/wiki/Text_segmentation">text segmentation code points</a> in the string. </summary></documentation>
          </property>
        </class>
        <class name="UnicodeRange" displayName="UnicodeRange" namespace="Microsoft.Test.Text" id="T:Microsoft.Test.Text.UnicodeRange" access="Public">
          <documentation><summary> Represents a Unicode range.<para /> A UnicodeRange instance can be created by either providing start and end of the desired Unicode range or by providing a <see cref="T:Microsoft.Test.Text.UnicodeChart" />. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.Text.UnicodeRange.#ctor(Microsoft.Test.Text.UnicodeChart)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Create a UnicodeRange instance, using the provided UnicodeChart Enum type. </summary>
<param name="chart">Group name of scripts, symbols or punctuations (e.g. "European Scripts", "Punctuation", etc.)</param></documentation>
            <parameter name="chart" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.Text.UnicodeRange.#ctor(System.Int32,System.Int32)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Create a UnicodeRange instance, using the provided start and end of the Unicode range </summary>
<param name="start">Start of the Unicode range (e.g. 0x0000, etc.)</param>
<param name="end">End of the Unicode range (e.g. 0xFFFF, etc.)</param></documentation>
            <parameter name="start" typeId="T:System.Int32" valueType="true" />
            <parameter name="end" typeId="T:System.Int32" valueType="true" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.Text.UnicodeRange.#ctor(Microsoft.Test.Text.UnicodeRange)" access="Public" contract="Normal" overload="3">
            <documentation><summary> Copy constructor </summary>
<param name="range">A UnicodeRange object to be copied</param></documentation>
            <parameter name="range" typeId="T:Microsoft.Test.Text.UnicodeRange" valueType="false" />
          </constructor>
          <property name="StartOfUnicodeRange" id="P:Microsoft.Test.Text.UnicodeRange.StartOfUnicodeRange" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Get the start of the Unicode range </summary></documentation>
          </property>
          <property name="EndOfUnicodeRange" id="P:Microsoft.Test.Text.UnicodeRange.EndOfUnicodeRange" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Get the end of the Unicode range </summary></documentation>
          </property>
        </class>
        <enumeration name="UnicodeChart" id="T:Microsoft.Test.Text.UnicodeChart" displayName="UnicodeChart" namespace="Microsoft.Test.Text" access="Public">
          <documentation><summary> Specifies a <a href="http://unicode.org/charts">Unicode character code chart</a>. </summary>
<remarks> The Unicode standard defines a number of different character subsets, which are called <b>Unicode character code charts</b> (or <b>Unicode charts</b> for short). These charts are available on <a href="http://unicode.org/charts">http://unicode.org/charts</a>. The charts divide and categorize all symbols available in the Unicode range (0x0000 - 0x10FFFF) according to their common characteristics. </remarks></documentation>
          <field name="AdditionalArrows" id="F:Microsoft.Test.Text.UnicodeChart.AdditionalArrows" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="0">
            <documentation><summary> Additional Arrows Chart </summary></documentation>
          </field>
          <field name="AdditionalShapes" id="F:Microsoft.Test.Text.UnicodeChart.AdditionalShapes" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="1">
            <documentation><summary> Additional Shapes Chart </summary></documentation>
          </field>
          <field name="AdditionalSquaredSymbols" id="F:Microsoft.Test.Text.UnicodeChart.AdditionalSquaredSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="2">
            <documentation><summary> Additional Squared Symbols Chart </summary></documentation>
          </field>
          <field name="AegeanNumbers" id="F:Microsoft.Test.Text.UnicodeChart.AegeanNumbers" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="3">
            <documentation><summary> Aegean Numbers Chart </summary></documentation>
          </field>
          <field name="AlphabeticPresentationForms" id="F:Microsoft.Test.Text.UnicodeChart.AlphabeticPresentationForms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="4">
            <documentation><summary> Alphabetic Presentation Forms Chart </summary></documentation>
          </field>
          <field name="AncientGreekMusicalNotation" id="F:Microsoft.Test.Text.UnicodeChart.AncientGreekMusicalNotation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="5">
            <documentation><summary> Ancient Greek Musical Notation Chart </summary></documentation>
          </field>
          <field name="AncientGreekNumbers" id="F:Microsoft.Test.Text.UnicodeChart.AncientGreekNumbers" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="6">
            <documentation><summary> Ancient Greek Numbers Chart </summary></documentation>
          </field>
          <field name="AncientSymbols" id="F:Microsoft.Test.Text.UnicodeChart.AncientSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="7">
            <documentation><summary> Ancient Symbols Chart </summary></documentation>
          </field>
          <field name="AplSymbols" id="F:Microsoft.Test.Text.UnicodeChart.AplSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="8">
            <documentation><summary> APL symbols Chart </summary></documentation>
          </field>
          <field name="Arabic" id="F:Microsoft.Test.Text.UnicodeChart.Arabic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="9">
            <documentation><summary> Arabic Chart </summary></documentation>
          </field>
          <field name="ArabicPresentationFormsA" id="F:Microsoft.Test.Text.UnicodeChart.ArabicPresentationFormsA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="10">
            <documentation><summary> Arabic Presentation Forms-A Chart </summary></documentation>
          </field>
          <field name="ArabicPresentationFormsB" id="F:Microsoft.Test.Text.UnicodeChart.ArabicPresentationFormsB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="11">
            <documentation><summary> Arabic Presentation Forms-B Chart </summary></documentation>
          </field>
          <field name="ArabicSupplement" id="F:Microsoft.Test.Text.UnicodeChart.ArabicSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="12">
            <documentation><summary> Arabic Supplement Chart </summary></documentation>
          </field>
          <field name="AramaicImperial" id="F:Microsoft.Test.Text.UnicodeChart.AramaicImperial" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="13">
            <documentation><summary> Aramaic Imperial Chart </summary></documentation>
          </field>
          <field name="Armenian" id="F:Microsoft.Test.Text.UnicodeChart.Armenian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="14">
            <documentation><summary> Armenian Chart </summary></documentation>
          </field>
          <field name="ArmenianLigatures" id="F:Microsoft.Test.Text.UnicodeChart.ArmenianLigatures" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="15">
            <documentation><summary> Armenian Ligatures Chart </summary></documentation>
          </field>
          <field name="Arrows" id="F:Microsoft.Test.Text.UnicodeChart.Arrows" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="16">
            <documentation><summary> Arrows Chart </summary></documentation>
          </field>
          <field name="AsciiCharacters" id="F:Microsoft.Test.Text.UnicodeChart.AsciiCharacters" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="17">
            <documentation><summary> ASCII Characters Chart </summary></documentation>
          </field>
          <field name="AsciiDigits" id="F:Microsoft.Test.Text.UnicodeChart.AsciiDigits" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="18">
            <documentation><summary> ASCII Digits Chart </summary></documentation>
          </field>
          <field name="AsciiPunctuation" id="F:Microsoft.Test.Text.UnicodeChart.AsciiPunctuation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="19">
            <documentation><summary> ASCII Punctuation Chart </summary></documentation>
          </field>
          <field name="AtEndOf" id="F:Microsoft.Test.Text.UnicodeChart.AtEndOf" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="20">
            <documentation><summary> Same as BMP Chart </summary></documentation>
          </field>
          <field name="Avestan" id="F:Microsoft.Test.Text.UnicodeChart.Avestan" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="21">
            <documentation><summary> Avestan Chart </summary></documentation>
          </field>
          <field name="Balinese" id="F:Microsoft.Test.Text.UnicodeChart.Balinese" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="22">
            <documentation><summary> Balinese Chart </summary></documentation>
          </field>
          <field name="Bamum" id="F:Microsoft.Test.Text.UnicodeChart.Bamum" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="23">
            <documentation><summary> Bamum Chart </summary></documentation>
          </field>
          <field name="BasicOperatorsDivisionMultiplication" id="F:Microsoft.Test.Text.UnicodeChart.BasicOperatorsDivisionMultiplication" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="24">
            <documentation><summary> Basic operators Division Multiplication Chart </summary></documentation>
          </field>
          <field name="BasicOperatorsPlusFactorial" id="F:Microsoft.Test.Text.UnicodeChart.BasicOperatorsPlusFactorial" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="25">
            <documentation><summary> Basic operators Plus Factorial Chart </summary></documentation>
          </field>
          <field name="Bengali" id="F:Microsoft.Test.Text.UnicodeChart.Bengali" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="26">
            <documentation><summary> Bengali Chart </summary></documentation>
          </field>
          <field name="BlockElements" id="F:Microsoft.Test.Text.UnicodeChart.BlockElements" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="27">
            <documentation><summary> Block Elements Chart </summary></documentation>
          </field>
          <field name="Bmp" id="F:Microsoft.Test.Text.UnicodeChart.Bmp" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="28">
            <documentation><summary> BMP Chart </summary></documentation>
          </field>
          <field name="Bopomofo" id="F:Microsoft.Test.Text.UnicodeChart.Bopomofo" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="29">
            <documentation><summary> Bopomofo Chart </summary></documentation>
          </field>
          <field name="BopomofoExtended" id="F:Microsoft.Test.Text.UnicodeChart.BopomofoExtended" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="30">
            <documentation><summary> Bopomofo Extended Chart </summary></documentation>
          </field>
          <field name="BoxDrawing" id="F:Microsoft.Test.Text.UnicodeChart.BoxDrawing" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="31">
            <documentation><summary> Box Drawing Chart </summary></documentation>
          </field>
          <field name="BraillePatterns" id="F:Microsoft.Test.Text.UnicodeChart.BraillePatterns" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="32">
            <documentation><summary> Braille Patterns Chart </summary></documentation>
          </field>
          <field name="Buginese" id="F:Microsoft.Test.Text.UnicodeChart.Buginese" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="33">
            <documentation><summary> Buginese Chart </summary></documentation>
          </field>
          <field name="Buhid" id="F:Microsoft.Test.Text.UnicodeChart.Buhid" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="34">
            <documentation><summary> Buhid Chart </summary></documentation>
          </field>
          <field name="ByzantineMusicalSymbols" id="F:Microsoft.Test.Text.UnicodeChart.ByzantineMusicalSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="35">
            <documentation><summary> Byzantine Musical Symbols Chart </summary></documentation>
          </field>
          <field name="C0" id="F:Microsoft.Test.Text.UnicodeChart.C0" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="36">
            <documentation><summary> C0 Chart </summary></documentation>
          </field>
          <field name="C1" id="F:Microsoft.Test.Text.UnicodeChart.C1" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="37">
            <documentation><summary> C1 Chart </summary></documentation>
          </field>
          <field name="CardSuits" id="F:Microsoft.Test.Text.UnicodeChart.CardSuits" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="38">
            <documentation><summary> Card suits Chart </summary></documentation>
          </field>
          <field name="Carian" id="F:Microsoft.Test.Text.UnicodeChart.Carian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="39">
            <documentation><summary> Carian Chart </summary></documentation>
          </field>
          <field name="Cham" id="F:Microsoft.Test.Text.UnicodeChart.Cham" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="40">
            <documentation><summary> Cham Chart </summary></documentation>
          </field>
          <field name="Cherokee" id="F:Microsoft.Test.Text.UnicodeChart.Cherokee" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="41">
            <documentation><summary> Cherokee Chart </summary></documentation>
          </field>
          <field name="ChessCheckers" id="F:Microsoft.Test.Text.UnicodeChart.ChessCheckers" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="42">
            <documentation><summary> Chess/Checkers Chart </summary></documentation>
          </field>
          <field name="CjkCompatibility" id="F:Microsoft.Test.Text.UnicodeChart.CjkCompatibility" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="43">
            <documentation><summary> CJK Compatibility Chart </summary></documentation>
          </field>
          <field name="CjkCompatibilityForms" id="F:Microsoft.Test.Text.UnicodeChart.CjkCompatibilityForms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="44">
            <documentation><summary> CJK Compatibility Forms Chart </summary></documentation>
          </field>
          <field name="CjkCompatibilityIdeographs" id="F:Microsoft.Test.Text.UnicodeChart.CjkCompatibilityIdeographs" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="45">
            <documentation><summary> CJK Compatibility Ideographs Chart </summary></documentation>
          </field>
          <field name="CjkCompatibilityIdeographsSupplement" id="F:Microsoft.Test.Text.UnicodeChart.CjkCompatibilityIdeographsSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="46">
            <documentation><summary> CJK Compatibility Ideographs Supplement Chart </summary></documentation>
          </field>
          <field name="CjkExtensionA" id="F:Microsoft.Test.Text.UnicodeChart.CjkExtensionA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="47">
            <documentation><summary> CJK ExtensionA Chart </summary></documentation>
          </field>
          <field name="CjkExtensionB" id="F:Microsoft.Test.Text.UnicodeChart.CjkExtensionB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="48">
            <documentation><summary> CJK Extension-B Chart </summary></documentation>
          </field>
          <field name="CjkExtensionC" id="F:Microsoft.Test.Text.UnicodeChart.CjkExtensionC" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="49">
            <documentation><summary> CJK Extension-C Chart </summary></documentation>
          </field>
          <field name="CjkKangXiRadicals" id="F:Microsoft.Test.Text.UnicodeChart.CjkKangXiRadicals" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="50">
            <documentation><summary> CJK Radicals / KangXi Chart </summary></documentation>
          </field>
          <field name="CjkRadicalsSupplement" id="F:Microsoft.Test.Text.UnicodeChart.CjkRadicalsSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="51">
            <documentation><summary> CJK Radicals Supplement </summary></documentation>
          </field>
          <field name="CjkStrokes" id="F:Microsoft.Test.Text.UnicodeChart.CjkStrokes" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="52">
            <documentation><summary> CJK Strokes Chart </summary></documentation>
          </field>
          <field name="CjkSymbolsAndPunctuation" id="F:Microsoft.Test.Text.UnicodeChart.CjkSymbolsAndPunctuation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="53">
            <documentation><summary> CJK Symbols and Punctuation Chart </summary></documentation>
          </field>
          <field name="CjkUnifiedIdeographs" id="F:Microsoft.Test.Text.UnicodeChart.CjkUnifiedIdeographs" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="54">
            <documentation><summary> CJK Unified Ideographs Chart </summary></documentation>
          </field>
          <field name="CombiningDiacriticalMarks" id="F:Microsoft.Test.Text.UnicodeChart.CombiningDiacriticalMarks" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="55">
            <documentation><summary> Combining Diacritical Marks Chart </summary></documentation>
          </field>
          <field name="CombiningDiacriticalMarksForSymbols" id="F:Microsoft.Test.Text.UnicodeChart.CombiningDiacriticalMarksForSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="56">
            <documentation><summary> Combining Diacritical Marks for Symbols Chart </summary></documentation>
          </field>
          <field name="CombiningDiacriticalMarksSupplement" id="F:Microsoft.Test.Text.UnicodeChart.CombiningDiacriticalMarksSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="57">
            <documentation><summary> Combining Diacritical Marks Supplement Chart </summary></documentation>
          </field>
          <field name="CombiningHalfMarks" id="F:Microsoft.Test.Text.UnicodeChart.CombiningHalfMarks" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="58">
            <documentation><summary> Combining HalfMarks Chart </summary></documentation>
          </field>
          <field name="CommonIndicNumberForms" id="F:Microsoft.Test.Text.UnicodeChart.CommonIndicNumberForms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="59">
            <documentation><summary> Common Indic Number Forms Chart </summary></documentation>
          </field>
          <field name="ControlPictures" id="F:Microsoft.Test.Text.UnicodeChart.ControlPictures" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="60">
            <documentation><summary> Control Pictures Chart </summary></documentation>
          </field>
          <field name="Controls" id="F:Microsoft.Test.Text.UnicodeChart.Controls" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="61">
            <documentation><summary> C0 and C1 Chart </summary></documentation>
          </field>
          <field name="Coptic" id="F:Microsoft.Test.Text.UnicodeChart.Coptic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="62">
            <documentation><summary> Coptic Chart </summary></documentation>
          </field>
          <field name="CopticInGreekBlock" id="F:Microsoft.Test.Text.UnicodeChart.CopticInGreekBlock" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="63">
            <documentation><summary> Coptic in Greek Block Chart </summary></documentation>
          </field>
          <field name="CountingRodNumerals" id="F:Microsoft.Test.Text.UnicodeChart.CountingRodNumerals" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="64">
            <documentation><summary> Counting Rod Numerals Chart </summary></documentation>
          </field>
          <field name="Cuneiform" id="F:Microsoft.Test.Text.UnicodeChart.Cuneiform" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="65">
            <documentation><summary> Cuneiform Chart </summary></documentation>
          </field>
          <field name="CuneiformNumbersAndPunctuation" id="F:Microsoft.Test.Text.UnicodeChart.CuneiformNumbersAndPunctuation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="66">
            <documentation><summary> Cuneiform Numbers and Punctuation Chart </summary></documentation>
          </field>
          <field name="CurrencySymbols" id="F:Microsoft.Test.Text.UnicodeChart.CurrencySymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="67">
            <documentation><summary> Currency Symbols Chart </summary></documentation>
          </field>
          <field name="CypriotSyllabary" id="F:Microsoft.Test.Text.UnicodeChart.CypriotSyllabary" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="68">
            <documentation><summary> Cypriot Syllabary Chart </summary></documentation>
          </field>
          <field name="Cyrillic" id="F:Microsoft.Test.Text.UnicodeChart.Cyrillic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="69">
            <documentation><summary> Cyrillic Chart </summary></documentation>
          </field>
          <field name="CyrillicExtendedA" id="F:Microsoft.Test.Text.UnicodeChart.CyrillicExtendedA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="70">
            <documentation><summary> Cyrillic Extended-A Chart </summary></documentation>
          </field>
          <field name="CyrillicExtendedB" id="F:Microsoft.Test.Text.UnicodeChart.CyrillicExtendedB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="71">
            <documentation><summary> Cyrillic Extended-B Chart </summary></documentation>
          </field>
          <field name="CyrillicSupplement" id="F:Microsoft.Test.Text.UnicodeChart.CyrillicSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="72">
            <documentation><summary> Cyrillic Supplement Chart </summary></documentation>
          </field>
          <field name="Deseret" id="F:Microsoft.Test.Text.UnicodeChart.Deseret" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="73">
            <documentation><summary> Deseret Chart </summary></documentation>
          </field>
          <field name="Devanagari" id="F:Microsoft.Test.Text.UnicodeChart.Devanagari" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="74">
            <documentation><summary> Devanagari Chart </summary></documentation>
          </field>
          <field name="DevanagariExtended" id="F:Microsoft.Test.Text.UnicodeChart.DevanagariExtended" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="75">
            <documentation><summary> Devanagari Extended Chart </summary></documentation>
          </field>
          <field name="Dingbats" id="F:Microsoft.Test.Text.UnicodeChart.Dingbats" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="76">
            <documentation><summary> Dingbats Chart </summary></documentation>
          </field>
          <field name="DollarSign" id="F:Microsoft.Test.Text.UnicodeChart.DollarSign" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="77">
            <documentation><summary> Dollar Sign Chart </summary></documentation>
          </field>
          <field name="DominoTiles" id="F:Microsoft.Test.Text.UnicodeChart.DominoTiles" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="78">
            <documentation><summary> Domino Tiles Chart </summary></documentation>
          </field>
          <field name="EgyptianHieroglyphs" id="F:Microsoft.Test.Text.UnicodeChart.EgyptianHieroglyphs" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="79">
            <documentation><summary> Egyptian Hieroglyphs Chart </summary></documentation>
          </field>
          <field name="EnclosedAlphanumerics" id="F:Microsoft.Test.Text.UnicodeChart.EnclosedAlphanumerics" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="80">
            <documentation><summary> Enclosed Alphanumerics Chart </summary></documentation>
          </field>
          <field name="EnclosedAlphanumericSupplement" id="F:Microsoft.Test.Text.UnicodeChart.EnclosedAlphanumericSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="81">
            <documentation><summary> Enclosed Alphanumeric Supplement Chart </summary></documentation>
          </field>
          <field name="EnclosedCjkLettersAndMonths" id="F:Microsoft.Test.Text.UnicodeChart.EnclosedCjkLettersAndMonths" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="82">
            <documentation><summary> Enclosed CJK Letters and Months Chart </summary></documentation>
          </field>
          <field name="EnclosedIdeographicSupplement" id="F:Microsoft.Test.Text.UnicodeChart.EnclosedIdeographicSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="83">
            <documentation><summary> Enclosed Ideographic Supplement Chart </summary></documentation>
          </field>
          <field name="Ethiopic" id="F:Microsoft.Test.Text.UnicodeChart.Ethiopic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="84">
            <documentation><summary> Ethiopic Chart </summary></documentation>
          </field>
          <field name="EthiopicExtended" id="F:Microsoft.Test.Text.UnicodeChart.EthiopicExtended" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="85">
            <documentation><summary> Ethiopic Extended Chart </summary></documentation>
          </field>
          <field name="EthiopicSupplement" id="F:Microsoft.Test.Text.UnicodeChart.EthiopicSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="86">
            <documentation><summary> Ethiopic Supplement Chart </summary></documentation>
          </field>
          <field name="EuroSign" id="F:Microsoft.Test.Text.UnicodeChart.EuroSign" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="87">
            <documentation><summary> Euro Sign Chart </summary></documentation>
          </field>
          <field name="FloorsAndCeilings" id="F:Microsoft.Test.Text.UnicodeChart.FloorsAndCeilings" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="88">
            <documentation><summary> Floors and ceilings </summary></documentation>
          </field>
          <field name="FullwidthAsciiDigits" id="F:Microsoft.Test.Text.UnicodeChart.FullwidthAsciiDigits" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="89">
            <documentation><summary> Fullwidth ASCII Digits Chart </summary></documentation>
          </field>
          <field name="FullwidthAsciiPunctuation" id="F:Microsoft.Test.Text.UnicodeChart.FullwidthAsciiPunctuation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="90">
            <documentation><summary> Fullwidth ASCII Punctuation Chart </summary></documentation>
          </field>
          <field name="FullwidthCurrencySymbols" id="F:Microsoft.Test.Text.UnicodeChart.FullwidthCurrencySymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="91">
            <documentation><summary> Fullwidth Currency Symbols Chart </summary></documentation>
          </field>
          <field name="FullwidthLatinLetters" id="F:Microsoft.Test.Text.UnicodeChart.FullwidthLatinLetters" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="92">
            <documentation><summary> Fullwidth Latin Letters Chart </summary></documentation>
          </field>
          <field name="GameSymbols" id="F:Microsoft.Test.Text.UnicodeChart.GameSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="93">
            <documentation><summary> Same as Chess/Checkers Chart </summary></documentation>
          </field>
          <field name="GeneralPunctuation" id="F:Microsoft.Test.Text.UnicodeChart.GeneralPunctuation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="94">
            <documentation><summary> General Punctuation Chart </summary></documentation>
          </field>
          <field name="GeometricShapes" id="F:Microsoft.Test.Text.UnicodeChart.GeometricShapes" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="95">
            <documentation><summary> Geometric Shapes Chart </summary></documentation>
          </field>
          <field name="Georgian" id="F:Microsoft.Test.Text.UnicodeChart.Georgian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="96">
            <documentation><summary> Georgian Chart </summary></documentation>
          </field>
          <field name="GeorgianSupplement" id="F:Microsoft.Test.Text.UnicodeChart.GeorgianSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="97">
            <documentation><summary> Georgian Supplement Chart </summary></documentation>
          </field>
          <field name="Glagolitic" id="F:Microsoft.Test.Text.UnicodeChart.Glagolitic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="98">
            <documentation><summary> Glagolitic Chart </summary></documentation>
          </field>
          <field name="Gothic" id="F:Microsoft.Test.Text.UnicodeChart.Gothic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="99">
            <documentation><summary> Gothic Chart </summary></documentation>
          </field>
          <field name="Greek" id="F:Microsoft.Test.Text.UnicodeChart.Greek" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="100">
            <documentation><summary> Greek Chart </summary></documentation>
          </field>
          <field name="GreekExtended" id="F:Microsoft.Test.Text.UnicodeChart.GreekExtended" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="101">
            <documentation><summary> Greek Extended Chart </summary></documentation>
          </field>
          <field name="Gujarati" id="F:Microsoft.Test.Text.UnicodeChart.Gujarati" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="102">
            <documentation><summary> Gujarati Chart </summary></documentation>
          </field>
          <field name="Gurmukhi" id="F:Microsoft.Test.Text.UnicodeChart.Gurmukhi" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="103">
            <documentation><summary> Gurmukhi Chart </summary></documentation>
          </field>
          <field name="HalfwidthAndFullwidthForms" id="F:Microsoft.Test.Text.UnicodeChart.HalfwidthAndFullwidthForms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="104">
            <documentation><summary> Halfwidth and Fullwidth Forms Chart </summary></documentation>
          </field>
          <field name="HalfwidthJamo" id="F:Microsoft.Test.Text.UnicodeChart.HalfwidthJamo" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="105">
            <documentation><summary> Half width Jamo Chart </summary></documentation>
          </field>
          <field name="HalfwidthKatakana" id="F:Microsoft.Test.Text.UnicodeChart.HalfwidthKatakana" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="106">
            <documentation><summary> Half width Katakana Chart </summary></documentation>
          </field>
          <field name="HangulCompatibilityJamo" id="F:Microsoft.Test.Text.UnicodeChart.HangulCompatibilityJamo" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="107">
            <documentation><summary> Hangul Compatibility Jamo Chart </summary></documentation>
          </field>
          <field name="HangulJamo" id="F:Microsoft.Test.Text.UnicodeChart.HangulJamo" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="108">
            <documentation><summary> Hangul Jamo Chart </summary></documentation>
          </field>
          <field name="HangulJamoExtendedA" id="F:Microsoft.Test.Text.UnicodeChart.HangulJamoExtendedA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="109">
            <documentation><summary> Hangul Jamo ExtendedA Chart </summary></documentation>
          </field>
          <field name="HangulJamoExtendedB" id="F:Microsoft.Test.Text.UnicodeChart.HangulJamoExtendedB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="110">
            <documentation><summary> Hangul Jamo Extended-B Chart </summary></documentation>
          </field>
          <field name="HangulSyllables" id="F:Microsoft.Test.Text.UnicodeChart.HangulSyllables" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="111">
            <documentation><summary> Hangul Syllables Chart </summary></documentation>
          </field>
          <field name="Hanunoo" id="F:Microsoft.Test.Text.UnicodeChart.Hanunoo" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="112">
            <documentation><summary> Hanunoo Chart </summary></documentation>
          </field>
          <field name="Hebrew" id="F:Microsoft.Test.Text.UnicodeChart.Hebrew" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="113">
            <documentation><summary> Hebrew Chart </summary></documentation>
          </field>
          <field name="HebrewPresentationForms" id="F:Microsoft.Test.Text.UnicodeChart.HebrewPresentationForms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="114">
            <documentation><summary> Hebrew Presentation Forms Chart </summary></documentation>
          </field>
          <field name="HighSurrogates" id="F:Microsoft.Test.Text.UnicodeChart.HighSurrogates" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="115">
            <documentation><summary> High Surrogates Chart </summary></documentation>
          </field>
          <field name="Hiragana" id="F:Microsoft.Test.Text.UnicodeChart.Hiragana" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="116">
            <documentation><summary> Hiragana Chart </summary></documentation>
          </field>
          <field name="IdeographicDescriptionCharacters" id="F:Microsoft.Test.Text.UnicodeChart.IdeographicDescriptionCharacters" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="117">
            <documentation><summary> Ideographic Description Characters Chart </summary></documentation>
          </field>
          <field name="InvisibleOperators" id="F:Microsoft.Test.Text.UnicodeChart.InvisibleOperators" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="118">
            <documentation><summary> Invisible Operators Chart </summary></documentation>
          </field>
          <field name="IpaExtensions" id="F:Microsoft.Test.Text.UnicodeChart.IpaExtensions" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="119">
            <documentation><summary> IPA Extensions Chart </summary></documentation>
          </field>
          <field name="JapaneseChess" id="F:Microsoft.Test.Text.UnicodeChart.JapaneseChess" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="120">
            <documentation><summary> Japanese Chess Chart </summary></documentation>
          </field>
          <field name="Javanese" id="F:Microsoft.Test.Text.UnicodeChart.Javanese" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="121">
            <documentation><summary> Javanese Chart </summary></documentation>
          </field>
          <field name="Kaithi" id="F:Microsoft.Test.Text.UnicodeChart.Kaithi" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="122">
            <documentation><summary> Kaithi Chart </summary></documentation>
          </field>
          <field name="Kanbun" id="F:Microsoft.Test.Text.UnicodeChart.Kanbun" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="123">
            <documentation><summary> Kanbun Chart </summary></documentation>
          </field>
          <field name="Kannada" id="F:Microsoft.Test.Text.UnicodeChart.Kannada" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="124">
            <documentation><summary> Kannada Chart </summary></documentation>
          </field>
          <field name="Katakana" id="F:Microsoft.Test.Text.UnicodeChart.Katakana" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="125">
            <documentation><summary> Katakana Chart </summary></documentation>
          </field>
          <field name="KatakanaPhoneticExtensions" id="F:Microsoft.Test.Text.UnicodeChart.KatakanaPhoneticExtensions" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="126">
            <documentation><summary> Katakana Phonetic Extensions Chart </summary></documentation>
          </field>
          <field name="KayahLi" id="F:Microsoft.Test.Text.UnicodeChart.KayahLi" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="127">
            <documentation><summary> Kayah Li Chart </summary></documentation>
          </field>
          <field name="Kharoshthi" id="F:Microsoft.Test.Text.UnicodeChart.Kharoshthi" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="128">
            <documentation><summary> Kharoshthi Chart </summary></documentation>
          </field>
          <field name="Khmer" id="F:Microsoft.Test.Text.UnicodeChart.Khmer" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="129">
            <documentation><summary> Khmer Chart </summary></documentation>
          </field>
          <field name="KhmerSymbols" id="F:Microsoft.Test.Text.UnicodeChart.KhmerSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="130">
            <documentation><summary> Khmer Symbols Chart </summary></documentation>
          </field>
          <field name="Lao" id="F:Microsoft.Test.Text.UnicodeChart.Lao" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="131">
            <documentation><summary> Lao Chart </summary></documentation>
          </field>
          <field name="Latin" id="F:Microsoft.Test.Text.UnicodeChart.Latin" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="132">
            <documentation><summary> Latin Chart </summary></documentation>
          </field>
          <field name="Latin1Punctuation" id="F:Microsoft.Test.Text.UnicodeChart.Latin1Punctuation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="133">
            <documentation><summary> Latin-1 Punctuation Chart </summary></documentation>
          </field>
          <field name="Latin1Supplement" id="F:Microsoft.Test.Text.UnicodeChart.Latin1Supplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="134">
            <documentation><summary> Latin-1 Supplement Chart </summary></documentation>
          </field>
          <field name="LatinExtendedA" id="F:Microsoft.Test.Text.UnicodeChart.LatinExtendedA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="135">
            <documentation><summary> Latin Extended-A Chart </summary></documentation>
          </field>
          <field name="LatinExtendedAdditional" id="F:Microsoft.Test.Text.UnicodeChart.LatinExtendedAdditional" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="136">
            <documentation><summary> Latin Extended Additional Chart </summary></documentation>
          </field>
          <field name="LatinExtendedB" id="F:Microsoft.Test.Text.UnicodeChart.LatinExtendedB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="137">
            <documentation><summary> Latin Extended-B Chart </summary></documentation>
          </field>
          <field name="LatinExtendedC" id="F:Microsoft.Test.Text.UnicodeChart.LatinExtendedC" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="138">
            <documentation><summary> Latin Extended-C Chart </summary></documentation>
          </field>
          <field name="LatinExtendedD" id="F:Microsoft.Test.Text.UnicodeChart.LatinExtendedD" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="139">
            <documentation><summary> Latin Extended-D Chart </summary></documentation>
          </field>
          <field name="LatinLigatures" id="F:Microsoft.Test.Text.UnicodeChart.LatinLigatures" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="140">
            <documentation><summary> Latin Ligatures Chart </summary></documentation>
          </field>
          <field name="LayoutControls" id="F:Microsoft.Test.Text.UnicodeChart.LayoutControls" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="141">
            <documentation><summary> Layout Controls Chart </summary></documentation>
          </field>
          <field name="Lepcha" id="F:Microsoft.Test.Text.UnicodeChart.Lepcha" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="142">
            <documentation><summary> Lepcha Chart </summary></documentation>
          </field>
          <field name="LetterlikeSymbols" id="F:Microsoft.Test.Text.UnicodeChart.LetterlikeSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="143">
            <documentation><summary> Letterlike Symbols Chart </summary></documentation>
          </field>
          <field name="Limbu" id="F:Microsoft.Test.Text.UnicodeChart.Limbu" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="144">
            <documentation><summary> Limbu Chart </summary></documentation>
          </field>
          <field name="LinearB" id="F:Microsoft.Test.Text.UnicodeChart.LinearB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="145">
            <documentation><summary> Linear B Syllabary and Linear B Ideograms Chart </summary></documentation>
          </field>
          <field name="LinearBIdeograms" id="F:Microsoft.Test.Text.UnicodeChart.LinearBIdeograms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="146">
            <documentation><summary> Linear B Ideograms Chart </summary></documentation>
          </field>
          <field name="LinearBSyllabary" id="F:Microsoft.Test.Text.UnicodeChart.LinearBSyllabary" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="147">
            <documentation><summary> Linear B Syllabary Chart </summary></documentation>
          </field>
          <field name="Lisu" id="F:Microsoft.Test.Text.UnicodeChart.Lisu" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="148">
            <documentation><summary> Lisu Chart </summary></documentation>
          </field>
          <field name="LowSurrogates" id="F:Microsoft.Test.Text.UnicodeChart.LowSurrogates" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="149">
            <documentation><summary> Low Surrogates Chart </summary></documentation>
          </field>
          <field name="Lycian" id="F:Microsoft.Test.Text.UnicodeChart.Lycian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="150">
            <documentation><summary> Lycian Chart </summary></documentation>
          </field>
          <field name="Lydian" id="F:Microsoft.Test.Text.UnicodeChart.Lydian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="151">
            <documentation><summary> Lydian Chart </summary></documentation>
          </field>
          <field name="MahjongTiles" id="F:Microsoft.Test.Text.UnicodeChart.MahjongTiles" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="152">
            <documentation><summary> Mahjong Tiles Chart </summary></documentation>
          </field>
          <field name="Malayalam" id="F:Microsoft.Test.Text.UnicodeChart.Malayalam" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="153">
            <documentation><summary> Malayalam Chart </summary></documentation>
          </field>
          <field name="Mark" id="F:Microsoft.Test.Text.UnicodeChart.Mark" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="154">
            <documentation><summary> Mark Chart </summary></documentation>
          </field>
          <field name="MathematicalAlphanumericSymbols" id="F:Microsoft.Test.Text.UnicodeChart.MathematicalAlphanumericSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="155">
            <documentation><summary> Mathematical Alphanumeric Symbols Chart </summary></documentation>
          </field>
          <field name="MathematicalOperators" id="F:Microsoft.Test.Text.UnicodeChart.MathematicalOperators" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="156">
            <documentation><summary> Mathematical Operators Chart </summary></documentation>
          </field>
          <field name="MeeteiMayek" id="F:Microsoft.Test.Text.UnicodeChart.MeeteiMayek" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="157">
            <documentation><summary> Meetei Mayek Chart </summary></documentation>
          </field>
          <field name="MiscellaneousMathematicalSymbolsA" id="F:Microsoft.Test.Text.UnicodeChart.MiscellaneousMathematicalSymbolsA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="158">
            <documentation><summary> Miscellaneous Mathematical SymbolsA Chart </summary></documentation>
          </field>
          <field name="MiscellaneousMathematicalSymbolsB" id="F:Microsoft.Test.Text.UnicodeChart.MiscellaneousMathematicalSymbolsB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="159">
            <documentation><summary> Miscellaneous Mathematical SymbolsB Chart </summary></documentation>
          </field>
          <field name="MiscellaneousSymbols" id="F:Microsoft.Test.Text.UnicodeChart.MiscellaneousSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="160">
            <documentation><summary> Miscellaneous Symbols Chart </summary></documentation>
          </field>
          <field name="MiscellaneousSymbolsAndArrows" id="F:Microsoft.Test.Text.UnicodeChart.MiscellaneousSymbolsAndArrows" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="161">
            <documentation><summary> Miscellaneous Symbols and Arrows Chart </summary></documentation>
          </field>
          <field name="MiscellaneousTechnical" id="F:Microsoft.Test.Text.UnicodeChart.MiscellaneousTechnical" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="162">
            <documentation><summary> Miscellaneous Technical Chart </summary></documentation>
          </field>
          <field name="ModifierToneLetters" id="F:Microsoft.Test.Text.UnicodeChart.ModifierToneLetters" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="163">
            <documentation><summary> Modifier Tone Letters Chart </summary></documentation>
          </field>
          <field name="Mongolian" id="F:Microsoft.Test.Text.UnicodeChart.Mongolian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="164">
            <documentation><summary> Mongolian Chart </summary></documentation>
          </field>
          <field name="MusicalSymbols" id="F:Microsoft.Test.Text.UnicodeChart.MusicalSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="165">
            <documentation><summary> Musical Symbols Chart </summary></documentation>
          </field>
          <field name="Myanmar" id="F:Microsoft.Test.Text.UnicodeChart.Myanmar" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="166">
            <documentation><summary> Myanmar Chart </summary></documentation>
          </field>
          <field name="MyanmarExtendedA" id="F:Microsoft.Test.Text.UnicodeChart.MyanmarExtendedA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="167">
            <documentation><summary> Myanmar Extended-A Chart </summary></documentation>
          </field>
          <field name="NewTaiLue" id="F:Microsoft.Test.Text.UnicodeChart.NewTaiLue" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="168">
            <documentation><summary> New Tai Lue Chart </summary></documentation>
          </field>
          <field name="NKo" id="F:Microsoft.Test.Text.UnicodeChart.NKo" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="169">
            <documentation><summary> N'Ko Chart </summary></documentation>
          </field>
          <field name="NumberForms" id="F:Microsoft.Test.Text.UnicodeChart.NumberForms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="170">
            <documentation><summary> Number Forms Chart </summary></documentation>
          </field>
          <field name="Ogham" id="F:Microsoft.Test.Text.UnicodeChart.Ogham" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="171">
            <documentation><summary> Ogham Chart </summary></documentation>
          </field>
          <field name="OlChiki" id="F:Microsoft.Test.Text.UnicodeChart.OlChiki" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="172">
            <documentation><summary> Ol Chiki Chart </summary></documentation>
          </field>
          <field name="OldItalic" id="F:Microsoft.Test.Text.UnicodeChart.OldItalic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="173">
            <documentation><summary> Old Italic Chart </summary></documentation>
          </field>
          <field name="OldPersian" id="F:Microsoft.Test.Text.UnicodeChart.OldPersian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="174">
            <documentation><summary> Old Persian Chart </summary></documentation>
          </field>
          <field name="OldSouthArabian" id="F:Microsoft.Test.Text.UnicodeChart.OldSouthArabian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="175">
            <documentation><summary> Old South Arabian Chart </summary></documentation>
          </field>
          <field name="OldTurkic" id="F:Microsoft.Test.Text.UnicodeChart.OldTurkic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="176">
            <documentation><summary> Old Turkic Chart </summary></documentation>
          </field>
          <field name="OpticalCharacterRecognition" id="F:Microsoft.Test.Text.UnicodeChart.OpticalCharacterRecognition" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="177">
            <documentation><summary> Optical Character Recognition Chart </summary></documentation>
          </field>
          <field name="Oriya" id="F:Microsoft.Test.Text.UnicodeChart.Oriya" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="178">
            <documentation><summary> Oriya Chart </summary></documentation>
          </field>
          <field name="Osmanya" id="F:Microsoft.Test.Text.UnicodeChart.Osmanya" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="179">
            <documentation><summary> Osmanya Chart </summary></documentation>
          </field>
          <field name="PahlaviInscriptional" id="F:Microsoft.Test.Text.UnicodeChart.PahlaviInscriptional" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="180">
            <documentation><summary> Pahlavi Inscriptional Chart </summary></documentation>
          </field>
          <field name="ParthianInscriptional" id="F:Microsoft.Test.Text.UnicodeChart.ParthianInscriptional" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="181">
            <documentation><summary> Parthian Inscriptional Chart </summary></documentation>
          </field>
          <field name="Pfennig" id="F:Microsoft.Test.Text.UnicodeChart.Pfennig" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="182">
            <documentation><summary> Pfennig Chart </summary></documentation>
          </field>
          <field name="PhagsPa" id="F:Microsoft.Test.Text.UnicodeChart.PhagsPa" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="183">
            <documentation><summary> Phags-Pa Chart </summary></documentation>
          </field>
          <field name="PhaistosDisc" id="F:Microsoft.Test.Text.UnicodeChart.PhaistosDisc" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="184">
            <documentation><summary> Phaistos Disc Chart </summary></documentation>
          </field>
          <field name="Phoenician" id="F:Microsoft.Test.Text.UnicodeChart.Phoenician" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="185">
            <documentation><summary> Phoenician Chart </summary></documentation>
          </field>
          <field name="PhoneticExtensions" id="F:Microsoft.Test.Text.UnicodeChart.PhoneticExtensions" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="186">
            <documentation><summary> Phonetic Extensions Chart </summary></documentation>
          </field>
          <field name="PhoneticExtensionsSupplement" id="F:Microsoft.Test.Text.UnicodeChart.PhoneticExtensionsSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="187">
            <documentation><summary> Phonetic Extensions Supplement Chart </summary></documentation>
          </field>
          <field name="Plane1" id="F:Microsoft.Test.Text.UnicodeChart.Plane1" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="188">
            <documentation><summary> Plane 1 Chart </summary></documentation>
          </field>
          <field name="Plane10" id="F:Microsoft.Test.Text.UnicodeChart.Plane10" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="189">
            <documentation><summary> Plane 10 Chart </summary></documentation>
          </field>
          <field name="Plane11" id="F:Microsoft.Test.Text.UnicodeChart.Plane11" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="190">
            <documentation><summary> Plane 11 Chart </summary></documentation>
          </field>
          <field name="Plane12" id="F:Microsoft.Test.Text.UnicodeChart.Plane12" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="191">
            <documentation><summary> Plane 12 Chart </summary></documentation>
          </field>
          <field name="Plane13" id="F:Microsoft.Test.Text.UnicodeChart.Plane13" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="192">
            <documentation><summary> Plane 13 Chart </summary></documentation>
          </field>
          <field name="Plane14" id="F:Microsoft.Test.Text.UnicodeChart.Plane14" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="193">
            <documentation><summary> Plane 14 Chart </summary></documentation>
          </field>
          <field name="Plane15" id="F:Microsoft.Test.Text.UnicodeChart.Plane15" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="194">
            <documentation><summary> Plane 15 Chart </summary></documentation>
          </field>
          <field name="Plane16" id="F:Microsoft.Test.Text.UnicodeChart.Plane16" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="195">
            <documentation><summary> Plane 16 Chart </summary></documentation>
          </field>
          <field name="Plane2" id="F:Microsoft.Test.Text.UnicodeChart.Plane2" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="196">
            <documentation><summary> Plane 2 Chart </summary></documentation>
          </field>
          <field name="Plane3" id="F:Microsoft.Test.Text.UnicodeChart.Plane3" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="197">
            <documentation><summary> Plane 3 Chart </summary></documentation>
          </field>
          <field name="Plane4" id="F:Microsoft.Test.Text.UnicodeChart.Plane4" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="198">
            <documentation><summary> Plane 4 Chart </summary></documentation>
          </field>
          <field name="Plane5" id="F:Microsoft.Test.Text.UnicodeChart.Plane5" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="199">
            <documentation><summary> Plane 5 Chart </summary></documentation>
          </field>
          <field name="Plane6" id="F:Microsoft.Test.Text.UnicodeChart.Plane6" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="200">
            <documentation><summary> Plane 6 Chart </summary></documentation>
          </field>
          <field name="Plane7" id="F:Microsoft.Test.Text.UnicodeChart.Plane7" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="201">
            <documentation><summary> Plane 7 Chart </summary></documentation>
          </field>
          <field name="Plane8" id="F:Microsoft.Test.Text.UnicodeChart.Plane8" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="202">
            <documentation><summary> Plane 8 Chart </summary></documentation>
          </field>
          <field name="Plane9" id="F:Microsoft.Test.Text.UnicodeChart.Plane9" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="203">
            <documentation><summary> Plane 9 Chart </summary></documentation>
          </field>
          <field name="PrivateUseArea" id="F:Microsoft.Test.Text.UnicodeChart.PrivateUseArea" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="204">
            <documentation><summary> Private Use Area Chart </summary></documentation>
          </field>
          <field name="Rejang" id="F:Microsoft.Test.Text.UnicodeChart.Rejang" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="205">
            <documentation><summary> Rejang Chart </summary></documentation>
          </field>
          <field name="ReservedRange" id="F:Microsoft.Test.Text.UnicodeChart.ReservedRange" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="206">
            <documentation><summary> Reserved Range Chart </summary></documentation>
          </field>
          <field name="RialSign" id="F:Microsoft.Test.Text.UnicodeChart.RialSign" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="207">
            <documentation><summary> Rial Sign Chart </summary></documentation>
          </field>
          <field name="RomanSymbols" id="F:Microsoft.Test.Text.UnicodeChart.RomanSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="208">
            <documentation><summary> Roman Symbols Chart </summary></documentation>
          </field>
          <field name="RumiNumeralSymbols" id="F:Microsoft.Test.Text.UnicodeChart.RumiNumeralSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="209">
            <documentation><summary> Rumi Numeral Symbols Chart </summary></documentation>
          </field>
          <field name="Runic" id="F:Microsoft.Test.Text.UnicodeChart.Runic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="210">
            <documentation><summary> Runic Chart </summary></documentation>
          </field>
          <field name="Samaritan" id="F:Microsoft.Test.Text.UnicodeChart.Samaritan" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="211">
            <documentation><summary> Samaritan Chart </summary></documentation>
          </field>
          <field name="Saurashtra" id="F:Microsoft.Test.Text.UnicodeChart.Saurashtra" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="212">
            <documentation><summary> Saurashtra Chart </summary></documentation>
          </field>
          <field name="Shavian" id="F:Microsoft.Test.Text.UnicodeChart.Shavian" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="213">
            <documentation><summary> Shavian Chart </summary></documentation>
          </field>
          <field name="Sinhala" id="F:Microsoft.Test.Text.UnicodeChart.Sinhala" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="214">
            <documentation><summary> Sinhala Chart </summary></documentation>
          </field>
          <field name="SmallFormVariants" id="F:Microsoft.Test.Text.UnicodeChart.SmallFormVariants" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="215">
            <documentation><summary> Small Form Variants Chart </summary></documentation>
          </field>
          <field name="SpacingModifierLetters" id="F:Microsoft.Test.Text.UnicodeChart.SpacingModifierLetters" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="216">
            <documentation><summary> Spacing Modifier Letters Chart </summary></documentation>
          </field>
          <field name="Specials" id="F:Microsoft.Test.Text.UnicodeChart.Specials" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="217">
            <documentation><summary> Specials Chart </summary></documentation>
          </field>
          <field name="Sundanese" id="F:Microsoft.Test.Text.UnicodeChart.Sundanese" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="218">
            <documentation><summary> Sundanese Chart </summary></documentation>
          </field>
          <field name="SuperAndSubscripts" id="F:Microsoft.Test.Text.UnicodeChart.SuperAndSubscripts" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="219">
            <documentation><summary> Super and Subscripts Chart </summary></documentation>
          </field>
          <field name="SuperscriptsAndSubscripts" id="F:Microsoft.Test.Text.UnicodeChart.SuperscriptsAndSubscripts" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="220">
            <documentation><summary> Superscripts and Subscripts Chart </summary></documentation>
          </field>
          <field name="SupplementalArrowsA" id="F:Microsoft.Test.Text.UnicodeChart.SupplementalArrowsA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="221">
            <documentation><summary> Supplemental Arrows-A Chart </summary></documentation>
          </field>
          <field name="SupplementalArrowsB" id="F:Microsoft.Test.Text.UnicodeChart.SupplementalArrowsB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="222">
            <documentation><summary> Supplemental Arrows-B Chart </summary></documentation>
          </field>
          <field name="SupplementalMathematicalOperators" id="F:Microsoft.Test.Text.UnicodeChart.SupplementalMathematicalOperators" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="223">
            <documentation><summary> Supplemental Mathematical Operators Chart </summary></documentation>
          </field>
          <field name="SupplementalPunctuation" id="F:Microsoft.Test.Text.UnicodeChart.SupplementalPunctuation" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="224">
            <documentation><summary> Supplemental Punctuation Chart </summary></documentation>
          </field>
          <field name="SupplementaryPrivateUseAreaA" id="F:Microsoft.Test.Text.UnicodeChart.SupplementaryPrivateUseAreaA" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="225">
            <documentation><summary> Supplementary Private Use Area-A Chart </summary></documentation>
          </field>
          <field name="SupplementaryPrivateUseAreaB" id="F:Microsoft.Test.Text.UnicodeChart.SupplementaryPrivateUseAreaB" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="226">
            <documentation><summary> Supplementary Private Use Area-B Chart </summary></documentation>
          </field>
          <field name="SylotiNagri" id="F:Microsoft.Test.Text.UnicodeChart.SylotiNagri" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="227">
            <documentation><summary> Syloti Nagri Chart </summary></documentation>
          </field>
          <field name="Syriac" id="F:Microsoft.Test.Text.UnicodeChart.Syriac" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="228">
            <documentation><summary> Syriac Chart </summary></documentation>
          </field>
          <field name="Tagalog" id="F:Microsoft.Test.Text.UnicodeChart.Tagalog" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="229">
            <documentation><summary> Tagalog Chart </summary></documentation>
          </field>
          <field name="Tagbanwa" id="F:Microsoft.Test.Text.UnicodeChart.Tagbanwa" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="230">
            <documentation><summary> Tagbanwa Chart </summary></documentation>
          </field>
          <field name="Tags" id="F:Microsoft.Test.Text.UnicodeChart.Tags" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="231">
            <documentation><summary> Tags Chart </summary></documentation>
          </field>
          <field name="TaiLe" id="F:Microsoft.Test.Text.UnicodeChart.TaiLe" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="232">
            <documentation><summary> Tai Le Chart </summary></documentation>
          </field>
          <field name="TaiTham" id="F:Microsoft.Test.Text.UnicodeChart.TaiTham" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="233">
            <documentation><summary> Tai Tham Chart </summary></documentation>
          </field>
          <field name="TaiViet" id="F:Microsoft.Test.Text.UnicodeChart.TaiViet" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="234">
            <documentation><summary> Tai Viet Chart </summary></documentation>
          </field>
          <field name="TaiXuanJingSymbols" id="F:Microsoft.Test.Text.UnicodeChart.TaiXuanJingSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="235">
            <documentation><summary> Tai Xuan Jing Symbols Chart </summary></documentation>
          </field>
          <field name="Tamil" id="F:Microsoft.Test.Text.UnicodeChart.Tamil" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="236">
            <documentation><summary> Tamil Chart </summary></documentation>
          </field>
          <field name="Telugu" id="F:Microsoft.Test.Text.UnicodeChart.Telugu" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="237">
            <documentation><summary> Telugu Chart </summary></documentation>
          </field>
          <field name="Thaana" id="F:Microsoft.Test.Text.UnicodeChart.Thaana" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="238">
            <documentation><summary> Thaana Chart </summary></documentation>
          </field>
          <field name="Thai" id="F:Microsoft.Test.Text.UnicodeChart.Thai" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="239">
            <documentation><summary> Thai Chart </summary></documentation>
          </field>
          <field name="Tibetan" id="F:Microsoft.Test.Text.UnicodeChart.Tibetan" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="240">
            <documentation><summary> Tibetan Chart </summary></documentation>
          </field>
          <field name="Tifinagh" id="F:Microsoft.Test.Text.UnicodeChart.Tifinagh" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="241">
            <documentation><summary> Tifinagh Chart </summary></documentation>
          </field>
          <field name="Ugaritic" id="F:Microsoft.Test.Text.UnicodeChart.Ugaritic" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="242">
            <documentation><summary> Ugaritic Chart </summary></documentation>
          </field>
          <field name="UnifiedCanadianAboriginalSyllabics" id="F:Microsoft.Test.Text.UnicodeChart.UnifiedCanadianAboriginalSyllabics" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="243">
            <documentation><summary> Unified Canadian Aboriginal Syllabics Chart </summary></documentation>
          </field>
          <field name="UnifiedCanadianAboriginalSyllabicsExtended" id="F:Microsoft.Test.Text.UnicodeChart.UnifiedCanadianAboriginalSyllabicsExtended" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="244">
            <documentation><summary> Unified Canadian Aboriginal Syllabics ExtendedChart </summary></documentation>
          </field>
          <field name="Vai" id="F:Microsoft.Test.Text.UnicodeChart.Vai" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="245">
            <documentation><summary> Vai Chart </summary></documentation>
          </field>
          <field name="VariationSelectors" id="F:Microsoft.Test.Text.UnicodeChart.VariationSelectors" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="246">
            <documentation><summary> Variation Selectors Chart </summary></documentation>
          </field>
          <field name="VariationSelectorsSupplement" id="F:Microsoft.Test.Text.UnicodeChart.VariationSelectorsSupplement" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="247">
            <documentation><summary> Variation Selectors Supplement Chart </summary></documentation>
          </field>
          <field name="VedicExtensions" id="F:Microsoft.Test.Text.UnicodeChart.VedicExtensions" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="248">
            <documentation><summary> Vedic Extensions Chart </summary></documentation>
          </field>
          <field name="VerticalForms" id="F:Microsoft.Test.Text.UnicodeChart.VerticalForms" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="249">
            <documentation><summary> Vertical Forms Chart </summary></documentation>
          </field>
          <field name="YenPoundAndCent" id="F:Microsoft.Test.Text.UnicodeChart.YenPoundAndCent" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="250">
            <documentation><summary> Yen Pound and Cent Chart </summary></documentation>
          </field>
          <field name="Yi" id="F:Microsoft.Test.Text.UnicodeChart.Yi" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="251">
            <documentation><summary> Yi Syllables and Yi Radicals Chart </summary></documentation>
          </field>
          <field name="YijingHexagramSymbols" id="F:Microsoft.Test.Text.UnicodeChart.YijingHexagramSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="252">
            <documentation><summary> Yijing Hexagram Symbols Chart </summary></documentation>
          </field>
          <field name="YijingMonoDiAndTrigrams" id="F:Microsoft.Test.Text.UnicodeChart.YijingMonoDiAndTrigrams" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="253">
            <documentation><summary> Yijing Mono- Di- and Trigrams Chart </summary></documentation>
          </field>
          <field name="YijingSymbols" id="F:Microsoft.Test.Text.UnicodeChart.YijingSymbols" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="254">
            <documentation><summary> Same as Yijing Mono- Di- and Trigrams Chart </summary></documentation>
          </field>
          <field name="YiRadicals" id="F:Microsoft.Test.Text.UnicodeChart.YiRadicals" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="255">
            <documentation><summary> Yi Radicals Chart </summary></documentation>
          </field>
          <field name="YiSyllables" id="F:Microsoft.Test.Text.UnicodeChart.YiSyllables" access="Public" contract="Static" typeId="T:Microsoft.Test.Text.UnicodeChart" valueType="true" literal="true" value="256">
            <documentation><summary> Yi Syllables Chart </summary></documentation>
          </field>
        </enumeration>
      </namespace>
      <namespace name="Microsoft.Test.LeakDetection">
        <class name="MemorySnapshot" displayName="MemorySnapshot" namespace="Microsoft.Test.LeakDetection" id="T:Microsoft.Test.LeakDetection.MemorySnapshot" access="Public">
          <documentation><summary> Represents a snapshot in time of the memory consumed by a specified OS process. MemorySnapshot objects can be instantiated from a running process or from a file. <p>MemorySnapshot objects are used for detection of <a href="http://en.wikipedia.org/wiki/Memory_leak">memory leaks</a>.</p></summary>
<example>
  <code> // Start an instance of the target process and wait for it to reach steady state.
 // Then take a memory snapshot.
 Process p = Process.Start("notepad.exe");
 p.WaitForInputIdle(5000);
 MemorySnapshot s1 = MemorySnapshot.FromProcess(p.Id);
 
 // Perform operations that may cause a leak in the target process...
 // Then take another second memory snapshot
 MemorySnapshot s2 = MemorySnapshot.FromProcess(p.Id);

 // Compare the two memory snapshots and generate a diff.
 // Check the fields of the resulting diff for possible leaks (indicated by fields with non-zero values).
 MemorySnapshot diff = s2.CompareTo(s1);
 if (diff.GdiObjectCount != 0)
 {
     s1.ToFile(@"\s1.xml");
     s2.ToFile(@"\s2.xml");
     Console.WriteLine("Possible GDI handle leak! Review the saved memory snapshots.");
 }
 
 // Close the process.
 p.CloseMainWindow();
 p.Close();
 </code>
</example>
<remarks>
  <p>For more information on memory leak detection in native code, refer to the <a href="http://msdn.microsoft.com/en-us/library/x98tx3cf.aspx"> Memory Leak Detection and Isolation</a> article. The table below provides a relationship between the metrics reported by the different tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>TestApi</strong>
      </td>
      <td>
        <strong>
          <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
        </strong>
      </td>
      <td>
        <strong>
          <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
        </strong>
      </td>
      <td>
        <strong>Task Manager (Windows 7)</strong>
      </td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.GdiObjectCount" />
      </td>
      <td> - </td>
      <td>Handles : GDI Objects</td>
      <td>GDI Handles</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.HandleCount" />
      </td>
      <td>HandleCount</td>
      <td>Handles : Handles</td>
      <td>Handles</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.PageFileBytes" />
      </td>
      <td>PageFileBytes</td>
      <td> - </td>
      <td> - </td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.PageFilePeakBytes" />
      </td>
      <td>PageFileBytesPeak</td>
      <td> - </td>
      <td> - </td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.PoolNonpagedBytes" />
      </td>
      <td>Pool Nonpaged Bytes</td>
      <td> - </td>
      <td>NonPaged Pool</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.PoolPagedBytes" />
      </td>
      <td>Pool Paged Bytes</td>
      <td> - </td>
      <td>Paged Pool</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.ThreadCount" />
      </td>
      <td> - </td>
      <td>Threads</td>
      <td>Threads</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.Timestamp" />
      </td>
      <td> - </td>
      <td> - </td>
      <td> - </td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.UserObjectCount" />
      </td>
      <td> - </td>
      <td>Handles : USER Objects</td>
      <td>USER Handles</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.VirtualMemoryBytes" />
      </td>
      <td>VirtualBytes</td>
      <td>Virtual Memory : Virtual Size</td>
      <td> - </td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.VirtualMemoryPrivateBytes" />
      </td>
      <td>PrivateBytes</td>
      <td>Virtual Memory : Private Bytes</td>
      <td>Commit Size</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetBytes" />
      </td>
      <td>WorkingSet</td>
      <td>Physical Memory : WorkingSet</td>
      <td>Working Set (Memory)</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetPeakBytes" />
      </td>
      <td>WorkingSetPeak</td>
      <td>Physical Memory : Peak Working Set</td>
      <td>Peak Working Set (Memory)</td>
    </tr>
    <tr>
      <td>
        <see cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetPrivateBytes" />
      </td>
      <td>WorkingSetPrivate</td>
      <td>Physical Memory : Working Set : WS Private</td>
      <td>Memory (Private Working Set)</td>
    </tr>
  </table>
</remarks></documentation>
          <property name="GdiObjectCount" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.GdiObjectCount" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The number of handles to GDI objects in use by the process. For more information see the <a href="http://msdn.microsoft.com/en-us/library/ms683192(VS.85).aspx">GetGuiResources</a> function. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Handles : GDI Objects</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>GDI Handles</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="HandleCount" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.HandleCount" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The total number of handles currently open by the process. This number is equal to the sum of the handles currently open by each thread in this process. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>HandleCount</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Handles : Handles</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>Handles</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="PageFileBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.PageFileBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The current amount of virtual memory that this process has reserved for use in the paging file or files. Those pages may or may not be in memory. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>PageFileBytes</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>n/a</td>
    </tr>
  </table> For more information, see the <a href="http://msdn.microsoft.com/en-us/library/ms684874(VS.85).aspx"> PROCESS_MEMORY_COUNTERS_EX</a> structure. </remarks></documentation>
          </property>
          <property name="PageFilePeakBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.PageFilePeakBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The maximum amount of virtual memory that this process has reserved for use in the paging file or files. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>PageFileBytesPeak</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>n/a</td>
    </tr>
  </table> For more information, see the <a href="http://msdn.microsoft.com/en-us/library/ms684874(VS.85).aspx"> PROCESS_MEMORY_COUNTERS_EX</a> structure. </remarks></documentation>
          </property>
          <property name="PoolNonpagedBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.PoolNonpagedBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The size of the <i>nonpaged pool</i>, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk but must remain in physical memory as long as they are allocated. For more information, see the <a href="http://msdn.microsoft.com/en-us/library/ms683219(VS.85).aspx">GetProcessMemoryInfo</a> function and the <a href="http://msdn.microsoft.com/en-us/library/ms684874(VS.85).aspx">PROCESS_MEMORY_COUNTERS_EX</a> structure. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>Pool Nonpaged Bytes</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>NonPaged Pool</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="PoolPagedBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.PoolPagedBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The size of the <i>paged pool</i>, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. For more information, see the <a href="http://msdn.microsoft.com/en-us/library/ms683219(VS.85).aspx">GetProcessMemoryInfo</a> function and the <a href="http://msdn.microsoft.com/en-us/library/ms684874(VS.85).aspx">PROCESS_MEMORY_COUNTERS_EX</a> structure. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>Pool Paged Bytes</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>Paged Pool</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="ThreadCount" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.ThreadCount" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The number of threads currently active in the process. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Threads</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>Threads</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="Timestamp" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.Timestamp" access="Public" contract="Normal" typeId="T:System.DateTime" valueType="true" get="Public" set="Private">
            <documentation><summary> The time when the memory snapshot was taken. </summary></documentation>
          </property>
          <property name="UserObjectCount" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.UserObjectCount" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The number of handles to USER objects in use by the process. For more information see the <a href="http://msdn.microsoft.com/en-us/library/ms683192(VS.85).aspx">GetGuiResources</a> function. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Handles : USER Objects</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>USER Handles</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="VirtualMemoryBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.VirtualMemoryBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The current size of the virtual address space that the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries. For more information see the <a href="http://msdn.microsoft.com/en-us/library/aa366589(VS.85).aspx">GlobalMemoryStatusEx</a> function and the <a href="http://msdn.microsoft.com/en-us/library/aa366770(VS.85).aspx">MEMORYSTATUSEX</a> structure. This metric is calculated as MEMORYSTATUSEX.ullTotalVirtual – MEMORYSTATUSEX.ullAvailVirtual. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>VirtualBytes</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Virtual Memory : Virtual Size</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>n/a</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="VirtualMemoryPrivateBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.VirtualMemoryPrivateBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The current size of memory that this process has allocated that cannot be shared with other processes. For more information see the <a href="http://msdn.microsoft.com/en-us/library/ms683219(VS.85).aspx">GetProcessMemoryInfo</a> function and the <a href="http://msdn.microsoft.com/en-us/library/ms684874(VS.85).aspx">PROCESS_MEMORY_COUNTERS_EX</a> structure (this metric corresponds to the <b>PrivateUsage</b> field in the structure). </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>PrivateBytes</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Virtual Memory : Private Bytes</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>Commit Size</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="WorkingSetBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The current size of the <i>working set</i> of the process. The working set is the set of memory pages recently touched by the threads in the process. If free memory in the computer is above a threshold, pages are left in the working set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from working sets. If they are needed they will then be soft-faulted back into the working set before leaving main memory. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>WorkingSet</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Physical Memory : Working Set</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>Working Set (Memory)</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="WorkingSetPeakBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetPeakBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The maximum size, in bytes, of the working set of the process at any one time. For more information see <seealso cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetBytes" />. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>WorkingSetPeak</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Physical Memory : Peak Working Set</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>Peak Working Set (Memory)</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <property name="WorkingSetPrivateBytes" id="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetPrivateBytes" access="Public" contract="Normal" typeId="T:System.Int64" valueType="true" get="Public" set="Private">
            <documentation><summary> The size of the working set that is only used for the process and not shared nor shareable by other processes. For more information see <seealso cref="P:Microsoft.Test.LeakDetection.MemorySnapshot.WorkingSetBytes" />. </summary>
<remarks>
  <p> This metric is reported as follows by the other tools: </p>
  <table style="font-size:xx-small" border="1" bordercolor="#CCCCCC" cellpadding="1" cellspacing="0">
    <tr>
      <td>
        <strong>Tool</strong>
      </td>
      <td>
        <strong>Metric</strong>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://msdn.microsoft.com/en-us/library/aa373083(VS.85).aspx">Performance Counters</a>
      </td>
      <td>WorkingSetPrivate</td>
    </tr>
    <tr>
      <td>
        <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx">Process Explorer</a>
      </td>
      <td>Physical Memory : Working Set : WS Private</td>
    </tr>
    <tr>
      <td>Task Manager (Windows 7)</td>
      <td>Memory (Private Working Set)</td>
    </tr>
  </table>
</remarks></documentation>
          </property>
          <method name="FromProcess" displayName="FromProcess" id="M:Microsoft.Test.LeakDetection.MemorySnapshot.FromProcess(System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.LeakDetection.MemorySnapshot" id="T:Microsoft.Test.LeakDetection.MemorySnapshot" />
            <documentation><summary> Creates a MemorySnapshot instance for the specified OS process. </summary>
<param name="processId">The ID of the process for which to generate the memory snapshot.</param>
<returns>A MemorySnapshot instance containing memory information for the specified process, at the time of the snapshot.</returns></documentation>
            <parameter name="processId" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="FromFile" displayName="FromFile" id="M:Microsoft.Test.LeakDetection.MemorySnapshot.FromFile(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.LeakDetection.MemorySnapshot" id="T:Microsoft.Test.LeakDetection.MemorySnapshot" />
            <documentation><summary> Creates a MemorySnapshot instance from data in the specified file. </summary>
<param name="filePath">The path to the memory snapshot file.</param>
<returns>A MemorySnapshot instance containing memory information recorded in the specified file.</returns></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
          <method name="ToFile" displayName="ToFile" id="M:Microsoft.Test.LeakDetection.MemorySnapshot.ToFile(System.String)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Writes the current MemorySnapshot to a file. </summary>
<param name="filePath">The path to the output file.</param></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
          <method name="CompareTo" displayName="CompareTo" id="M:Microsoft.Test.LeakDetection.MemorySnapshot.CompareTo(Microsoft.Test.LeakDetection.MemorySnapshot)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.LeakDetection.MemorySnapshot" id="T:Microsoft.Test.LeakDetection.MemorySnapshot" />
            <documentation><summary> Compares the current MemorySnapshot instance to the specified MemorySnapshot to produce a difference. </summary>
<param name="memorySnapshot">The MemorySnapshot to be compared to.</param>
<returns>A new MemorySnapshot object representing the difference between the two memory snapshots (i.e. the result of the comparison).</returns></documentation>
            <parameter name="memorySnapshot" typeId="T:Microsoft.Test.LeakDetection.MemorySnapshot" valueType="false" />
          </method>
        </class>
        <class name="MemorySnapshotCollection" displayName="MemorySnapshotCollection" namespace="Microsoft.Test.LeakDetection" id="T:Microsoft.Test.LeakDetection.MemorySnapshotCollection" access="Public">
          <documentation><summary> A collection of MemorySnapshots that can be serialized to an XML file. </summary>
<example>
  <code>
// Create a memory snapshot collection and add the snapshots to it.
MemorySnapshotCollection c = new MemorySnapshotCollection();     

// Start an instance of the target process and wait for it to reach steady state.
// Then take a memory snapshot.
Process p = Process.Start("notepad.exe");
p.WaitForInputIdle(5000);
MemorySnapshot s1 = MemorySnapshot.FromProcess(p.Id);
c.Add(s1);

// Perform operations that may cause a leak in the target process...
// Then take another second memory snapshot
MemorySnapshot s2 = MemorySnapshot.FromProcess(p.Id);
c.Add(s2);

// Save the collection to a XML file.
c.ToFile(@"C:\mySnapshots.xml");

// Close the process.
p.CloseMainWindow();
p.Close();

</code>
</example>
<example>
  <code>
// Load up a saved collection from a XML file.
MemorySnapshotCollection c = MemorySnapshotCollection.FromFile(@"C:\SampleSnapshots.xml");

</code>
</example></documentation>
          <baseType name="Collection`1" id="T:System.Collections.ObjectModel.Collection`1" displayName="Collection`1" namespace="System.Collections.ObjectModel" assembly="mscorlib">
            <genericargument name="Microsoft.Test.LeakDetection.MemorySnapshot" />
          </baseType>
          <implementsClass type="System.Collections.Generic.IList`1" id="T:System.Collections.Generic.IList`1" displayName="IList(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.ICollection`1" id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.IEnumerable`1" id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.IEnumerable" id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.IList" id="T:System.Collections.IList" displayName="IList" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.ICollection" id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" inherited="true" />
          <constructor name=".ctor" id="M:Microsoft.Test.LeakDetection.MemorySnapshotCollection.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.LeakDetection.MemorySnapshotCollection" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Count" id="P:Microsoft.Test.LeakDetection.MemorySnapshotCollection.Count" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" declaringType="System.Collections.ObjectModel.Collection`1" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <implements name="Count" id="P:System.Collections.ICollection.Count" interface="ICollection" assembly="mscorlib" interfaceId="T:System.Collections.ICollection" declaringType="System.Collections.ICollection" />
          </property>
          <property name="Items" id="P:Microsoft.Test.LeakDetection.MemorySnapshotCollection.Items" access="Family" contract="Normal" typeId="T:System.Collections.Generic.IList`1" valueType="false" declaringType="System.Collections.ObjectModel.Collection`1" get="Family" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="Microsoft.Test.LeakDetection.MemorySnapshot" />
          </property>
          <property name="Item" id="P:Microsoft.Test.LeakDetection.MemorySnapshotCollection.Item(System.Int32)" access="Public" contract="Final" typeId="T:Microsoft.Test.LeakDetection.MemorySnapshot" valueType="false" declaringType="System.Collections.ObjectModel.Collection`1" get="Public" set="Public">
            <documentation><summary></summary></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
            <implements name="Item" id="P:System.Collections.Generic.IList`1.Item(System.Int32)" interface="IList`1" assembly="mscorlib" interfaceId="T:System.Collections.Generic.IList`1" declaringType="System.Collections.Generic.IList`1" />
          </property>
          <method name="FromFile" displayName="FromFile" id="M:Microsoft.Test.LeakDetection.MemorySnapshotCollection.FromFile(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.LeakDetection.MemorySnapshotCollection" id="T:Microsoft.Test.LeakDetection.MemorySnapshotCollection" />
            <documentation><summary> Creates a MemorySnapshotCollection instance from data in the specified file. </summary>
<param name="filePath">The path to the MemorySnapshotCollection file.</param>
<returns>A MemorySnapshotCollection instance, containing memory information recorded in the specified file.</returns></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
          <method name="ToFile" displayName="ToFile" id="M:Microsoft.Test.LeakDetection.MemorySnapshotCollection.ToFile(System.String)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Writes the current MemorySnapshotCollection to a file. </summary>
<param name="filePath">The path to the output file.</param></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.ObjectComparison">
        <class name="GraphNode" displayName="GraphNode" namespace="Microsoft.Test.ObjectComparison" id="T:Microsoft.Test.ObjectComparison.GraphNode" access="Public">
          <documentation><summary> Represents one node in the object graph. The root of the graph is a graph node. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.ObjectComparison.GraphNode.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ObjectComparison.GraphNode" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Name" id="P:Microsoft.Test.ObjectComparison.GraphNode.Name" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> A name to identify this node. When comparing, the left and right nodes are matched by name. </summary></documentation>
          </property>
          <property name="Children" id="P:Microsoft.Test.ObjectComparison.GraphNode.Children" access="Public" contract="Normal" typeId="T:System.Collections.ObjectModel.Collection`1" valueType="false" get="Public" set="false">
            <documentation><summary> Gets the collection of child nodes to this node. The child nodes represent properties or fields on an object. </summary></documentation>
            <genericargument name="Microsoft.Test.ObjectComparison.GraphNode" />
          </property>
          <property name="Parent" id="P:Microsoft.Test.ObjectComparison.GraphNode.Parent" access="Public" contract="Normal" typeId="T:Microsoft.Test.ObjectComparison.GraphNode" valueType="false" get="Public" set="Public">
            <documentation><summary> Represents the immediate parent to this node. The parent node of the root of the graph is null. </summary></documentation>
          </property>
          <property name="ObjectValue" id="P:Microsoft.Test.ObjectComparison.GraphNode.ObjectValue" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> Contains the value of the object represented by this node. </summary></documentation>
          </property>
          <property name="ObjectType" id="P:Microsoft.Test.ObjectComparison.GraphNode.ObjectType" access="Public" contract="Normal" typeId="T:System.Type" valueType="false" get="Public" set="false">
            <documentation><summary> Provides the System.Type of the object represented by this node. Returns null if the object value is null. </summary></documentation>
          </property>
          <property name="Depth" id="P:Microsoft.Test.ObjectComparison.GraphNode.Depth" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Gets the depth of this node from the root. If the depth of the root node is 0, root.child is 1. </summary></documentation>
          </property>
          <property name="QualifiedName" id="P:Microsoft.Test.ObjectComparison.GraphNode.QualifiedName" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="false">
            <documentation><summary> Gets the fully qualified name of this node If the root node has a child that is named child1 and the child has another child that is named child12, qualified name of child12 would be root.child1.child12. </summary></documentation>
          </property>
          <method name="GetNodesInDepthFirstOrder" displayName="GetNodesInDepthFirstOrder" id="M:Microsoft.Test.ObjectComparison.GraphNode.GetNodesInDepthFirstOrder" access="Public" contract="Normal" valueType="false">
            <returnType type="System.Collections.Generic.IEnumerable{Microsoft.Test.ObjectComparison.GraphNode}" id="T:System.Collections.Generic.IEnumerable`1">
              <genericargument name="Microsoft.Test.ObjectComparison.GraphNode" />
            </returnType>
            <documentation><summary> Performs a depth-first traversal of the graph with this node as root, and provides the nodes visited, in that order. </summary>
<returns>Nodes visited in depth-first order.</returns></documentation>
          </method>
        </class>
        <class name="ObjectComparer" displayName="ObjectComparer" namespace="Microsoft.Test.ObjectComparison" id="T:Microsoft.Test.ObjectComparison.ObjectComparer" access="Public" sealed="true">
          <documentation><summary> Represents a generic object comparer. This class uses an <seealso cref="P:Microsoft.Test.ObjectComparison.ObjectComparer.ObjectGraphFactory" /> instance to convert objects to graph representations before comparing the representations. </summary>
<remarks> Comparing two objects for equivalence is a relatively common task during test validation. One example would be to test whether a type follows the rules required by a particular serializer by saving and loading the object and comparing the two. A deep object comparison is one where all the properties and its properties are compared repeatedly until primitives are reached. The .NET Framework provides mechanisms to perform such comparisons but requires the types in question to implement part of the comparison logic (IComparable, .Equals). However, there are often types that do not follow these mechanisms. This API provides a mechanism to deep compare two objects using reflection. </remarks>
<example>
  <p>The following example demonstrates how to compare two objects using a general-purpose object comparison strategy (represented by <see cref="T:Microsoft.Test.ObjectComparison.PublicPropertyObjectGraphFactory" />).</p>
  <code>// create an ObjectGraph factory
ObjectGraphFactory factory = new PublicPropertyObjectGraphFactory();

// instantiate the reusable comparer by passing the factory
ObjectComparer comparer = new ObjectComparer(factory);

// perform the compare operation
bool match = comparer.Compare(obj1, obj2);
if (!match)
{
    Console.WriteLine("The two objects do not match.");
}
</code>
</example>
<example>
  <p>In addition, the object comparison API allows the user to get back a number of comparison mismatches (in the form of <see cref="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatch" /> objects). The following example demonstrates how to do that.</p>
  <code>// create a list to hold the mismatches
IEnumerable&lt;ObjectComparisonMismatch&gt; mismatches = new List&lt;ObjectComparisonMismatch&gt;();
   
// if the objects don't match, print out the mismatches
bool match = comparer.Compare(obj1, obj2, out mismatches);
if (!match)
{ 
    foreach (ObjectComparisonMismatch mismatch in mismatches)
    {
        Console.WriteLine(
            String.Format(
                "Nodes '{0}' and '{1}' do not match. Mismatch message: '{3}'", 
                mismatch.LeftObjectNode.Name,
                mismatch.RightObjectNode.Name,
                mismatch.Description));
    }
}
</code>
</example></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.ObjectComparison.ObjectComparer.#ctor(Microsoft.Test.ObjectComparison.ObjectGraphFactory)" access="Public" contract="Normal">
            <documentation><summary> Creates an instance of the ObjectComparer class. </summary>
<param name="factory">An ObjectGraphFactory to use for converting objects to graphs.</param></documentation>
            <parameter name="factory" typeId="T:Microsoft.Test.ObjectComparison.ObjectGraphFactory" valueType="false" />
          </constructor>
          <property name="ObjectGraphFactory" id="P:Microsoft.Test.ObjectComparison.ObjectComparer.ObjectGraphFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ObjectComparison.ObjectGraphFactory" valueType="false" get="Public" set="false">
            <documentation><summary> Gets the ObjectGraphFactory used to convert objects to graphs. </summary></documentation>
          </property>
          <method name="Compare" displayName="Compare" id="M:Microsoft.Test.ObjectComparison.ObjectComparer.Compare(System.Object,System.Object)" access="Public" contract="Normal" valueType="true" overload="1">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Performs a deep comparison of two objects. </summary>
<param name="leftValue">The left object.</param>
<param name="rightValue">The right object.</param>
<returns>true if the objects match.</returns></documentation>
            <parameter name="leftValue" typeId="T:System.Object" valueType="false" />
            <parameter name="rightValue" typeId="T:System.Object" valueType="false" />
          </method>
          <method name="Compare" displayName="Compare" id="M:Microsoft.Test.ObjectComparison.ObjectComparer.Compare(System.Object,System.Object,System.Collections.Generic.IEnumerable{Microsoft.Test.ObjectComparison.ObjectComparisonMismatch}@)" access="Public" contract="Normal" valueType="true" overload="2">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Performs a deep comparison of two objects and provides a list of mismatching nodes. </summary>
<param name="leftValue">The left object.</param>
<param name="rightValue">The right object.</param>
<param name="mismatches">The list of mismatches.</param>
<returns>true if the objects match.</returns></documentation>
            <parameter name="leftValue" typeId="T:System.Object" valueType="false" />
            <parameter name="rightValue" typeId="T:System.Object" valueType="false" />
            <parameter name="mismatches" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false" direction="out" />
          </method>
        </class>
        <class name="ObjectComparisonMismatch" displayName="ObjectComparisonMismatch" namespace="Microsoft.Test.ObjectComparison" id="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatch" access="Public" sealed="true">
          <documentation><summary> Represents one comparison mismatch. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.ObjectComparison.ObjectComparisonMismatch.#ctor(Microsoft.Test.ObjectComparison.GraphNode,Microsoft.Test.ObjectComparison.GraphNode,Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType)" access="Public" contract="Normal">
            <documentation><summary> Creates an instance of the ObjectComparisonMismatch class. </summary>
<param name="leftObjectNode">The node from the left object.</param>
<param name="rightObjectNode">The node from the right object.</param>
<param name="mismatchType">Represents the type of mismatch.</param></documentation>
            <parameter name="leftObjectNode" typeId="T:Microsoft.Test.ObjectComparison.GraphNode" valueType="false" />
            <parameter name="rightObjectNode" typeId="T:Microsoft.Test.ObjectComparison.GraphNode" valueType="false" />
            <parameter name="mismatchType" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" />
          </constructor>
          <property name="LeftObjectNode" id="P:Microsoft.Test.ObjectComparison.ObjectComparisonMismatch.LeftObjectNode" access="Public" contract="Normal" typeId="T:Microsoft.Test.ObjectComparison.GraphNode" valueType="false" get="Public" set="false">
            <documentation><summary> Gets the node in the left object. </summary></documentation>
          </property>
          <property name="RightObjectNode" id="P:Microsoft.Test.ObjectComparison.ObjectComparisonMismatch.RightObjectNode" access="Public" contract="Normal" typeId="T:Microsoft.Test.ObjectComparison.GraphNode" valueType="false" get="Public" set="false">
            <documentation><summary> Gets the node in the right object. </summary></documentation>
          </property>
          <property name="MismatchType" id="P:Microsoft.Test.ObjectComparison.ObjectComparisonMismatch.MismatchType" access="Public" contract="Normal" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" get="Public" set="false">
            <documentation><summary> Represents the type of mismatch. </summary></documentation>
          </property>
        </class>
        <class name="ObjectGraphFactory" displayName="ObjectGraphFactory" namespace="Microsoft.Test.ObjectComparison" id="T:Microsoft.Test.ObjectComparison.ObjectGraphFactory" access="Public" abstract="true">
          <documentation><summary> Creates a graph for the provided object. </summary></documentation>
          <derivedBy id="T:Microsoft.Test.ObjectComparison.PublicPropertyObjectGraphFactory" displayName="PublicPropertyObjectGraphFactory" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ObjectComparison.ObjectGraphFactory.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ObjectComparison.ObjectGraphFactory" /> class.</summary>
            </documentation>
          </constructor>
          <method name="CreateObjectGraph" displayName="CreateObjectGraph" id="M:Microsoft.Test.ObjectComparison.ObjectGraphFactory.CreateObjectGraph(System.Object)" access="Public" contract="Virtual" valueType="false">
            <returnType type="Microsoft.Test.ObjectComparison.GraphNode" id="T:Microsoft.Test.ObjectComparison.GraphNode" />
            <documentation><summary> Creates a graph for the given object. </summary>
<param name="value">The object to convert.</param>
<returns>The root node of the created graph.</returns></documentation>
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </method>
        </class>
        <class name="PublicPropertyObjectGraphFactory" displayName="PublicPropertyObjectGraphFactory" namespace="Microsoft.Test.ObjectComparison" id="T:Microsoft.Test.ObjectComparison.PublicPropertyObjectGraphFactory" access="Public" sealed="true">
          <documentation><summary> Creates a graph by extracting public instance properties in the object. If the property is an IEnumerable, extract the items. If an exception is thrown when accessing a property on the left object, it is considered a match if the same exception type is thrown when accessing the property on the right object. </summary></documentation>
          <baseType name="ObjectGraphFactory" id="T:Microsoft.Test.ObjectComparison.ObjectGraphFactory" displayName="ObjectGraphFactory" namespace="Microsoft.Test.ObjectComparison" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.ObjectComparison.PublicPropertyObjectGraphFactory.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ObjectComparison.PublicPropertyObjectGraphFactory" /> class.</summary>
            </documentation>
          </constructor>
          <method name="CreateObjectGraph" displayName="CreateObjectGraph" id="M:Microsoft.Test.ObjectComparison.PublicPropertyObjectGraphFactory.CreateObjectGraph(System.Object)" access="Public" contract="Override" valueType="false">
            <returnType type="Microsoft.Test.ObjectComparison.GraphNode" id="T:Microsoft.Test.ObjectComparison.GraphNode" />
            <documentation><summary> Creates a graph for the given object by extracting public properties. </summary>
<param name="value">The object to convert.</param>
<returns>The root node of the created graph.</returns></documentation>
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </method>
        </class>
        <enumeration name="ObjectComparisonMismatchType" id="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" displayName="ObjectComparisonMismatchType" namespace="Microsoft.Test.ObjectComparison" access="Public">
          <documentation><summary> Represents the type of mismatch. </summary></documentation>
          <field name="MissingRightNode" id="F:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType.MissingRightNode" access="Public" contract="Static" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" literal="true" value="0">
            <documentation><summary> The node is missing in the right graph. </summary></documentation>
          </field>
          <field name="MissingLeftNode" id="F:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType.MissingLeftNode" access="Public" contract="Static" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" literal="true" value="1">
            <documentation><summary> The node is missing in the left graph. </summary></documentation>
          </field>
          <field name="RightNodeHasFewerChildren" id="F:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType.RightNodeHasFewerChildren" access="Public" contract="Static" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" literal="true" value="2">
            <documentation><summary> The right node has fewer children than the left node. </summary></documentation>
          </field>
          <field name="LeftNodeHasFewerChildren" id="F:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType.LeftNodeHasFewerChildren" access="Public" contract="Static" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" literal="true" value="3">
            <documentation><summary> The left node has fewer children than the right node. </summary></documentation>
          </field>
          <field name="ObjectTypesDoNotMatch" id="F:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType.ObjectTypesDoNotMatch" access="Public" contract="Static" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" literal="true" value="4">
            <documentation><summary> The node types do not match. </summary></documentation>
          </field>
          <field name="ObjectValuesDoNotMatch" id="F:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType.ObjectValuesDoNotMatch" access="Public" contract="Static" typeId="T:Microsoft.Test.ObjectComparison.ObjectComparisonMismatchType" valueType="true" literal="true" value="5">
            <documentation><summary> The node values do not match. </summary></documentation>
          </field>
        </enumeration>
      </namespace>
      <namespace name="Microsoft.Test.VariationGeneration">
        <class name="Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Constraint" access="Public" abstract="true">
          <documentation><summary> Represents a relationship between parameters, their values or other constraints. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, tests every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. Ideally all parameters in a model are independent but this is generally not the case. Constraints define combinations of values that are impossible in the variations produced by the <see cref="T:Microsoft.Test.VariationGeneration.Model" /> using combinatorial testing techniques. </remarks></documentation>
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" displayName="IfThenConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraint.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraint" /> class.</summary>
            </documentation>
          </constructor>
        </class>
        <class name="Model" displayName="Model" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Model" access="Public">
          <documentation><summary> Contains all the parameters and constraints for the system under test and produces a set of variations using combinatorial test techniques. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, tests every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. </remarks>
<example>
  <p> The following example demonstrates creating variations for a vacation planner with a signature like this: CallVacationPlanner(string destination, int hotelQuality, string activity). It demonstrates that certain activities are only available for certain destinations. </p>
  <code>            Parameter destination = 
                new Parameter("Destination") { "Whistler", "Hawaii", "Las Vegas" };

            Parameter hotelQuality = 
                new Parameter("Hotel Quality") { 5, 4, 3, 2, 1 };

            Parameter activity = 
               new Parameter("Activity") { "gambling", "swimming", "shopping", "skiing" };

            List&lt;Parameter&gt; parameters = new List&lt;Parameter&gt; { destination, hotelQuality, activity };
            List&lt;Constraint&gt; constraints = new List&lt;Constraint&gt;
            {
                new IfThenConstraint
                {
                    If = destination.Equal("Whistler").Or(destination.Equal("Hawaii")),
                    Then = activity.NotEqual("gambling")                        
                },
                new IfThenConstraint
                {
                    If = destination.Equal("Las Vegas").Or(destination.Equal("Hawaii")),
                    Then = activity.NotEqual("skiing")
                },
                new IfThenConstraint
                {
                    If = destination.Equal("Whistler"),
                    Then = activity.NotEqual("swimming")
                },
            };

            Model model = new Model(parameters, constraints);

            // call the method under test with each generated variation
            foreach (var variation in model.GenerateVariations())
            {
                CallVacationPlanner(
                    (string)variation[destination.Name], 
                    (int)variation[hotelQuality.Name], 
                    (string)variation[activity.Name]);
            }
</code>
</example>
<example>
  <p> The following example demonstrates creating variations for a vacation planner that adds weights and tags to certain values. Adding weights changes the frequency a value will occur. Adding tags allows expected values to be added to variations. </p>
  <code>            Parameter destination = 
                new Parameter("Destination") 
                { 
                    "Whistler", 
                    "Hawaii",
                    // specify that Las Vegas should be emphasized
                    new ParameterValue("Las Vegas") { Weight = 5.0 },
                    // specify the expected result when Cleveland is specified
                    new ParameterValue("Cleveland") { Tag = false }
                };

            Parameter hotelQuality = 
                new Parameter("Hotel Quality") { 5, 4, 3, 2, 1 };

            Parameter activity = 
                new Parameter("Activity") { "gambling", "swimming", "shopping", "skiing" };

            Parameter parameters = new List&lt;Parameter&gt; { destination, hotelQuality, activity };

            Model model = new Model(parameters) { DefaultVariationTag = true };

            foreach (var variation in model.GenerateVariations(2))
            {
                if (CallVacationPlanner(
                        (string)variation[destination.Name],
                        (int)variation[hotelQuality.Name],
                        (string)variation[activity.Name]) != (bool)variation.Tag)
                {
                    Console.WriteLine("Variation failed.");
                }
            }
</code>
</example></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Model.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Parameter})" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new model with the specified parameters. </summary>
<param name="parameters">The parameters.</param></documentation>
            <parameter name="parameters" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.VariationGeneration.Parameter" />
            </parameter>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Model.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Parameter},System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Constraint})" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new model with the specified parameters and constraints. </summary>
<param name="parameters">The parameters.</param>
<param name="constraints">The constraints.</param></documentation>
            <parameter name="parameters" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.VariationGeneration.Parameter" />
            </parameter>
            <parameter name="constraints" typeId="T:System.Collections.Generic.IEnumerable`1" valueType="false">
              <genericargument name="Microsoft.Test.VariationGeneration.Constraint" />
            </parameter>
          </constructor>
          <property name="Parameters" id="P:Microsoft.Test.VariationGeneration.Model.Parameters" access="Public" contract="Normal" typeId="T:System.Collections.Generic.IList`1" valueType="false" get="Public" set="false">
            <documentation><summary> The parameters in the model. </summary></documentation>
            <genericargument name="Microsoft.Test.VariationGeneration.Parameter" />
          </property>
          <property name="Constraints" id="P:Microsoft.Test.VariationGeneration.Model.Constraints" access="Public" contract="Normal" typeId="T:System.Collections.Generic.ICollection`1" valueType="false" get="Public" set="false">
            <documentation><summary> The constraints in the model. </summary></documentation>
            <genericargument name="Microsoft.Test.VariationGeneration.Constraint" />
          </property>
          <property name="DefaultVariationTag" id="P:Microsoft.Test.VariationGeneration.Model.DefaultVariationTag" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> The default tag on generated variations, set when no value in the variation has been tagged. Default is null. </summary></documentation>
          </property>
          <method name="GenerateVariations" displayName="GenerateVariations" id="M:Microsoft.Test.VariationGeneration.Model.GenerateVariations(System.Int32)" access="Public" contract="Virtual" valueType="false" overload="1">
            <returnType type="System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Variation}" id="T:System.Collections.Generic.IEnumerable`1">
              <genericargument name="Microsoft.Test.VariationGeneration.Variation" />
            </returnType>
            <documentation><summary> Generate an order-wise set of variations using a constant seed. </summary>
<param name="order">The order or the combinations selected (2 is every pair, 3 is every triple, etc). Must be between 1 and the number of parameters.</param>
<returns>The variations.</returns></documentation>
            <parameter name="order" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="GenerateVariations" displayName="GenerateVariations" id="M:Microsoft.Test.VariationGeneration.Model.GenerateVariations(System.Int32,System.Int32)" access="Public" contract="Virtual" valueType="false" overload="2">
            <returnType type="System.Collections.Generic.IEnumerable{Microsoft.Test.VariationGeneration.Variation}" id="T:System.Collections.Generic.IEnumerable`1">
              <genericargument name="Microsoft.Test.VariationGeneration.Variation" />
            </returnType>
            <documentation><summary> Generate and order-wise set of variations using the specified seed for random generation. </summary>
<param name="order">The order or the combinations selected (2 is every pair, 3 is every triple, etc). Must be between 1 and the number of parameters.</param>
<param name="seed">The seed used for random generation.</param>
<returns>The variations.</returns></documentation>
            <parameter name="order" typeId="T:System.Int32" valueType="true" />
            <parameter name="seed" typeId="T:System.Int32" valueType="true" />
          </method>
        </class>
        <class name="Parameter" displayName="Parameter" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Parameter" access="Public">
          <documentation><summary> Represents a single variable and its values in the model. Combinations of these values are used in the combinatorial generation of variations by the <see cref="T:Microsoft.Test.VariationGeneration.Model" />. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, tests every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. </remarks></documentation>
          <implementsClass type="System.Collections.Generic.IList`1" id="T:System.Collections.Generic.IList`1" displayName="IList(T)" namespace="System.Collections.Generic">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.ICollection`1" id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.IEnumerable`1" id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.IEnumerable" id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Parameter.#ctor(System.String)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the parameter class using the specified name. </summary>
<param name="name">The name of the parameter</param></documentation>
            <parameter name="name" typeId="T:System.String" valueType="false" />
          </constructor>
          <property name="Name" id="P:Microsoft.Test.VariationGeneration.Parameter.Name" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> The name of the parameter. </summary></documentation>
          </property>
          <property name="Count" id="P:Microsoft.Test.VariationGeneration.Parameter.Count" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> The number of values in the parameter. </summary></documentation>
            <implements name="Count" id="P:System.Collections.Generic.ICollection`1.Count" interface="ICollection`1" assembly="mscorlib" interfaceId="T:System.Collections.Generic.ICollection`1" declaringType="System.Collections.Generic.ICollection`1" />
          </property>
          <property name="IsReadOnly" id="P:Microsoft.Test.VariationGeneration.Parameter.IsReadOnly" access="Public" contract="Final" typeId="T:System.Boolean" valueType="true" get="Public" set="false">
            <documentation><summary> Whether values can be added or removed from the parameter. </summary></documentation>
            <implements name="IsReadOnly" id="P:System.Collections.Generic.ICollection`1.IsReadOnly" interface="ICollection`1" assembly="mscorlib" interfaceId="T:System.Collections.Generic.ICollection`1" declaringType="System.Collections.Generic.ICollection`1" />
          </property>
          <property name="Item" id="P:Microsoft.Test.VariationGeneration.Parameter.Item(System.Int32)" access="Public" contract="Final" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> The value at the specified index. </summary>
<param name="index">The index of the value.</param>
<returns>The value at the index.</returns></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
            <implements name="Item" id="P:System.Collections.Generic.IList`1.Item(System.Int32)" interface="IList`1" assembly="mscorlib" interfaceId="T:System.Collections.Generic.IList`1" declaringType="System.Collections.Generic.IList`1" />
          </property>
          <method name="Add" displayName="Add" id="M:Microsoft.Test.VariationGeneration.Parameter.Add(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Adds a value to the parameter. </summary>
<param name="item">The value to add</param></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Add" id="M:System.Collections.Generic.ICollection`1.Add(System.Object)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Clear" displayName="Clear" id="M:Microsoft.Test.VariationGeneration.Parameter.Clear" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Removes all values from the parameter. </summary></documentation>
            <implements name="Clear" id="M:System.Collections.Generic.ICollection`1.Clear" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Contains" displayName="Contains" id="M:Microsoft.Test.VariationGeneration.Parameter.Contains(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Checks whether the parameter has the specified value. </summary>
<param name="item">The value to search for.</param>
<returns>Whether the value was found.</returns></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Contains" id="M:System.Collections.Generic.ICollection`1.Contains(System.Object)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="CopyTo" displayName="CopyTo" id="M:Microsoft.Test.VariationGeneration.Parameter.CopyTo(System.Object[],System.Int32)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Copies the values into the specified array. </summary>
<param name="array">The target array.</param>
<param name="arrayIndex">The zero-based index in array at which copying begins.</param></documentation>
            <parameter name="array" typeId="T:System.Object" valueType="false" />
            <parameter name="arrayIndex" typeId="T:System.Int32" valueType="true" />
            <implements name="CopyTo" id="M:System.Collections.Generic.ICollection`1.CopyTo(System.Object[],System.Int32)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Remove" displayName="Remove" id="M:Microsoft.Test.VariationGeneration.Parameter.Remove(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Boolean" id="T:System.Boolean" />
            <documentation><summary> Removes the specified value from the parameter if found. </summary>
<param name="item">The value to remove.</param>
<returns>Whether the value was found and removed.</returns></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Remove" id="M:System.Collections.Generic.ICollection`1.Remove(System.Object)" interface="ICollection`1" interfaceId="T:System.Collections.Generic.ICollection`1" assembly="mscorlib" declaringType="System.Collections.Generic.ICollection`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="GetEnumerator" displayName="GetEnumerator" id="M:Microsoft.Test.VariationGeneration.Parameter.GetEnumerator" access="Public" contract="Final" valueType="false">
            <returnType type="System.Collections.Generic.IEnumerator{System.Object}" id="T:System.Collections.Generic.IEnumerator`1">
              <genericargument name="System.Object" />
            </returnType>
            <documentation><summary> Gets an enumerator over the values in the parameter. </summary>
<returns>The enumerator.</returns></documentation>
            <implements name="GetEnumerator" id="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" interface="IEnumerable`1" interfaceId="T:System.Collections.Generic.IEnumerable`1" assembly="mscorlib" declaringType="System.Collections.Generic.IEnumerable`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="IndexOf" displayName="IndexOf" id="M:Microsoft.Test.VariationGeneration.Parameter.IndexOf(System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Int32" id="T:System.Int32" />
            <documentation><summary> Determines the index of the value in the parameter. </summary>
<param name="item">The value to find.</param>
<returns>The index of the value if found, otherwise -1.</returns></documentation>
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="IndexOf" id="M:System.Collections.Generic.IList`1.IndexOf(System.Object)" interface="IList`1" interfaceId="T:System.Collections.Generic.IList`1" assembly="mscorlib" declaringType="System.Collections.Generic.IList`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="Insert" displayName="Insert" id="M:Microsoft.Test.VariationGeneration.Parameter.Insert(System.Int32,System.Object)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Inserts a value at the specified index. </summary>
<param name="index">The zero-based index where the value should be inserted.</param>
<param name="item">The value to insert.</param></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
            <parameter name="item" typeId="T:System.Object" valueType="false" />
            <implements name="Insert" id="M:System.Collections.Generic.IList`1.Insert(System.Int32,System.Object)" interface="IList`1" interfaceId="T:System.Collections.Generic.IList`1" assembly="mscorlib" declaringType="System.Collections.Generic.IList`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
          <method name="RemoveAt" displayName="RemoveAt" id="M:Microsoft.Test.VariationGeneration.Parameter.RemoveAt(System.Int32)" access="Public" contract="Final" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Removes a value at the specified index. </summary>
<param name="index">The zero-based index of the value to remove.</param></documentation>
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
            <implements name="RemoveAt" id="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" interface="IList`1" interfaceId="T:System.Collections.Generic.IList`1" assembly="mscorlib" declaringType="System.Collections.Generic.IList`1[[System.Object, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]" />
          </method>
        </class>
        <class name="ParameterValue" displayName="ParameterValue" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.ParameterValue" access="Public">
          <documentation><summary> Represents a single value in a parameter. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.ParameterValue.#ctor(System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new value with the specified value. </summary>
<param name="value">The value.</param></documentation>
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.ParameterValue.#ctor(System.Object,System.Object)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new value with the specified value and an expected result. </summary>
<param name="value">The value.</param>
<param name="tag">A user defined tag.</param></documentation>
            <parameter name="value" typeId="T:System.Object" valueType="false" />
            <parameter name="tag" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.ParameterValue.#ctor(System.Object,System.Double)" access="Public" contract="Normal" overload="3">
            <documentation><summary> Initializes a new value with the specified value and weight. </summary>
<param name="value">The value.</param>
<param name="weight">The weight of the value.</param></documentation>
            <parameter name="value" typeId="T:System.Object" valueType="false" />
            <parameter name="weight" typeId="T:System.Double" valueType="true" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.ParameterValue.#ctor(System.Object,System.Object,System.Double)" access="Public" contract="Normal" overload="4">
            <documentation><summary> Initializes a new value with the specified value, a tag, and weight. </summary>
<param name="value">The value</param>
<param name="tag">A user defined tag.</param>
<param name="weight">The weight of the value.</param></documentation>
            <parameter name="value" typeId="T:System.Object" valueType="false" />
            <parameter name="tag" typeId="T:System.Object" valueType="false" />
            <parameter name="weight" typeId="T:System.Double" valueType="true" />
          </constructor>
          <property name="Value" id="P:Microsoft.Test.VariationGeneration.ParameterValue.Value" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> The actual value. </summary></documentation>
          </property>
          <property name="Tag" id="P:Microsoft.Test.VariationGeneration.ParameterValue.Tag" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="Public">
            <documentation><summary> Tags the value with a user defined expected result. At most one tagged value will appear in a variation. The default is null. </summary></documentation>
          </property>
          <property name="Weight" id="P:Microsoft.Test.VariationGeneration.ParameterValue.Weight" access="Public" contract="Normal" typeId="T:System.Double" valueType="true" get="Public" set="Public">
            <documentation><summary> A value indicating whether this value should be chosen more or less frequently. Larger values will be chosen more often. The default is 1.0. </summary>
<remarks> Weighting creates preferences for certain values. Due to the nature of the algorithm used, the actual weight value has no intrinsic meaning (weighting one value at 10.0 and the others at 1.0 doesn’t mean it will appear 10x more often). The primary goal of the algorithm is to cover all the combinations with fewest test cases possible which often runs counter to honoring the weight. Weight acts a tie breaker when candidate values cover the same number of combinations. </remarks></documentation>
          </property>
        </class>
        <class name="Variation" displayName="Variation" namespace="Microsoft.Test.VariationGeneration" id="T:Microsoft.Test.VariationGeneration.Variation" access="Public">
          <documentation><summary> Represents a tuple with a single value for every <see cref="T:Microsoft.Test.VariationGeneration.Parameter" /> in the <see cref="T:Microsoft.Test.VariationGeneration.Model" />. The Model produces these using combinatorial test techniques. </summary>
<remarks> Exhaustively testing all possible inputs to any nontrivial software component is generally impossible due to the enormous number of variations. Combinatorial testing is one approach to achieve high coverage with a much smaller set of variations. Pairwise, the most common combinatorial strategy, test every possible pair of values. Higher orders of combinations (3-wise, 4-wise, etc.) can also be used for higher coverage at the expense of more variations. See <a href="http://pairwise.org">Pairwise Testing</a> and <a href="http://www.pairwise.org/docs/pnsqc2006/PNSQC%20140%20-%20Jacek%20Czerwonka%20-%20Pairwise%20Testing%20-%20BW.pdf"> Pairwise Testing in Real World</a> for more resources. </remarks></documentation>
          <baseType name="Dictionary`2" id="T:System.Collections.Generic.Dictionary`2" displayName="Dictionary`2" namespace="System.Collections.Generic" assembly="mscorlib">
            <genericargument name="System.String" />
            <genericargument name="System.Object" />
          </baseType>
          <implementsClass type="System.Collections.Generic.IDictionary`2" id="T:System.Collections.Generic.IDictionary`2" displayName="IDictionary(TKey,TValue)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="TKey" />
            <genericargument name="TValue" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.ICollection`1" id="T:System.Collections.Generic.ICollection`1" displayName="ICollection(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.Generic.IEnumerable`1" id="T:System.Collections.Generic.IEnumerable`1" displayName="IEnumerable(T)" namespace="System.Collections.Generic" inherited="true">
            <genericargument name="T" />
          </implementsClass>
          <implementsClass type="System.Collections.IEnumerable" id="T:System.Collections.IEnumerable" displayName="IEnumerable" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.IDictionary" id="T:System.Collections.IDictionary" displayName="IDictionary" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Collections.ICollection" id="T:System.Collections.ICollection" displayName="ICollection" namespace="System.Collections" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.ISerializable" id="T:System.Runtime.Serialization.ISerializable" displayName="ISerializable" namespace="System.Runtime.Serialization" inherited="true" />
          <implementsClass type="System.Runtime.Serialization.IDeserializationCallback" id="T:System.Runtime.Serialization.IDeserializationCallback" displayName="IDeserializationCallback" namespace="System.Runtime.Serialization" inherited="true" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Variation.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new Variation. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Variation.#ctor(System.Object)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new Variation with the specified expected result. </summary>
<param name="tag">Whether this variation contains a user defined tag.</param></documentation>
            <parameter name="tag" typeId="T:System.Object" valueType="false" />
          </constructor>
          <property name="Tag" id="P:Microsoft.Test.VariationGeneration.Variation.Tag" access="Public" contract="Normal" typeId="T:System.Object" valueType="false" get="Public" set="Private">
            <documentation><summary> Indicates if one of the values has been tagged with an expected result. The default is null. </summary></documentation>
          </property>
          <property name="Comparer" id="P:Microsoft.Test.VariationGeneration.Variation.Comparer" access="Public" contract="Normal" typeId="T:System.Collections.Generic.IEqualityComparer`1" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
          </property>
          <property name="Count" id="P:Microsoft.Test.VariationGeneration.Variation.Count" access="Public" contract="Final" typeId="T:System.Int32" valueType="true" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <implements name="Count" id="P:System.Collections.ICollection.Count" interface="ICollection" assembly="mscorlib" interfaceId="T:System.Collections.ICollection" declaringType="System.Collections.ICollection" />
          </property>
          <property name="Keys" id="P:Microsoft.Test.VariationGeneration.Variation.Keys" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.KeyCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.Object" />
          </property>
          <property name="Values" id="P:Microsoft.Test.VariationGeneration.Variation.Values" access="Public" contract="Normal" typeId="T:System.Collections.Generic.Dictionary`2.ValueCollection" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="false">
            <documentation><summary></summary></documentation>
            <genericargument name="System.String" />
            <genericargument name="System.Object" />
          </property>
          <property name="Item" id="P:Microsoft.Test.VariationGeneration.Variation.Item(System.String)" access="Public" contract="Final" typeId="T:System.Object" valueType="false" declaringType="System.Collections.Generic.Dictionary`2" get="Public" set="Public">
            <documentation><summary></summary></documentation>
            <parameter name="key" typeId="T:System.String" valueType="false" />
            <implements name="Item" id="P:System.Collections.Generic.IDictionary`2.Item(System.String)" interface="IDictionary`2" assembly="mscorlib" interfaceId="T:System.Collections.Generic.IDictionary`2" declaringType="System.Collections.Generic.IDictionary`2" />
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.VariationGeneration.Constraints">
        <class name="ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" access="Public" abstract="true">
          <documentation><summary> Represents a relationship that evaluates to a boolean, such as "and", "or", or "equals." </summary></documentation>
          <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" displayName="AndConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" displayName="EqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" displayName="GreaterThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" displayName="GreaterThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" displayName="LessThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" displayName="LessThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" displayName="NotConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" displayName="NotEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" displayName="OrConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" /> class.</summary>
            </documentation>
          </constructor>
        </class>
        <class name="AndConstraint" displayName="AndConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" access="Public">
          <documentation><summary> Represents an "and" relationship between two conditions. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.AndConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="First" id="P:Microsoft.Test.VariationGeneration.Constraints.AndConstraint.First" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The first condition. </summary></documentation>
          </property>
          <property name="Second" id="P:Microsoft.Test.VariationGeneration.Constraints.AndConstraint.Second" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The second condition. </summary></documentation>
          </property>
        </class>
        <class name="EqualConstraint" displayName="EqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" access="Public">
          <documentation><summary> Represents an equality condition between either a parameter and a value or two parameters. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the EqualConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the EqualConstraint class using the specified parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="ConstraintHelpers" displayName="ConstraintHelpers" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers" access="Public" static="true">
          <documentation><summary> A collection of methods to help create constraints. </summary></documentation>
          <method name="And" displayName="And" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.And(Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint,Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.AndConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.AndConstraint" />
            <documentation><summary> Creates an AndConstraint between two ConditionConstraints. </summary>
<param name="first">The first condition.</param>
<param name="second">The second condition.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
          </method>
          <method name="Equal" displayName="Equal" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Equal(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" />
            <documentation><summary> Creates an EqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="Equal" displayName="Equal" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Equal(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.EqualConstraint" />
            <documentation><summary> Creates an EqualConstraint between two parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="GreaterThan" displayName="GreaterThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThan(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" />
            <documentation><summary> Creates an EqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="GreaterThan" displayName="GreaterThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThan(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" />
            <documentation><summary> Creates a GreaterThanConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="GreaterThanOrEqual" displayName="GreaterThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" />
            <documentation><summary> Creates an GreaterThanOrEqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="GreaterThanOrEqual" displayName="GreaterThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.GreaterThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" />
            <documentation><summary> Creates a GreaterThanOrEqualConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="LessThan" displayName="LessThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThan(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" />
            <documentation><summary> Creates a LessThanConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="LessThan" displayName="LessThan" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThan(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" />
            <documentation><summary> Creates a LessThanConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="LessThanOrEqual" displayName="LessThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" />
            <documentation><summary> Creates a LessThanOrEqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="LessThanOrEqual" displayName="LessThanOrEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.LessThanOrEqual(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" />
            <documentation><summary> Creates an EqualConstraint between two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="Not" displayName="Not" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Not(Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.NotConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" />
            <documentation><summary> Creates a NotConstraint on the given condition. </summary>
<param name="condition">The condition to negate.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="condition" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
          </method>
          <method name="NotEqual" displayName="NotEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.NotEqual(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Static" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" />
            <documentation><summary> Creates a NotEqualConstraint between a parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="value" typeId="T:System.Object" valueType="false" extension="true" />
          </method>
          <method name="NotEqual" displayName="NotEqual" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.NotEqual(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Static" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" />
            <documentation><summary> Creates a NotEqualConstraint between 2 parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" extension="true" />
          </method>
          <method name="Or" displayName="Or" id="M:Microsoft.Test.VariationGeneration.Constraints.ConstraintHelpers.Or(Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint,Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VariationGeneration.Constraints.OrConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" />
            <documentation><summary> Creates an OrConstraint between two ConditionConstraints. </summary>
<param name="first">The first condition.</param>
<param name="second">The second condition.</param>
<returns>The constraint.</returns></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" extension="true" />
          </method>
        </class>
        <class name="GreaterThanConstraint" displayName="GreaterThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint" access="Public">
          <documentation><summary> Represents a greater-than condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the GreaterThanConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the GreaterThanConstraint class using the specified parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="GreaterThanOrEqualConstraint" displayName="GreaterThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint" access="Public">
          <documentation><summary> Represents a greater-than-or-equal condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the GreaterThanOrEqualConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.GreaterThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the GreaterThanOrEqualConstraint using two parameters. </summary>
<param name="left"> The left parameter.</param>
<param name="right">The right parameter.</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="IfThenConstraint" displayName="IfThenConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" access="Public">
          <documentation><summary> Represents an implication between two constraints. </summary></documentation>
          <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="If" id="P:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint.If" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The condition to test. </summary></documentation>
          </property>
          <property name="Then" id="P:Microsoft.Test.VariationGeneration.Constraints.IfThenConstraint.Then" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The implied result of the test. </summary></documentation>
          </property>
        </class>
        <class name="LessThanConstraint" displayName="LessThanConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint" access="Public">
          <documentation><summary> Represents a less-than condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the LessThanConstraint class using the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the LessThanConstraint class using the specified parameters. </summary>
<param name="left"> The left side</param>
<param name="right">The right side</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="LessThanOrEqualConstraint" displayName="LessThanOrEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint" access="Public">
          <documentation><summary> Represents a less-than-or-equal condition between either a parameter and a value or two parameters. </summary>
<remarks> All values must implement IComparable. </remarks></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the LessThanOrEqualConstraint class the specified parameter and value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.LessThanOrEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the LessThanOrEqualConstraint class the specified parameters. </summary>
<param name="left"> The first parameter</param>
<param name="right">The second parameter</param></documentation>
            <parameter name="left" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="right" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="NotConstraint" displayName="NotConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" access="Public">
          <documentation><summary> Negates the inner condition. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.NotConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.NotConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="Condition" id="P:Microsoft.Test.VariationGeneration.Constraints.NotConstraint.Condition" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The condition to negate. </summary></documentation>
          </property>
        </class>
        <class name="NotEqualConstraint" displayName="NotEqualConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint" access="Public">
          <documentation><summary> Represents an inequality condition between either a parameter and a value or two parameters. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,System.Object)" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the NotEqualConstraint class using the specified parameter and a value. </summary>
<param name="parameter">The parameter.</param>
<param name="value">The value.</param></documentation>
            <parameter name="parameter" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="value" typeId="T:System.Object" valueType="false" />
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.NotEqualConstraint.#ctor(Microsoft.Test.VariationGeneration.Parameter,Microsoft.Test.VariationGeneration.Parameter)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the NotEqualConstraint class using the specified parameters. </summary>
<param name="first"> The first parameter.</param>
<param name="second">The second parameter.</param></documentation>
            <parameter name="first" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
            <parameter name="second" typeId="T:Microsoft.Test.VariationGeneration.Parameter" valueType="false" />
          </constructor>
        </class>
        <class name="OrConstraint" displayName="OrConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" id="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" access="Public">
          <documentation><summary> Represents an "or" relationship between two conditions. </summary></documentation>
          <baseType name="ConditionConstraint" id="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" displayName="ConditionConstraint" namespace="Microsoft.Test.VariationGeneration.Constraints" assembly="TestApiCore">
            <baseType name="Constraint" id="T:Microsoft.Test.VariationGeneration.Constraint" displayName="Constraint" namespace="Microsoft.Test.VariationGeneration" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.VariationGeneration.Constraints.OrConstraint.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VariationGeneration.Constraints.OrConstraint" /> class.</summary>
            </documentation>
          </constructor>
          <property name="First" id="P:Microsoft.Test.VariationGeneration.Constraints.OrConstraint.First" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The first condition. </summary></documentation>
          </property>
          <property name="Second" id="P:Microsoft.Test.VariationGeneration.Constraints.OrConstraint.Second" access="Public" contract="Normal" typeId="T:Microsoft.Test.VariationGeneration.Constraints.ConditionConstraint" valueType="false" get="Public" set="Public">
            <documentation><summary> The second condition. </summary></documentation>
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.VisualVerification">
        <class name="ColorDifference" displayName="ColorDifference" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.ColorDifference" access="Public">
          <documentation><summary> Represents the per-channel difference between two colors. </summary></documentation>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.ColorDifference.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the ColorDifference class using values of zero, indicating no difference. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.ColorDifference.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the ColorDifference class, using the specified alpha, red, green and blue values. </summary>
<param name="alpha">The alpha (transparency) color channel difference.</param>
<param name="red">The red color channel difference.</param>
<param name="green">The green color channel difference.</param>
<param name="blue">The blue color channel difference.</param></documentation>
            <parameter name="alpha" typeId="T:System.Byte" valueType="true" />
            <parameter name="red" typeId="T:System.Byte" valueType="true" />
            <parameter name="green" typeId="T:System.Byte" valueType="true" />
            <parameter name="blue" typeId="T:System.Byte" valueType="true" />
          </constructor>
          <property name="A" id="P:Microsoft.Test.VisualVerification.ColorDifference.A" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Alpha (transparency) color channel difference. </summary></documentation>
          </property>
          <property name="R" id="P:Microsoft.Test.VisualVerification.ColorDifference.R" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Red color channel difference. </summary></documentation>
          </property>
          <property name="G" id="P:Microsoft.Test.VisualVerification.ColorDifference.G" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Green color channel difference. </summary></documentation>
          </property>
          <property name="B" id="P:Microsoft.Test.VisualVerification.ColorDifference.B" access="Public" contract="Normal" typeId="T:System.Byte" valueType="true" get="Public" set="Public">
            <documentation><summary> Blue color channel difference. </summary></documentation>
          </property>
        </class>
        <class name="Histogram" displayName="Histogram" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.Histogram" access="Public">
          <documentation><summary> The Histogram class represents a histogram curve, expressed in terms of frequency (proportion of total pixels) over brightness (from 0 to 255). In other words, the Histogram class represents the percentage (proportion) of pixels that have brightness of 0, 1, etc. <a href="http://en.wikipedia.org/wiki/Image_histogram">This page</a> provides a good introduction to <i>image histograms</i>. <p /> For testing purposes "brightness" is often equated to "difference". Thus, one is able to construct a "difference histogram" from a "difference shapshot" and compare that histogram to a histogram of "expected maximum differences" (also knows as a "tolerance histogram") in order to determine whether a visual verification test passes or fails. <p /> A Histogram object can be loaded from a XML file or generated from a Snapshot object. </summary></documentation>
          <property name="Item" id="P:Microsoft.Test.VisualVerification.Histogram.Item(System.Int32)" access="Public" contract="Normal" typeId="T:System.Double" valueType="true" get="Public" set="Public">
            <documentation><summary> The data of the histogram. </summary>
<param name="column">Which column of the histogram you want.</param>
<returns>A double value between 0 and 1.</returns></documentation>
            <parameter name="column" typeId="T:System.Int32" valueType="true" />
          </property>
          <method name="FromSnapshot" displayName="FromSnapshot" id="M:Microsoft.Test.VisualVerification.Histogram.FromSnapshot(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Histogram" id="T:Microsoft.Test.VisualVerification.Histogram" />
            <documentation><summary> Creates a Histogram object from an existing Snapshot object. </summary>
<param name="snapshot">The Snapshot object to derive the Histogram from.</param>
<returns>A new instance of Histogram, based on the provided snapshot.</returns></documentation>
            <parameter name="snapshot" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
          <method name="FromFile" displayName="FromFile" id="M:Microsoft.Test.VisualVerification.Histogram.FromFile(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Histogram" id="T:Microsoft.Test.VisualVerification.Histogram" />
            <documentation><summary> Creates a Histogram object from a histogram curve file. </summary>
<param name="filePath">Name of the file containing the histogram curve.</param>
<returns>A new instance of Histogram, based on the specified file.</returns></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
          <method name="ToGraph" displayName="ToGraph" id="M:Microsoft.Test.VisualVerification.Histogram.ToGraph(System.String,System.Drawing.Imaging.ImageFormat)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Create a snapshot to visualize this histogram, and save it to a file. The graph will be 100 pixels high and 256 columns wide - one for each 'bin' in the histogram. The snapshot generated will be framed and slightly larger. </summary></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
            <parameter name="imageFormat" typeId="T:System.Drawing.Imaging.ImageFormat" valueType="false" />
          </method>
          <method name="Merge" displayName="Merge" id="M:Microsoft.Test.VisualVerification.Histogram.Merge(Microsoft.Test.VisualVerification.Histogram)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Histogram" id="T:Microsoft.Test.VisualVerification.Histogram" />
            <documentation><summary> Merges the specified input histogram curve with the current histogram by accumulating the per-brightness peak error quantities of two histograms. The Merge operation merges the peak values of the two histograms. </summary>
<param name="histogram">The histogram curve to be merged with.</param>
<returns>A new Histogram object, containing the peak values of both histogram curves.</returns></documentation>
            <parameter name="histogram" typeId="T:Microsoft.Test.VisualVerification.Histogram" valueType="false" />
          </method>
          <method name="ToFile" displayName="ToFile" id="M:Microsoft.Test.VisualVerification.Histogram.ToFile(System.String)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Saves the Histogram object to an XML file representation. </summary>
<param name="filePath">The path of the XML histogram file to be stored.</param></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="Snapshot" displayName="Snapshot" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.Snapshot" access="Public">
          <documentation><summary> Represents image pixels in a two-dimensional array for use in visual verification. Every element of the array represents a pixel at the given [row, column] of the image. A Snapshot object can be instantiated from a file or captured from the screen. </summary>
<example>Takes a snapshot and verifies it is an absolute match to an expected image. <code>        // Take a snapshot, compare to master image, validate match and save the diff
        // in case of a poor match.
        Snapshot actual = Snapshot.FromRectangle(new Rectangle(0, 0, 800, 600));
        Snapshot expected = Snapshot.FromFile("Expected.bmp");
        Snapshot diff = actual.CompareTo(expected);
     
        // The SnapshotColorVerifier.Verify() method compares every pixel of a diff bitmap 
        // against the threshold defined by the ColorDifference tolerance. If all pixels
        // fall within the tolerance, then the method returns VerificationResult.Pass
        SnapshotVerifier v = new SnapshotColorVerifier(Color.Black, new ColorDifference(0, 0, 0, 0));
        if (v.Verify(diff) == VerificationResult.Fail)
        {
            diff.ToFile("Actual.bmp", ImageFormat.Bmp);
        }
</code></example></documentation>
          <implementsClass type="System.ICloneable" id="T:System.ICloneable" displayName="ICloneable" namespace="System" />
          <property name="Item" id="P:Microsoft.Test.VisualVerification.Snapshot.Item(System.Int32,System.Int32)" access="Public" contract="Normal" typeId="T:System.Drawing.Color" valueType="true" get="Public" set="Public">
            <documentation><summary> Returns a Color instance for the pixel at the specified row and column. </summary>
<param name="row">Zero-based row position of the pixel.</param>
<param name="column">Zero-based column position of the pixel.</param>
<returns>A Color instance for the pixel at the specified row and column.</returns></documentation>
            <parameter name="row" typeId="T:System.Int32" valueType="true" />
            <parameter name="column" typeId="T:System.Int32" valueType="true" />
          </property>
          <property name="Width" id="P:Microsoft.Test.VisualVerification.Snapshot.Width" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Returns the width of the pixel buffer. </summary></documentation>
          </property>
          <property name="Height" id="P:Microsoft.Test.VisualVerification.Snapshot.Height" access="Public" contract="Normal" typeId="T:System.Int32" valueType="true" get="Public" set="false">
            <documentation><summary> Returns the height of the pixel buffer. </summary></documentation>
          </property>
          <method name="FromFile" displayName="FromFile" id="M:Microsoft.Test.VisualVerification.Snapshot.FromFile(System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a Snapshot instance from data in the specified image file. </summary>
<param name="filePath">Path to the image file.</param>
<returns>A Snapshot instance containing the pixels in the loaded file.</returns></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
          </method>
          <method name="FromWindow" displayName="FromWindow" id="M:Microsoft.Test.VisualVerification.Snapshot.FromWindow(System.IntPtr,Microsoft.Test.VisualVerification.WindowSnapshotMode)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a Snapshot instance populated with pixels sampled from the rectangle of the specified window. </summary>
<param name="windowHandle">The Win32 window handle (also known as an HWND), identifying the window to capture from.</param>
<param name="windowSnapshotMode">Determines if window border region should captured as part of Snapshot.</param>
<returns>A Snapshot instance of the pixels captured.</returns></documentation>
            <parameter name="windowHandle" typeId="T:System.IntPtr" valueType="true" />
            <parameter name="windowSnapshotMode" typeId="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" valueType="true" />
          </method>
          <method name="FromRectangle" displayName="FromRectangle" id="M:Microsoft.Test.VisualVerification.Snapshot.FromRectangle(System.Drawing.Rectangle)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a Snapshot instance populated with pixels sampled from the specified screen rectangle, from the context of the Desktop. </summary>
<param name="rectangle">Rectangle of the screen region to be sampled from.</param>
<returns>A Snapshot instance of the pixels from the bounds of the screen rectangle.</returns></documentation>
            <parameter name="rectangle" typeId="T:System.Drawing.Rectangle" valueType="true" />
          </method>
          <method name="FromBitmap" displayName="FromBitmap" id="M:Microsoft.Test.VisualVerification.Snapshot.FromBitmap(System.Drawing.Bitmap)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Instantiates a Snapshot representation from a Windows Bitmap. </summary>
<param name="source">Source bitmap to be converted.</param>
<returns>A snapshot based on the source buffer.</returns></documentation>
            <parameter name="source" typeId="T:System.Drawing.Bitmap" valueType="false" />
          </method>
          <method name="Clone" displayName="Clone" id="M:Microsoft.Test.VisualVerification.Snapshot.Clone" access="Public" contract="Final" valueType="false">
            <returnType type="System.Object" id="T:System.Object" />
            <documentation><summary> Creates a deep-copied clone Snapshot with the same value as the existing instance. </summary>
<returns>Clone instance</returns></documentation>
            <implements name="Clone" id="M:System.ICloneable.Clone" interface="ICloneable" interfaceId="T:System.ICloneable" assembly="mscorlib" declaringType="System.ICloneable" />
          </method>
          <method name="CompareTo" displayName="CompareTo" id="M:Microsoft.Test.VisualVerification.Snapshot.CompareTo(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal" valueType="false" overload="1">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Compares the current Snapshot instance to the specified Snapshot to produce a difference image. Note: This does not compare alpha channels. </summary>
<param name="snapshot">The Snapshot to be compared to.</param>
<returns>A new Snapshot object representing the difference image (i.e. the result of the comparison).</returns></documentation>
            <parameter name="snapshot" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
          <method name="CompareTo" displayName="CompareTo" id="M:Microsoft.Test.VisualVerification.Snapshot.CompareTo(Microsoft.Test.VisualVerification.Snapshot,System.Boolean)" access="Public" contract="Normal" valueType="false" overload="2">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Compares the current Snapshot instance to the specified Snapshot to produce a difference image. </summary>
<param name="snapshot">The target Snapshot to be compared to.</param>
<param name="compareAlphaChannel">If true, compares alpha channels. If false, the alpha channel difference values are fixed to 255.</param>
<returns>A new Snapshot object representing the difference image (i.e. the result of the comparison).</returns></documentation>
            <parameter name="snapshot" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
            <parameter name="compareAlphaChannel" typeId="T:System.Boolean" valueType="true" />
          </method>
          <method name="DrawLine" displayName="DrawLine" id="M:Microsoft.Test.VisualVerification.Snapshot.DrawLine(System.Int32,System.Int32,System.Int32,System.Drawing.Color)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Draw a vertical line from the bottom of the specified column up to the height given. </summary>
<param name="col">which column to draw in</param>
<param name="floor">the lowest pixel of the line</param>
<param name="height">the height of the line</param>
<param name="color">the color of the line</param></documentation>
            <parameter name="col" typeId="T:System.Int32" valueType="true" />
            <parameter name="floor" typeId="T:System.Int32" valueType="true" />
            <parameter name="height" typeId="T:System.Int32" valueType="true" />
            <parameter name="color" typeId="T:System.Drawing.Color" valueType="true" />
          </method>
          <method name="ToFile" displayName="ToFile" id="M:Microsoft.Test.VisualVerification.Snapshot.ToFile(System.String,System.Drawing.Imaging.ImageFormat)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Writes the current Snapshot (at 32 bits per pixel) to a file. </summary>
<param name="filePath">The path to the output file.</param>
<param name="imageFormat">The file storage format to be used.</param></documentation>
            <parameter name="filePath" typeId="T:System.String" valueType="false" />
            <parameter name="imageFormat" typeId="T:System.Drawing.Imaging.ImageFormat" valueType="false" />
          </method>
          <method name="Crop" displayName="Crop" id="M:Microsoft.Test.VisualVerification.Snapshot.Crop(System.Drawing.Rectangle)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a new Snapshot based on the cropped bounds of the current snapshot. </summary>
<param name="bounds">The bounding rectangle of the Snapshot.</param>
<returns></returns></documentation>
            <parameter name="bounds" typeId="T:System.Drawing.Rectangle" valueType="true" />
          </method>
          <method name="Resize" displayName="Resize" id="M:Microsoft.Test.VisualVerification.Snapshot.Resize(System.Drawing.Size)" access="Public" contract="Normal" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a new Snapshot of the specified size from the original using bilinear interpolation. </summary>
<param name="size">Desired size of new image</param>
<returns></returns></documentation>
            <parameter name="size" typeId="T:System.Drawing.Size" valueType="true" />
          </method>
          <method name="Or" displayName="Or" id="M:Microsoft.Test.VisualVerification.Snapshot.Or(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Modifies the current image to contain the result of a bitwise OR of this Snapshot and the mask. This technique can be used to merge data from two images. http://en.wikipedia.org/wiki/Bitmask#Image_masks </summary>
<param name="mask">Mask Snapshot to use in the bitwise OR operation.</param></documentation>
            <parameter name="mask" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
          <method name="And" displayName="And" id="M:Microsoft.Test.VisualVerification.Snapshot.And(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Modifies the current image to contain the result of a bitwise AND of this Snapshot and the mask. This technique can be used to remove data from an image. http://en.wikipedia.org/wiki/Bitmask#Image_masks </summary>
<param name="mask">Mask Snapshot to use in the bitwise AND operation.</param></documentation>
            <parameter name="mask" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" access="Public" abstract="true">
          <documentation><summary> Base class for all Snapshot verifier types. This establishes a single method contract: Verify(Snapshot). </summary></documentation>
          <derivedBy id="T:Microsoft.Test.VisualVerification.SnapshotColorVerifier" displayName="SnapshotColorVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier" displayName="SnapshotHistogramVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <derivedBy id="T:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier" displayName="SnapshotToleranceMapVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotVerifier.#ctor" access="Family" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.VisualVerification.SnapshotVerifier" /> class.</summary>
            </documentation>
          </constructor>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Abstract" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Verifies the specified Snapshot instance against the current settings of the SnapshotVerifier instance. </summary>
<param name="image">The image to be verified.</param>
<returns>The verification result based on the supplied image and the current settings of the SnapshotVerifier instance.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotColorVerifier" displayName="SnapshotColorVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotColorVerifier" access="Public">
          <documentation><summary> Verifies that all pixels in a Snapshot are within tolerance range of ExpectedColor. </summary></documentation>
          <baseType name="SnapshotVerifier" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotColorVerifier.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of a SnapshotColorVerifier class, using black pixels with zero tolerance. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotColorVerifier.#ctor(System.Drawing.Color,Microsoft.Test.VisualVerification.ColorDifference)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the SnapshotColorVerifier class, using the specified tolerance value. </summary>
<param name="expectedColor">The expected color to test against.</param>
<param name="tolerance">A ColorDifference instance specifying the desired tolerance.</param></documentation>
            <parameter name="expectedColor" typeId="T:System.Drawing.Color" valueType="true" />
            <parameter name="tolerance" typeId="T:Microsoft.Test.VisualVerification.ColorDifference" valueType="false" />
          </constructor>
          <property name="Tolerance" id="P:Microsoft.Test.VisualVerification.SnapshotColorVerifier.Tolerance" access="Public" contract="Normal" typeId="T:Microsoft.Test.VisualVerification.ColorDifference" valueType="false" get="Public" set="Public">
            <documentation><summary> The color tolerance range for verification. To pass verification, all Snapshot pixels must be within range of the expected color tolerance. </summary></documentation>
          </property>
          <property name="ExpectedColor" id="P:Microsoft.Test.VisualVerification.SnapshotColorVerifier.ExpectedColor" access="Public" contract="Normal" typeId="T:System.Drawing.Color" valueType="true" get="Public" set="Public">
            <documentation><summary> The expected Color value for verification. </summary></documentation>
          </property>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotColorVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Override" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Ensures that the image colors are all within tolerance range of the expected Color. </summary>
<param name="image">The actual image being verified.</param>
<returns>A VerificationResult enumeration value based on the image, the expected color, and the tolerance.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotHistogramVerifier" displayName="SnapshotHistogramVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier" access="Public">
          <documentation><summary> Verifies a diffed image based on the number of pixels of a given brightness per color. A tolerance Histogram curve can be created from an XML file, produced from a reference image, or manually created for use as a tolerance. <p /> For more information on histograms, refer to the description of the Histogram class. </summary>
<example>Takes a snapshot and verifies it is an absolute match to an expected image. <code>        // Take a snapshot, compare to a master image, validate match using a tolerance histogram 
        // and save the diff in case of a poor match.
        Snapshot actual = Snapshot.FromRectangle(new Rectangle(0, 0, 800, 600));
        Snapshot expected = Snapshot.FromFile("Expected.bmp");
        Snapshot diff = actual.CompareTo(expected);
     
        SnapshotVerifier v = new SnapshotHistogramVerifier(Histogram.FromFile("ToleranceHistogram.xml"));
        if (v.Verify(diff) == VerificationResult.Fail)
        {
            diff.ToFile("Actual.bmp", ImageFormat.Bmp);
        }
</code></example></documentation>
          <baseType name="SnapshotVerifier" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.#ctor" access="Public" contract="Normal" overload="1">
            <documentation><summary> Initializes a new instance of the SnapshotHistgramVerifier class, with the tolerance histogram curve initialized to zero tolerance for non-black values. </summary></documentation>
          </constructor>
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.#ctor(Microsoft.Test.VisualVerification.Histogram)" access="Public" contract="Normal" overload="2">
            <documentation><summary> Initializes a new instance of the SnapshotHistgramVerifier class, with the tolerance histogram curve initialized to the specified tolerance value. </summary>
<param name="tolerance">The tolerance Histogram to use for verification.</param></documentation>
            <parameter name="tolerance" typeId="T:Microsoft.Test.VisualVerification.Histogram" valueType="false" />
          </constructor>
          <property name="Tolerance" id="P:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.Tolerance" access="Public" contract="Normal" typeId="T:Microsoft.Test.VisualVerification.Histogram" valueType="false" get="Public" set="Public">
            <documentation><summary> The tolerance Histogram that is used to test snapshots; snapshots must produce a histogram which falls below this curve in order to pass. </summary></documentation>
          </property>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotHistogramVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Override" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Verifies a diffed image based on the number of pixels of a given brightness per color. A tolerance Histogram curve can be created from an XML file, produced from a reference image, or manually created for use as a tolerance. </summary>
<param name="image">The actual Snapshot to be verified.</param>
<returns>A VerificationResult enumeration value based on the image, the expected color, and the tolerance.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <class name="SnapshotToleranceMapVerifier" displayName="SnapshotToleranceMapVerifier" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier" access="Public">
          <documentation><summary> Verifies that all pixels in a Snapshot are within the tolerance range, defined by the tolerance map. </summary>
<example> This sample demonstrates the use of SnapshotToleranceMapVerifier. <code>        Snapshot expected = Shapshot.FromFile("expectedImage.png");
        Shapshot actual = Snapshot.FromRectangle(new Rectangle(10, 10, 200, 100));
        Snapshot diff = actual.CompareTo(master);
        
        Snapshot toleranceMap = Snapshot.FromFile("expectedImageTolerances.png");

        SnapshotVerifier v = new SnapshotToleranceMapVerifier(toleranceMap);
        if (v.Verify() == VerificationResult.Pass)
        {
            // Log success
        }
        else
        {
            // Log failure. Store the actual snapshot and the diff for investigation
            actual.ToFile("actualImage.png");
            diff.ToFile("diffImage.png");
        }
</code></example></documentation>
          <baseType name="SnapshotVerifier" id="T:Microsoft.Test.VisualVerification.SnapshotVerifier" displayName="SnapshotVerifier" namespace="Microsoft.Test.VisualVerification" assembly="TestApiCore" />
          <constructor name=".ctor" id="M:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier.#ctor(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Normal">
            <documentation><summary> Initializes a new instance of the SnapshotToleranceMapVerifier class, using the specified tolerance map. </summary>
<param name="toleranceMap"> A Snapshot instance defining the tolerance map, used by the verifier. A black tolerance map (a snapshot, where all pixels are with zero values) means zero tolerance. A white tolerance map (a snapshot, where all pixels are with value 0xFF) means infinitely high tolerance. </param></documentation>
            <parameter name="toleranceMap" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </constructor>
          <property name="ToleranceMap" id="P:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier.ToleranceMap" access="Public" contract="Normal" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" get="Public" set="Public">
            <documentation><summary> A Snapshot defining the tolerance map used by the verifier. A black tolerance map (a snapshot, where all pixels are with zero values) means zero tolerance. A white tolerance map (a snapshot, where all pixels are with value 0xFF) means infinitely high tolerance. </summary></documentation>
          </property>
          <method name="Verify" displayName="Verify" id="M:Microsoft.Test.VisualVerification.SnapshotToleranceMapVerifier.Verify(Microsoft.Test.VisualVerification.Snapshot)" access="Public" contract="Override" valueType="true">
            <returnType type="Microsoft.Test.VisualVerification.VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" />
            <documentation><summary> Ensures that the image colors are all with smaller values than the image colors of the tolerance map. </summary>
<param name="image">The actual image being verified.</param>
<returns>A VerificationResult enumeration value based on the image, and the tolerance map.</returns></documentation>
            <parameter name="image" typeId="T:Microsoft.Test.VisualVerification.Snapshot" valueType="false" />
          </method>
        </class>
        <enumeration name="VerificationResult" id="T:Microsoft.Test.VisualVerification.VerificationResult" displayName="VerificationResult" namespace="Microsoft.Test.VisualVerification" access="Public">
          <documentation><summary> Specifies values used to report the outcome of a verification. </summary></documentation>
          <field name="Fail" id="F:Microsoft.Test.VisualVerification.VerificationResult.Fail" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.VerificationResult" valueType="true" literal="true" value="0">
            <documentation><summary> Object does not meet verification criteria. </summary></documentation>
          </field>
          <field name="Pass" id="F:Microsoft.Test.VisualVerification.VerificationResult.Pass" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.VerificationResult" valueType="true" literal="true" value="1">
            <documentation><summary> Object meets verification criteria. </summary></documentation>
          </field>
        </enumeration>
        <enumeration name="WindowSnapshotMode" id="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" displayName="WindowSnapshotMode" namespace="Microsoft.Test.VisualVerification" access="Public">
          <documentation><summary> WindowSnapshotMode determines if window border should be captured as part of Snapshot. </summary></documentation>
          <field name="ExcludeWindowBorder" id="F:Microsoft.Test.VisualVerification.WindowSnapshotMode.ExcludeWindowBorder" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" valueType="true" literal="true" value="0">
            <documentation><summary> Capture a snapshot of only the window client area. This mode excludes the window border. </summary></documentation>
          </field>
          <field name="IncludeWindowBorder" id="F:Microsoft.Test.VisualVerification.WindowSnapshotMode.IncludeWindowBorder" access="Public" contract="Static" typeId="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" valueType="true" literal="true" value="1">
            <documentation><summary> Capture a snapshot of the entire window area. This mode includes the window border. </summary></documentation>
          </field>
        </enumeration>
      </namespace>
    </module>
  </assembly>
  <assembly name="TestApiWpf">
    <assemblyReference name="mscorlib" />
    <assemblyReference name="TestApiCore" />
    <assemblyReference name="UIAutomationClient" />
    <assemblyReference name="UIAutomationTypes" />
    <assemblyReference name="WindowsBase" />
    <assemblyReference name="System" />
    <assemblyReference name="PresentationCore" />
    <assemblyReference name="PresentationFramework" />
    <assemblyReference name="System.Core" />
    <assemblyReference name="System.Drawing" />
    <module name="TestApiWpf.dll">
      <namespace name="Microsoft.Test">
        <class name="AutomationUtilities" displayName="AutomationUtilities" namespace="Microsoft.Test" id="T:Microsoft.Test.AutomationUtilities" access="Public" static="true">
          <documentation><summary> The AutomationUtilities class provides a simple interface to common <a href="http://msdn.microsoft.com/en-us/library/ms747327.aspx">UI Automation</a> (UIA) operations. The most common class of UIA operations in testing involves discovery of UI elements. </summary>
<example> This sample discovers and clicks the "Close" button in an "About" dialog box, thus dismissing the "About" dialog box. <code>        string aboutDialogName = "About";
        string closeButtonName = "Close";

        AutomationElementCollection aboutDialogs = AutomationUtilities.FindElementsByName(
            AutomationElement.RootElement,
            aboutDialogName);

        AutomationElementCollection closeButtons = AutomationUtilities.FindElementsByName(
            aboutDialogs[0],
            closeButtonName);

        // You can either invoke the discovered control, through its invoke pattern ...
        InvokePattern p = 
            closeButtons[0].GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;
        p.Invoke();

        // ... or you can handle the mouse directly and click on the control.
        System.Windows.Point winPoint = closeButtons[0].GetClickablePoint();
        System.Drawing.Point drawingPoint = new System.Drawing.Point((int)winPoint.X, (int)winPoint.Y);
        Mouse.MoveTo(drawingPoint);
        Mouse.Click(System.Windows.Input.MouseButton.Left);
</code></example></documentation>
          <method name="FindElementByIndex" displayName="FindElementByIndex" id="M:Microsoft.Test.AutomationUtilities.FindElementByIndex(System.Windows.Automation.AutomationElement,System.Int32)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElement" id="T:System.Windows.Automation.AutomationElement" />
            <documentation><summary> Retrieves the child element with the specified index. </summary>
<param name="rootElement">The parent element (e.g., a ListBox control).</param>
<param name="index"> The index of the child element to find.</param>
<returns>An AutomationElement representing the discovered child element.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="index" typeId="T:System.Int32" valueType="true" />
          </method>
          <method name="FindElements" displayName="FindElements" id="M:Microsoft.Test.AutomationUtilities.FindElements(System.Windows.Automation.AutomationElement,System.Windows.Automation.Condition[])" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves all UIA elements that meet the specified conditions. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="conditions">Conditions that the returned collection should meet.</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="conditions" typeId="T:System.Windows.Automation.Condition" valueType="false" isParamArray="true" />
          </method>
          <method name="FindElementsByClassName" displayName="FindElementsByClassName" id="M:Microsoft.Test.AutomationUtilities.FindElementsByClassName(System.Windows.Automation.AutomationElement,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements with a given class name. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="className">The class name of the control type to find.</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="className" typeId="T:System.String" valueType="false" />
          </method>
          <method name="FindElementsByControlType" displayName="FindElementsByControlType" id="M:Microsoft.Test.AutomationUtilities.FindElementsByControlType(System.Windows.Automation.AutomationElement,System.Windows.Automation.ControlType)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements of a given control type. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="controlType">Control type of the control, such as Button.</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="controlType" typeId="T:System.Windows.Automation.ControlType" valueType="false" />
          </method>
          <method name="FindElementsById" displayName="FindElementsById" id="M:Microsoft.Test.AutomationUtilities.FindElementsById(System.Windows.Automation.AutomationElement,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements with a given UIA identifier. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="automationId">UIA identifier of the searched element, such as "button1".</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="automationId" typeId="T:System.String" valueType="false" />
          </method>
          <method name="FindElementsByName" displayName="FindElementsByName" id="M:Microsoft.Test.AutomationUtilities.FindElementsByName(System.Windows.Automation.AutomationElement,System.String)" access="Public" contract="Static" valueType="false">
            <returnType type="System.Windows.Automation.AutomationElementCollection" id="T:System.Windows.Automation.AutomationElementCollection" />
            <documentation><summary> Retrieves a UIA collection of all elements with a given name. </summary>
<param name="rootElement">Parent element, such as an application window, or AutomationElement.RootElement when searching for the application window.</param>
<param name="name">Name of the searched element, such as "button1".</param>
<returns>A UIA element collection.</returns></documentation>
            <parameter name="rootElement" typeId="T:System.Windows.Automation.AutomationElement" valueType="false" />
            <parameter name="name" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="DispatcherOperations" displayName="DispatcherOperations" namespace="Microsoft.Test" id="T:Microsoft.Test.DispatcherOperations" access="Public" static="true">
          <documentation><summary> Helper class for the WPF Dispatcher. This class provides simple and consistent wrappers for common dispatcher operations. </summary>
<example>
  <code>        // SAMPLE USAGE #1:
        // Move the mouse to a certain location on the screen. Wait for a popup to appear. 
        // Verify that it appeared.
        TimeSpan defaultPopupDelay = TimeSpan.FromSeconds(2);
        Mouse.MoveTo(new System.Drawing.Point(100, 100));
        DispatcherOperations.WaitFor(defaultPopupDelay);
        // verify that the popup showed up.

        // SAMPLE USAGE #2:
        // Click on a button and verify that a mouse click event handler gets called.
        Mouse.MoveTo(new System.Drawing.Point(100, 100));
        Mouse.Click(System.Windows.Input.MouseButton.Left);
        DispatcherOperations.WaitFor(DispatcherPriority.SystemIdle);
        // verify that the handler has been clicked (e.g. check a isClicked variable)
</code>
</example></documentation>
          <method name="WaitFor" displayName="WaitFor" id="M:Microsoft.Test.DispatcherOperations.WaitFor(System.Windows.Threading.DispatcherPriority)" access="Public" contract="Static" valueType="true" overload="1">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> This method will wait until all pending DispatcherOperations of a priority higher than the specified priority have been processed. </summary>
<param name="priority">The priority to wait for before continuing.</param></documentation>
            <parameter name="priority" typeId="T:System.Windows.Threading.DispatcherPriority" valueType="true" />
          </method>
          <method name="WaitFor" displayName="WaitFor" id="M:Microsoft.Test.DispatcherOperations.WaitFor(System.TimeSpan)" access="Public" contract="Static" valueType="true" overload="2">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> This method will wait for the specified TimeSpan, allowing pending DispatcherOperations (such as UI rendering) to continue during that time. This method should be used with caution. Waiting for time is generally discouraged, because it may have an adverse effect on the overall run time of a test suite when the test suite has a large number of tests. </summary>
<param name="time">Amount of time to wait.</param></documentation>
            <parameter name="time" typeId="T:System.TimeSpan" valueType="true" />
          </method>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.ApplicationControl">
        <class name="UIAutomationOutOfProcessApplicationFactory" displayName="UIAutomationOutOfProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" access="Public">
          <documentation><summary> Factory for a UIAutomation implementation that AutomatedApplication will consume. </summary></documentation>
          <implementsClass type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory" /> class.</summary>
            </documentation>
          </constructor>
          <method name="Create" displayName="Create" id="M:Microsoft.Test.ApplicationControl.UIAutomationOutOfProcessApplicationFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" access="Public" contract="Final" valueType="false">
            <returnType type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
            <documentation><summary> Factory method for creating the IAutomatedApplicationImpl instance to be used by AutomatedApplication. </summary>
<param name="settings">The settings needed to create the specific instance</param>
<param name="appDomain">The UIAutomation app proxy does not require initialization on a separate appdomain</param>
<returns>Returns the application implementation of UIAutomation for an OutOfProcessApplication</returns></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.ApplicationSettings" valueType="false" />
            <parameter name="appDomain" typeId="T:System.AppDomain" valueType="false" />
            <implements name="Create" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" interface="IAutomatedApplicationImplFactory" interfaceId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" declaringType="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" />
          </method>
        </class>
        <class name="WpfInProcessApplicationFactory" displayName="WpfInProcessApplicationFactory" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" access="Public">
          <documentation><summary> Factory for a WpfApplication implementation that AutomatedApplication will consume. </summary></documentation>
          <implementsClass type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" displayName="IAutomatedApplicationImplFactory" namespace="Microsoft.Test.ApplicationControl" />
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory" /> class.</summary>
            </documentation>
          </constructor>
          <method name="Create" displayName="Create" id="M:Microsoft.Test.ApplicationControl.WpfInProcessApplicationFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" access="Public" contract="Final" valueType="false">
            <returnType type="Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" id="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImpl" />
            <documentation><summary> Factory method for creating the IAutomatedApplicationImpl instance to be used by AutomatedApplication. </summary>
<param name="settings">The settings needed to create the specific instance</param>
<param name="appDomain"> The AppDomain to create the implementation in. This will be null for scenarios where separate AppDomain is not specified. </param>
<returns>Returns the application implementation of Wpf for an InProcessApplication</returns></documentation>
            <parameter name="settings" typeId="T:Microsoft.Test.ApplicationControl.ApplicationSettings" valueType="false" />
            <parameter name="appDomain" typeId="T:System.AppDomain" valueType="false" />
            <implements name="Create" id="M:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory.Create(Microsoft.Test.ApplicationControl.ApplicationSettings,System.AppDomain)" interface="IAutomatedApplicationImplFactory" interfaceId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" assembly="TestApiCore" declaringType="Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" />
          </method>
        </class>
        <class name="WpfInProcessApplicationSettings" displayName="WpfInProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" id="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" access="Public">
          <documentation><summary> Configures a WPF in-process test application. </summary></documentation>
          <attribute name="System.SerializableAttribute" />
          <baseType name="InProcessApplicationSettings" id="T:Microsoft.Test.ApplicationControl.InProcessApplicationSettings" displayName="InProcessApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore">
            <baseType name="ApplicationSettings" id="T:Microsoft.Test.ApplicationControl.ApplicationSettings" displayName="ApplicationSettings" namespace="Microsoft.Test.ApplicationControl" assembly="TestApiCore" />
          </baseType>
          <constructor name=".ctor" id="M:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.#ctor" access="Public" contract="Normal">
            <documentation>
              <summary>Initializes a new instance of the <see cref="T:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings" /> class.</summary>
            </documentation>
          </constructor>
          <property name="WindowClassName" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.WindowClassName" access="Public" contract="Normal" typeId="T:System.String" valueType="false" get="Public" set="Public">
            <documentation><summary> The window class to start. </summary>
<remarks> This must be the full class name. </remarks></documentation>
          </property>
          <property name="Path" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.Path" access="Public" contract="Normal" typeId="T:System.String" valueType="false" declaringType="Microsoft.Test.ApplicationControl.InProcessApplicationSettings" get="Public" set="Public">
            <documentation><summary> The application path to test. </summary></documentation>
          </property>
          <property name="InProcessApplicationType" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.InProcessApplicationType" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.InProcessApplicationType" valueType="true" declaringType="Microsoft.Test.ApplicationControl.InProcessApplicationSettings" get="Public" set="Public">
            <documentation><summary> The type of test application to create. </summary></documentation>
          </property>
          <property name="ApplicationImplementationFactory" id="P:Microsoft.Test.ApplicationControl.WpfInProcessApplicationSettings.ApplicationImplementationFactory" access="Public" contract="Normal" typeId="T:Microsoft.Test.ApplicationControl.IAutomatedApplicationImplFactory" valueType="false" declaringType="Microsoft.Test.ApplicationControl.ApplicationSettings" get="Public" set="Public">
            <documentation><summary> The interface used for creation of the AutomatedApplicationImplementation. </summary></documentation>
          </property>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.Input">
        <class name="Keyboard" displayName="Keyboard" namespace="Microsoft.Test.Input" id="T:Microsoft.Test.Input.Keyboard" access="Public" static="true">
          <documentation><summary> Exposes a simple interface to common keyboard operations, allowing the user to simulate keyboard input. </summary>
<example> The following code types "Hello world" with the specified casing, and then types "hello, capitalized world" which will be in all caps because the left shift key is being held down. <code>            Keyboard.Type("Hello world");
            Keyboard.Press(Key.LeftShift);
            Keyboard.Type("hello, capitalized world");
            Keyboard.Release(Key.LeftShift);
</code></example></documentation>
          <method name="Press" displayName="Press" id="M:Microsoft.Test.Input.Keyboard.Press(System.Windows.Input.Key)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Presses down a key. </summary>
<param name="key">The key to press.</param></documentation>
            <parameter name="key" typeId="T:System.Windows.Input.Key" valueType="true" />
          </method>
          <method name="Release" displayName="Release" id="M:Microsoft.Test.Input.Keyboard.Release(System.Windows.Input.Key)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Releases a key. </summary>
<param name="key">The key to release.</param></documentation>
            <parameter name="key" typeId="T:System.Windows.Input.Key" valueType="true" />
          </method>
          <method name="Reset" displayName="Reset" id="M:Microsoft.Test.Input.Keyboard.Reset" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Resets the system keyboard to a clean state. </summary></documentation>
          </method>
          <method name="Type" displayName="Type" id="M:Microsoft.Test.Input.Keyboard.Type(System.Windows.Input.Key)" access="Public" contract="Static" valueType="true" overload="1">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Performs a press-and-release operation for the specified key, which is effectively equivallent to typing. </summary>
<param name="key">The key to press.</param></documentation>
            <parameter name="key" typeId="T:System.Windows.Input.Key" valueType="true" />
          </method>
          <method name="Type" displayName="Type" id="M:Microsoft.Test.Input.Keyboard.Type(System.String)" access="Public" contract="Static" valueType="true" overload="2">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Types the specified text. </summary>
<param name="text">The text to type.</param></documentation>
            <parameter name="text" typeId="T:System.String" valueType="false" />
          </method>
        </class>
        <class name="Mouse" displayName="Mouse" namespace="Microsoft.Test.Input" id="T:Microsoft.Test.Input.Mouse" access="Public" static="true">
          <documentation><summary> Exposes a simple interface to common mouse operations, allowing the user to simulate mouse input. </summary>
<example>The following code moves to screen coordinate 100,100 and left clicks. <code>        Mouse.MoveTo(new Point(100, 100));
        Mouse.Click(MouseButton.Left);
</code></example></documentation>
          <method name="Click" displayName="Click" id="M:Microsoft.Test.Input.Mouse.Click(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Clicks a mouse button. </summary>
<param name="mouseButton">The mouse button to click.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
          <method name="DoubleClick" displayName="DoubleClick" id="M:Microsoft.Test.Input.Mouse.DoubleClick(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Double-clicks a mouse button. </summary>
<param name="mouseButton">The mouse button to click.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
          <method name="Down" displayName="Down" id="M:Microsoft.Test.Input.Mouse.Down(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Performs a mouse-down operation for a specified mouse button. </summary>
<param name="mouseButton">The mouse button to use.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
          <method name="MoveTo" displayName="MoveTo" id="M:Microsoft.Test.Input.Mouse.MoveTo(System.Drawing.Point)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Moves the mouse pointer to the specified screen coordinates. </summary>
<param name="point">The screen coordinates to move to.</param></documentation>
            <parameter name="point" typeId="T:System.Drawing.Point" valueType="true" />
          </method>
          <method name="Reset" displayName="Reset" id="M:Microsoft.Test.Input.Mouse.Reset" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Resets the system mouse to a clean state. </summary></documentation>
          </method>
          <method name="Scroll" displayName="Scroll" id="M:Microsoft.Test.Input.Mouse.Scroll(System.Double)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Simulates scrolling of the mouse wheel up or down. </summary>
<param name="lines">The number of lines to scroll. Use positive numbers to scroll up and negative numbers to scroll down.</param></documentation>
            <parameter name="lines" typeId="T:System.Double" valueType="true" />
          </method>
          <method name="Up" displayName="Up" id="M:Microsoft.Test.Input.Mouse.Up(System.Windows.Input.MouseButton)" access="Public" contract="Static" valueType="true">
            <returnType type="System.Void" id="T:System.Void" />
            <documentation><summary> Performs a mouse-up operation for a specified mouse button. </summary>
<param name="mouseButton">The mouse button to use.</param></documentation>
            <parameter name="mouseButton" typeId="T:System.Windows.Input.MouseButton" valueType="true" />
          </method>
        </class>
      </namespace>
      <namespace name="Microsoft.Test.VisualVerification">
        <class name="SnapshotHelper" displayName="SnapshotHelper" namespace="Microsoft.Test.VisualVerification" id="T:Microsoft.Test.VisualVerification.SnapshotHelper" access="Public" static="true">
          <documentation><summary> WPF type centric helper, on top of the general purpose Snapshot. </summary></documentation>
          <method name="SnapshotFromWindow" displayName="SnapshotFromWindow" id="M:Microsoft.Test.VisualVerification.SnapshotHelper.SnapshotFromWindow(System.Windows.Media.Visual,Microsoft.Test.VisualVerification.WindowSnapshotMode)" access="Public" contract="Static" valueType="false">
            <returnType type="Microsoft.Test.VisualVerification.Snapshot" id="T:Microsoft.Test.VisualVerification.Snapshot" />
            <documentation><summary> Creates a Snapshot instance from a Wpf Window. </summary>
<param name="window">The Wpf Window, identifying the window to capture from.</param>
<param name="windowSnapshotMode">Determines if window border region should captured as part of Snapshot.</param>
<returns>A Snapshot instance of the pixels captured.</returns></documentation>
            <parameter name="window" typeId="T:System.Windows.Media.Visual" valueType="false" />
            <parameter name="windowSnapshotMode" typeId="T:Microsoft.Test.VisualVerification.WindowSnapshotMode" valueType="true" />
          </method>
        </class>
      </namespace>
    </module>
  </assembly>
</ndoc>